<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhangzef</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-03T10:22:35.102Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张泽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring--一、Spring概述及Spring中基于XML的IOC配置</title>
    <link href="http://yoursite.com/2019/10/02/Spring--%E4%B8%80%E3%80%81Spring%E6%A6%82%E8%BF%B0%E5%8F%8ASpring%E4%B8%AD%E5%9F%BA%E4%BA%8EXML%E7%9A%84IOC%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/</id>
    <published>2019-10-02T10:48:40.000Z</published>
    <updated>2019-10-03T10:22:35.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring–一、Spring概述及Spring中基于XML的IOC配置"><a href="#Spring–一、Spring概述及Spring中基于XML的IOC配置" class="headerlink" title="Spring–一、Spring概述及Spring中基于XML的IOC配置"></a>Spring–一、Spring概述及Spring中基于XML的IOC配置</h1><p>视频：<a href="https://www.bilibili.com/video/av47952931/?p=1" target="_blank" rel="noopener">Spring5教程IDEA版-4天-2018黑马</a></p><p><a href="https://pan.baidu.com/s/1V5WhXOqkjQ0CuEA8Zj504A" target="_blank" rel="noopener">教学资源</a>    提取码：cwbz</p><h2 id="1、Spring的概述（了解）"><a href="#1、Spring的概述（了解）" class="headerlink" title="1、Spring的概述（了解）"></a>1、Spring的概述（了解）</h2><h3 id="1-1、spring是什么"><a href="#1-1、spring是什么" class="headerlink" title="1.1、spring是什么"></a>1.1、spring是什么</h3><p>Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</p><h3 id="1-2、Spring的优势"><a href="#1-2、Spring的优势" class="headerlink" title="1.2、Spring的优势"></a>1.2、Spring的优势</h3><blockquote><p>  <strong>方便解耦，简化开发</strong></p><p>  通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p></blockquote><blockquote><p>  <strong>AOP编程的支持</strong></p><p>  通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p></blockquote><blockquote><p>  <strong>声明式事务的支持</strong></p><p>  可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。</p></blockquote><blockquote><p>  <strong>方便程序的测试</strong></p><p>  可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</p></blockquote><blockquote><p>  <strong>方便集成各种优秀框架</strong></p><p>  Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。</p></blockquote><blockquote><p>  <strong>降低JavaEE API的使用难度</strong></p><p>  Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。</p></blockquote><blockquote><p>  <strong>Java源码是经典学习范例</strong></p><p>  Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。</p></blockquote><h3 id="1-3、Spring的体系结构"><a href="#1-3、Spring的体系结构" class="headerlink" title="1.3、Spring的体系结构"></a>1.3、Spring的体系结构</h3><p><img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570021394756.png" alt="1570021394756" style="zoom:50%;"></p><p>Spring的两大核心为：AOP和IOC</p><p>AOP部分为：AOP、Aspects、Instrumentation、Messaging</p><p>IOC（核心容器）部分为Core Container部分</p><h2 id="2-IOC的概念和作用"><a href="#2-IOC的概念和作用" class="headerlink" title="2.IOC的概念和作用"></a>2.IOC的概念和作用</h2><h3 id="2-1、程序的耦合与解耦"><a href="#2-1、程序的耦合与解耦" class="headerlink" title="2.1、程序的耦合与解耦"></a>2.1、程序的耦合与解耦</h3><p>程序的耦合即程序间的依赖关系：①类之间的依赖关系。②方法间的依赖关系。</p><p>解耦即降低程序间的依赖关系，实际开发中应做到编译期不依赖，运行时才依赖：</p><ol><li>使用反射（Class.forName()）来创建对象，避免使用new来创建对象。</li><li>通过读取配置文件来获取要创建的对象的全限定类名。<ol><li>配置文件内容：唯一标识=全限定类名（key=value）</li></ol></li></ol><h3 id="2-2、工厂模式解耦"><a href="#2-2、工厂模式解耦" class="headerlink" title="2.2、工厂模式解耦"></a>2.2、工厂模式解耦</h3><p>在实际开发中我们可以把三层（参考JavaEE三层结构：Web(表现)层、业务层、DAO(数据)层）的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 </p><p>那么，这个读取配置文件，创建和获取三层对象的类就是工厂。</p><p>建议了解单例多例对象来提高工厂模式解耦效率。</p><h3 id="2-3、控制翻转-Inversion-Of-Control（IOC）"><a href="#2-3、控制翻转-Inversion-Of-Control（IOC）" class="headerlink" title="2.3、控制翻转-Inversion Of Control（IOC）"></a>2.3、控制翻转-Inversion Of Control（IOC）</h3><p>控制反转（IOC）即把创建对象的权利交给框架，是框架的重要特征，它包括依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）</p><p>原来我们创建对象是用new来<strong>主动</strong>创建的，即我们的项目对资源的使用是直接关联的，如图：<img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570085897052.png" alt="1570085897052" style="zoom:50%;"></p><p>现在，我们引入框架的工厂来帮我们创建生产对象，他负责给我们从指定容器中获取指定对象的类，这时候这个对象获取过来是不是我能用的，我们的应用本身已经无法得知了，工厂能得到哪个对象是根据配置文件中的全限定类名（key=value）获得的，我们的应用本身没有自主控制权。而原来的直接new的方法则应用本身是有自主控制权的。所以这种工厂模式降低了我们程序间的依赖关系，如图：<img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570086617087.png" alt="1570086617087" style="zoom:50%;"></p><p>即IOC用来削减计算机程序间的耦合。</p><h2 id="3、使用Spring的IOC解决程序耦合"><a href="#3、使用Spring的IOC解决程序耦合" class="headerlink" title="3、使用Spring的IOC解决程序耦合"></a>3、使用Spring的IOC解决程序耦合</h2><h3 id="3-1、Spring的开发包"><a href="#3-1、Spring的开发包" class="headerlink" title="3.1、Spring的开发包"></a>3.1、Spring的开发包</h3><p>官网：<a href="http://spring.io/" target="_blank" rel="noopener">http://spring.io/</a></p><p>Spring的目录结构：</p><ul><li>dcos：API和开发规范</li><li>libs：jar包和源码</li><li>schema：约束</li></ul><h3 id="3-2、Spring基于XML的IOC细节"><a href="#3-2、Spring基于XML的IOC细节" class="headerlink" title="3.2、Spring基于XML的IOC细节"></a>3.2、Spring基于XML的IOC细节</h3><h4 id="3-2-1、Spring中工厂的类结构图"><a href="#3-2-1、Spring中工厂的类结构图" class="headerlink" title="3.2.1、Spring中工厂的类结构图"></a>3.2.1、Spring中工厂的类结构图</h4><p><img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570088592204.png" alt="1570088592204" style="zoom:50%;"></p><p><img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/TIM截图20191003153640.png" alt="TIM截图20191003153640" style="zoom:50%;"></p><h5 id="3-2-1-1、BeanFactory和ApplicationContext的区别"><a href="#3-2-1-1、BeanFactory和ApplicationContext的区别" class="headerlink" title="3.2.1.1、BeanFactory和ApplicationContext的区别"></a>3.2.1.1、BeanFactory和ApplicationContext的区别</h5><p>BeanFactory 才是Spring 容器中的顶层接口。ApplicationContext 是它的子接口。</p><p>BeanFactory 和ApplicationContext 的区别：创建对象的时间点不一样。</p><ul><li>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。单例对象适用。常用此接口，Spring会根据对象的单例多例来选择。</li><li>BeanFactory：什么使用什么时候创建对象。多例对象适用。</li></ul><h5 id="3-2-1-2、ApplicationContext接口的实现类"><a href="#3-2-1-2、ApplicationContext接口的实现类" class="headerlink" title="3.2.1.2、ApplicationContext接口的实现类"></a>3.2.1.2、ApplicationContext接口的实现类</h5><ul><li>ClassPathXmlApplicationContext：<br>它是从类的根路径下加载配置文件 推荐使用这种</li><li>FileSystemXmlApplicationContext：<br>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</li><li>AnnotationConfigApplicationContext:<br>当我们使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。</li></ul><h4 id="3-2-2、IOC中bean标签和管理对象细节"><a href="#3-2-2、IOC中bean标签和管理对象细节" class="headerlink" title="3.2.2、IOC中bean标签和管理对象细节"></a>3.2.2、IOC中bean标签和管理对象细节</h4><h5 id="3-2-2-1、bean标签"><a href="#3-2-2-1、bean标签" class="headerlink" title="3.2.2.1、bean标签"></a>3.2.2.1、bean标签</h5><p>作用：</p><ul><li>用于配置对象让spring来创建的。 </li><li><p>默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</p><p>属性：</p></li><li><p>id：给对象在容器中提供一个唯一标识。用于获取对象。</p></li><li>class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</li><li>scope：指定对象的作用范围。<ul><li>singleton :默认值，单例的.</li><li>prototype :多例的. </li><li>request :WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中. </li><li>session :WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中.</li><li>global session :WEB项目中,应用在Portlet环境.如果没有Portlet环境那么globalSession相当于session. </li></ul></li><li>init-method：指定类中的初始化方法名称。</li><li>destroy-method：指定类中销毁方法名称。</li></ul><h5 id="3-2-2-2bean的作用范围和生命周期"><a href="#3-2-2-2bean的作用范围和生命周期" class="headerlink" title="3.2.2.2bean的作用范围和生命周期"></a>3.2.2.2bean的作用范围和生命周期</h5><p>单例对象：scope=”singleton” </p><ul><li>一个应用只有一个对象的实例。它的作用范围就是整个引用。 </li><li>生命周期： <ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。 </li><li>对象活着：只要容器在，对象一直活着。 </li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。 </li></ul></li></ul><p>多例对象：scope=”prototype” </p><ul><li>每次访问对象时，都会重新创建对象实例。 </li><li>生命周期： <ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。 </li><li>对象死亡：当对象长时间不用时，被java的垃圾回收器回收了。</li></ul></li></ul><h5 id="3-2-2-3、实例化bean的三种方式"><a href="#3-2-2-3、实例化bean的三种方式" class="headerlink" title="3.2.2.3、实例化bean的三种方式"></a>3.2.2.3、实例化bean的三种方式</h5><p>第一种方式：使用默认无参构造函数 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在默认情况下： 它会根据默认无参构造函数来创建类对象。如果bean中没有默认无参构造函数，将会创建失败。--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方式：spring管理静态工厂-使用静态工厂的方法创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*模拟一个静态工厂，创建业务层实现类*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title">createAccountService</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此种方式是:</span></span><br><span class="line"><span class="comment">使用StaticFactory类中的静态方法createAccountService创建对象，并存入spring容器</span></span><br><span class="line"><span class="comment">id属性：指定bean的id，用于从容器中获取</span></span><br><span class="line"><span class="comment">class属性：指定静态工厂的全限定类名</span></span><br><span class="line"><span class="comment">factory-method属性：指定生产对象的静态方法</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.factory.StaticFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">"createAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三种方式：spring管理实例工厂-使用实例工厂的方法创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*模拟一个实例工厂，创建业务层实现类</span></span><br><span class="line"><span class="comment">*此工厂创建对象，必须现有工厂实例对象，再调用方法 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">createAccountService</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此种方式是： </span></span><br><span class="line"><span class="comment">先把工厂的创建交给spring来管理。 然后在使用工厂的bean来调用里面的方法 </span></span><br><span class="line"><span class="comment">factory-bean属性：用于指定实例工厂bean的id。 </span></span><br><span class="line"><span class="comment">factory-method属性：用于指定实例工厂中创建对象的方法。</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instancFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.factory.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-bean</span>=<span class="string">"instancFactory"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">"createAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3、Spring的依赖注入"><a href="#3-2-3、Spring的依赖注入" class="headerlink" title="3.2.3、Spring的依赖注入"></a>3.2.3、Spring的依赖注入</h4><h5 id="3-2-3-1、依赖注入的概念"><a href="#3-2-3-1、依赖注入的概念" class="headerlink" title="3.2.3.1、依赖注入的概念"></a>3.2.3.1、依赖注入的概念</h5><p>依赖注入是Spring框架核心IOC的具体实现</p><p>什么是依赖注入呢？即在当前类需要其他类的对象时，由Spring为我们提供，而不是自己创建，我们只需要在配置文件中说明依赖关系的维护。</p><p>依赖注入：</p><ul><li>能注入的数据有三类：<ul><li>基本类型和String</li><li>其他bean类型（在配置文件或注解配置过的bean）</li><li>复杂类型/集合类型</li></ul></li><li>注入的方式：<ul><li>使用构造函数提供</li><li>使用set方法提供</li><li>使用注解提供（下一篇）</li></ul></li></ul><h5 id="3-2-3-2、构造函数的依赖注入"><a href="#3-2-3-2、构造函数的依赖注入" class="headerlink" title="3.2.3.2、构造函数的依赖注入"></a>3.2.3.2、构造函数的依赖注入</h5><p>就是通过类的构造函数，给成员变量赋值。赋值操作是通过配置文件的方式，让Spring框架来帮我们注入。一般这种方式用于不经常更变的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是我们需要调用的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="keyword">private</span> Date birthday; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, </span></span></span><br><span class="line"><span class="function"><span class="params">                              Integer age, Date birthday)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用构造函数的方式，给service中的属性传值 </span></span><br><span class="line"><span class="comment">要求： </span></span><br><span class="line"><span class="comment">类中需要提供一个对应参数列表的构造函数。 </span></span><br><span class="line"><span class="comment">涉及的标签： constructor-arg （bean标签内部）</span></span><br><span class="line"><span class="comment">       属性： </span></span><br><span class="line"><span class="comment">        index:指定参数在构造函数参数列表的索引位置 </span></span><br><span class="line"><span class="comment">        type:指定参数在构造函数中的数据类型</span></span><br><span class="line"><span class="comment">        name:指定参数在构造函数中的名称 用这个找给谁赋值</span></span><br><span class="line"><span class="comment">=======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== </span></span><br><span class="line"><span class="comment">        value:它能赋的值是基本数据类型和String类型 </span></span><br><span class="line"><span class="comment">        ref:它能赋的值是其他bean类型，也就是说，必须得是在配置文件中配置过的bean </span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring注入的类型默认为字符串，要注入其他bean类型时，他不能强制转换成该类型，需要另外在配置文件中创建一个bean类型，让该类型的构造函数帮我们创建好，再将该类型通过配置文件传入要注入的对象。</p><p>优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</p><p>弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</p><h5 id="3-2-3-3、set方法注入"><a href="#3-2-3-3、set方法注入" class="headerlink" title="3.2.3.3、set方法注入"></a>3.2.3.3、set方法注入</h5><p>就是利用类中提供set方法类设置成员变量的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="keyword">private</span> Date birthday; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过配置文件给bean中的属性传值：使用set方法的方式 </span></span><br><span class="line"><span class="comment">涉及的标签： property（bean标签里面）</span></span><br><span class="line"><span class="comment">属性： </span></span><br><span class="line"><span class="comment">name：找的是类中set方法后面的部分 </span></span><br><span class="line"><span class="comment">ref：给属性赋值是其他bean类型的 </span></span><br><span class="line"><span class="comment">value：给属性赋值是基本数据类型和string类型的 </span></span><br><span class="line"><span class="comment">实际开发中，此种方式用的较多。 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优势：创建对象时没有明确的限制，可以直接使用默认构造函数</p><p>弊端：如有某个成员必须有值，则获取对象可能set方法没有执行</p><h5 id="3-2-3-4-复杂类型注入"><a href="#3-2-3-4-复杂类型注入" class="headerlink" title="3.2.3.4 复杂类型注入"></a>3.2.3.4 复杂类型注入</h5><p>本质上还是使用set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String[] myStrs; </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; myList; </span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mySet; </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; myMap; </span><br><span class="line">    <span class="keyword">private</span> Properties myProps; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStrs</span><span class="params">(String[] myStrs)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myList = myList; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProps</span><span class="params">(Properties myProps)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(Arrays.toString(myStrs)); </span><br><span class="line">        System.out.println(myList); </span><br><span class="line">        System.out.println(mySet); </span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注入集合数据 </span></span><br><span class="line"><span class="comment">List结构的： array,list,set </span></span><br><span class="line"><span class="comment">Map结构的 map,entry,props,prop </span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 给数组注入数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入list集合数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="tag">&lt;/<span class="name">array</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入set集合数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入Map数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testA"</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入properties数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testA"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-2-3-5-使用P名称空间注入数据"><a href="#3-2-3-5-使用P名称空间注入数据" class="headerlink" title="3.2.3.5 使用P名称空间注入数据"></a>3.2.3.5 使用P名称空间注入数据</h5><p>通过再xml中导入p名称空间，使用p：propertyName来注入数据，本质还是调用set方法（视频里没讲，可能是少了一集）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl4</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="keyword">private</span> Date birthday; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl4"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">p:name</span>=<span class="string">"test"</span> <span class="attr">p:age</span>=<span class="string">"21"</span> <span class="attr">p:birthday-ref</span>=<span class="string">"now"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring–一、Spring概述及Spring中基于XML的IOC配置&quot;&gt;&lt;a href=&quot;#Spring–一、Spring概述及Spring中基于XML的IOC配置&quot; class=&quot;headerlink&quot; title=&quot;Spring–一、Spring概述及Sp
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot</title>
    <link href="http://yoursite.com/2019/10/02/Spring-boot/"/>
    <id>http://yoursite.com/2019/10/02/Spring-boot/</id>
    <published>2019-10-02T09:12:34.000Z</published>
    <updated>2019-10-02T09:19:49.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Spring-Boot"><a href="#一、Spring-Boot" class="headerlink" title="一、Spring Boot"></a>一、Spring Boot</h1><h2 id="0、前导内容"><a href="#0、前导内容" class="headerlink" title="0、前导内容"></a>0、前导内容</h2><p>（看了尚硅谷的视频看了几集才发现需要学前导内容，先滚去看Spring和Maven了，笔记回来再更新）</p><p>需要先掌握：</p><ul><li>Spring框架的使用经验</li><li>熟练使用Maven进行项目构建和依赖管理</li><li>熟练使用Eclipse或者IDEA</li></ul><h2 id="1、Spring-Boot-简介"><a href="#1、Spring-Boot-简介" class="headerlink" title="1、Spring Boot 简介"></a>1、Spring Boot 简介</h2><blockquote><p>  简化Spring应用开发的一个框架</p><p>  整个Spring技术栈的一个大整合</p><p>  JavaEE开发的一站式解决方案</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>微服务：架构风格</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行沟通</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软件单元</p><p>微服务文档：<a href="https://martinfowler.com/articles/microservices.html#microservicesAndSoa" target="_blank" rel="noopener">英文原版</a>  <a href="http://blog.cuicc.com/blog/2015/07/22/microservices/" target="_blank" rel="noopener">简体中文</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Spring-Boot&quot;&gt;&lt;a href=&quot;#一、Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;一、Spring Boot&quot;&gt;&lt;/a&gt;一、Spring Boot&lt;/h1&gt;&lt;h2 id=&quot;0、前导内容&quot;&gt;&lt;a href=&quot;#0、前
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>记--20190923</title>
    <link href="http://yoursite.com/2019/09/23/%E8%AE%B0-20190923/"/>
    <id>http://yoursite.com/2019/09/23/记-20190923/</id>
    <published>2019-09-23T12:17:55.000Z</published>
    <updated>2019-09-23T13:22:47.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记–20190923"><a href="#记–20190923" class="headerlink" title="记–20190923"></a>记–20190923</h1><p>今天的心情可能就像过山车一样，落起落落落落落。。。到晚上的时候已经麻木，什么都无所谓了。。。</p><h2 id="蓝桥杯报销"><a href="#蓝桥杯报销" class="headerlink" title="蓝桥杯报销"></a>蓝桥杯报销</h2><p>关于蓝桥杯报销的事跑了挺长时间了，可能是自己办事能力太差了，每次都像无头苍蝇一样到处乱撞。问了计算机院的老师，还问了16级的辅导员，跑了新区老区，今天终于给他弄完了，不过最后做的不太好，忘记将报销明细给记下来算一算，挺失误的。其实最后挺感谢16级的辅导员的，还是她帮我找的老师去算报销，要不然又得问一大堆人。。。最后办完专门给老师发了个短信谢谢老师。</p><h2 id="ACM省赛单项奖学金审核"><a href="#ACM省赛单项奖学金审核" class="headerlink" title="ACM省赛单项奖学金审核"></a>ACM省赛单项奖学金审核</h2><p>前一段时间导员给我说我的ACM省赛单项奖学金没有过审，我突然一愣，一脸懵逼。当时老师说级别不够，然后我觉得不可能啊，就问老师能不能申诉，可能是自己语气不太好，老师直接说不能。（自己有时候脾气太急了）后来问了学长啥的，又和老师联系了一下，老师也帮忙问了问。最后让我去行政楼问，还专门叮嘱我是去咨询，不是去质问。</p><p>今天去了行政楼，那个老师说这个奖从今年开始都不算了。WTM……当时就想怼一句，这个奖不算哪个省赛的奖还有资格算？？？最后说了两句，心里火大的很，可能语气也不太好，就走了。。。</p><h2 id="三好学生"><a href="#三好学生" class="headerlink" title="三好学生"></a>三好学生</h2><p>本来想着今年有希望能申请三好学生的，后来公布名单的时候没有我，心里挺失落的，就和前面那个人综合测评差了0.3分，正正好到我前面一个人，实力不行，无话可说。今天班长和我说我们专业多出来一个三好学生名额，最后导员说我文化课成绩不够年级前百分之三十，没有给我，行吧，莫得办法，菜就是菜。。。</p><h2 id="关于考研"><a href="#关于考研" class="headerlink" title="关于考研"></a>关于考研</h2><p>今天听了某考研机构的讲课，突然感觉要开始学英语和数学了，虽然他讲的有些夸张，想让我们报辅导班，但是英语和数学确实得拉长战线，感觉好紧张啊，还想啃一啃西瓜书和两本黑砖头的操作系统和计网的书了，光这三本砖头就够我看的了，感觉时间不够啊，还要准备接下来的区域赛，卧槽，压力好大啊。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己在办事能力和与人交流能力上差太多了，以后对老师和找别人办事一定要忍住脾气，对别人一定要谦逊有礼貌，办完事别忘说谢谢，麻烦您了，和别人打声招呼。对未来这学期的规划也该做一做了，考研英语数学，看书，ACM区域赛。希望能在区域赛拿个牌子，要是什么都没拿到，大学四年真的是废了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记–20190923&quot;&gt;&lt;a href=&quot;#记–20190923&quot; class=&quot;headerlink&quot; title=&quot;记–20190923&quot;&gt;&lt;/a&gt;记–20190923&lt;/h1&gt;&lt;p&gt;今天的心情可能就像过山车一样，落起落落落落落。。。到晚上的时候已经麻木，什么
      
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #587 (Div. 3) 比赛&amp;补题</title>
    <link href="http://yoursite.com/2019/09/21/Codeforces-Round-587-Div-3-%E6%AF%94%E8%B5%9B-%E8%A1%A5%E9%A2%98/"/>
    <id>http://yoursite.com/2019/09/21/Codeforces-Round-587-Div-3-比赛-补题/</id>
    <published>2019-09-21T09:50:46.000Z</published>
    <updated>2019-09-22T10:10:10.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-587-Div-3-比赛-amp-补题"><a href="#Codeforces-Round-587-Div-3-比赛-amp-补题" class="headerlink" title="Codeforces Round #587 (Div. 3) 比赛&amp;补题"></a>Codeforces Round #587 (Div. 3) 比赛&amp;补题</h1><p>tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁</p><p>想开始打一打cf，刷题刷的太少了，太吃亏了。</p><h2 id="1216A-Prefixes"><a href="#1216A-Prefixes" class="headerlink" title="1216A. Prefixes"></a>1216A. Prefixes</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个字符串，长度为偶数，只包含小写字母a和b，你可以变换其中任意一个字母，把a换成b或者把b换成a。要求最后结果中的字符串任意偶数前缀a和b的数量相同。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>只需要保证第i个字母和第i+1个字母不相同就行了，i每次递增2。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n, ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n &gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'a'</span>)</span><br><span class="line">                s[i] = <span class="string">'b'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[i] = <span class="string">'a'</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216B-Shooting"><a href="#1216B-Shooting" class="headerlink" title="1216B. Shooting"></a>1216B. Shooting</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给你几个罐子，每个罐子的耐久度为ai，你要将所有罐子击碎，当你要击碎第i个罐子时，你需要射击(ai*x+1)次，其中x为你已经击碎的罐子，可认为你将一个罐子击碎才会去射击下一个罐子。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>x是重点，只要反向排一下序就行了，有些类似哈夫曼树。一开始以为最后让依次输出第i个罐子是第几次被射击的，后来WA了一次才发现是让依次输出射击的是第几个罐子。。。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ai, index;</span><br><span class="line">&#125;ax[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(A a, A b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.ai&gt;b.ai;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;ax[i].ai;</span><br><span class="line">        ax[i].index = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>, ans=<span class="number">0</span>;</span><br><span class="line">    sort(ax, ax+n, cmp1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=(ax[i].ai*x+<span class="number">1</span>);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ax[<span class="number">0</span>].index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">' '</span> &lt;&lt;ax[i].index;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216C-White-Sheet"><a href="#1216C-White-Sheet" class="headerlink" title="1216C. White Sheet"></a>1216C. White Sheet</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给你一个白纸的左下角和右上角坐标，还有两张黑纸的左下角和右上角坐标，保证这三张纸的边缘都平行于坐标轴，问你黑纸是否能完全覆盖住白纸。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>坐标范围1e6，可以依次遍历白纸边缘的每一个点，看他是否在黑纸内，递增要设成0.5，不能设成1，最后没时间了，不知道思路对不对，回来再来补吧。（补：果然过了，太智障了。。。）</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">int</span> x3, y3, x4, y4;</span><br><span class="line">    <span class="keyword">int</span> x5, y5, x6, y6;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;x1 &gt;&gt;y1 &gt;&gt;x2 &gt;&gt;y2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;x3 &gt;&gt;y3 &gt;&gt;x4 &gt;&gt;y4;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;x5 &gt;&gt;y5 &gt;&gt;x6 &gt;&gt;y6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=x1; i&lt;=x2; i+=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=x4&amp;&amp;i&gt;=x3&amp;&amp;y1&lt;=y4&amp;&amp;y1&gt;=y3) || (i&lt;=x6&amp;&amp;i&gt;=x5&amp;&amp;y1&lt;=y6&amp;&amp;y1&gt;=y5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=y1; i&lt;=y2; i+=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=y4&amp;&amp;i&gt;=y3&amp;&amp;x1&lt;=x4&amp;&amp;x1&gt;=x3) || (i&lt;=y6&amp;&amp;i&gt;=y5&amp;&amp;x1&lt;=x6&amp;&amp;x1&gt;=x5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=x2; i&gt;=x1; i-=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=x4&amp;&amp;i&gt;=x3&amp;&amp;y2&lt;=y4&amp;&amp;y2&gt;=y3) || (i&lt;=x6&amp;&amp;i&gt;=x5&amp;&amp;y2&lt;=y6&amp;&amp;y2&gt;=y5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=y2; i&gt;=y2; i-=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=y4&amp;&amp;i&gt;=y3&amp;&amp;x2&lt;=x4&amp;&amp;x2&gt;=x3) || (i&lt;=y6&amp;&amp;i&gt;=y5&amp;&amp;x2&lt;=x6&amp;&amp;x2&gt;=x5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"NO"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216D-Swords"><a href="#1216D-Swords" class="headerlink" title="1216D. Swords"></a>1216D. Swords</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>地下室有n种剑，每种剑有x个，有y个人来地下室偷剑，每个人只拿一种剑，每个人拿了z个剑。现在发现地下室的剑被偷了，每种剑剩下ai个，其中x, y, z未知，给出n和ai，让你求出最少y个人来偷剑和每个人偷了多少剑z。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>用最大的数依次减去其他所有ai，求他们所有的最大公因数，然后再用前面算出来的最大数和其他数的差除以最大公因数，则可算出有多少人来偷剑了，最大公因数即为每个人偷了多少剑。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s, ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    sort(a, a+n, cmp);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a[<span class="number">0</span>]-a[i];</span><br><span class="line">        <span class="keyword">if</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(x);</span><br><span class="line">            ss.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s.size()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        y = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">        s.push(__gcd(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!ss.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x = ss.top();</span><br><span class="line">        ss.pop();</span><br><span class="line">        ans+=(x/s.top());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %d\n"</span>, ans, s.top());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216E1-Numerical-Sequence-easy-version"><a href="#1216E1-Numerical-Sequence-easy-version" class="headerlink" title="1216E1. Numerical Sequence (easy version)"></a>1216E1. Numerical Sequence (easy version)</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>11212312341234512345612345671234567812345678912345678910……，给你一个这样的无限循环数列，1、12、123、1234、12345……这样循环，询问q次，每次询问在这个数列中第k位是什么数字。注意：11算两位数字，而不是一个数字。k最大为1e9，q不大于100。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><img src="/2019/09/21/Codeforces-Round-587-Div-3-比赛-补题/TIM截图20190922180010.png" alt="TIM截图20190922180010" style="zoom:50%;"></p><p>由程序算出当k为1e9时总共也才21837个数，所以我们只用预处理出前1e5个数的排列，预处理时记录下每个数的最后一位排到哪里了，最后直接查表就行了。</p><p>计算程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ll k=<span class="number">0</span>, i=<span class="number">1</span>, x;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=<span class="number">1000000000</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">            x = j;</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;k++;x/=<span class="number">10</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num[maxn*<span class="number">5</span>], pre[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cal(x/<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    num[++n] = x%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cal(i);</span><br><span class="line">        pre[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;k;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+pre[i]&lt;k)</span><br><span class="line">                sum+=pre[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;num[k-sum] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/last-diary/p/11567813.html" target="_blank" rel="noopener">准点的星辰Codeforces Round #587(Div.3)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Codeforces-Round-587-Div-3-比赛-amp-补题&quot;&gt;&lt;a href=&quot;#Codeforces-Round-587-Div-3-比赛-amp-补题&quot; class=&quot;headerlink&quot; title=&quot;Codeforces Round #58
      
    
    </summary>
    
      <category term="比赛&amp;补题" scheme="http://yoursite.com/categories/%E6%AF%94%E8%B5%9B-%E8%A1%A5%E9%A2%98/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Codeforces" scheme="http://yoursite.com/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>kuangbin专题一简单搜索</title>
    <link href="http://yoursite.com/2019/09/19/kuangbin%E4%B8%93%E9%A2%98%E4%B8%80%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/09/19/kuangbin专题一简单搜索/</id>
    <published>2019-09-19T14:28:56.000Z</published>
    <updated>2019-10-02T09:15:04.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kuangbin专题一简单搜索"><a href="#kuangbin专题一简单搜索" class="headerlink" title="kuangbin专题一简单搜索"></a>kuangbin专题一简单搜索</h1><p>tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁</p><p><a href="https://vjudge.net/article/187" target="_blank" rel="noopener">kuangbin专题合集</a></p><p>[ACM正确入门方式——数学lover</p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><ol><li><a href="https://vjudge.net/problem/POJ-1321" target="_blank" rel="noopener"><strong>POJ 1321</strong></a> 棋盘问题<font color="green">AC: 2018-07-17 23:54:31</font></li><li><a href="https://vjudge.net/problem/POJ-2251" target="_blank" rel="noopener"><strong>POJ 2251</strong></a> Dungeon Master<font color="green">AC: 2019-09-19 18:32:04</font></li><li><a href="https://vjudge.net/problem/POJ-3278" target="_blank" rel="noopener"><strong>POJ 3278</strong></a> Catch That Cow<font color="green">AC: 2019-09-21 19:37:10</font></li><li><a href="https://vjudge.net/problem/POJ-3279" target="_blank" rel="noopener"><strong>POJ 3279</strong></a> Fliptile<font color="green">AC: 2019-09-22 16:09:25</font></li><li><a href="https://vjudge.net/problem/POJ-1426" target="_blank" rel="noopener"><strong>POJ 1426</strong></a> Find The Multiple<font color="green">AC: 2019-09-23 20:09:26</font></li><li><a href="https://vjudge.net/problem/POJ-3126" target="_blank" rel="noopener"><strong>POJ 3126</strong></a> Prime Path<font color="green">AC: 2019-09-24 22:48:09</font></li><li><a href="https://vjudge.net/problem/POJ-3087" target="_blank" rel="noopener"><strong>POJ 3087</strong></a> Shuffle’m Up</li><li><a href="https://vjudge.net/problem/POJ-3414" target="_blank" rel="noopener"><strong>POJ 3414</strong></a> Pots</li><li><a href="https://vjudge.net/problem/FZU-2150" target="_blank" rel="noopener"><strong>FZU 2150</strong></a> Fire Game</li><li><a href="https://vjudge.net/problem/UVA-11624" target="_blank" rel="noopener"><strong>UVA 11624</strong></a> Fire!</li><li><a href="https://vjudge.net/problem/POJ-3984" target="_blank" rel="noopener"><strong>POJ 3984</strong></a> 迷宫问题</li><li><a href="https://vjudge.net/problem/HDU-1241" target="_blank" rel="noopener"><strong>HDU 1241</strong></a> Oil Deposits</li><li><a href="https://vjudge.net/problem/HDU-1495" target="_blank" rel="noopener"><strong>HDU 1495</strong></a> 非常可乐</li><li><a href="https://vjudge.net/problem/HDU-2612" target="_blank" rel="noopener"><strong>HDU 2612</strong></a> Find a way</li></ol><h2 id="POJ1321-棋盘问题"><a href="#POJ1321-棋盘问题" class="headerlink" title="POJ1321  棋盘问题"></a><a href="https://vjudge.net/problem/POJ-1321" target="_blank" rel="noopener">POJ1321  棋盘问题</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>就是在棋盘上放棋子，放的时候不能同行同列，和八皇后问题类似，只不过空白的地方不能放。这是我去年暑假acm训练时写的，现在已经忘了当时咋写的了，看着自己WA了好多发，太菜了。。。dfs时记得复原。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>dfs吧，没什么可说的，八皇后模板题。好烦啊，POJ不能用万能头文件。。。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">char</span> pan[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(pan[l][i]==<span class="string">'#'</span> &amp;&amp; !vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                dfs(l+<span class="number">1</span>);</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(0), cin.tie(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span> &amp;&amp; m==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt;pan[i][j];</span><br><span class="line"></span><br><span class="line">        ans = cnt = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ2251-Dungeon-Master"><a href="#POJ2251-Dungeon-Master" class="headerlink" title="POJ2251  Dungeon Master"></a><a href="https://vjudge.net/problem/POJ-2251" target="_blank" rel="noopener">POJ2251  Dungeon Master</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个3D迷宫，总共六个方向，上下左右前后。有的地方不能走有的能走，给出起点终点，问你能不能走到终点，如果能的话应该是求用时最短的吧（题目中没说，一开始用dfsWA了，后来看别人都用bfs才发现是不是要求最短路）。没移动一次要花费一分钟。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>bfs，一开始用bfs一直内存超限，快给我郁闷死了。。。要把走过的点用#堵上，防止多余的结点入队列。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">make_node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node a;</span><br><span class="line">    a.x = x, a.y = y, a.z = z, a.step=step;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r, c;</span><br><span class="line">    <span class="keyword">char</span> mp[maxn][maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">6</span>]= &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">6</span>]= &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dz[<span class="number">6</span>]= &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt;l &gt;&gt;r &gt;&gt;c &amp;&amp; l+r+c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;r; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;c; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt;mp[i][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(mp[i][j][k]==<span class="string">'S'</span>)</span><br><span class="line">                        q.push(make_node(i, j, k, <span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">if</span>(mp[i][j][k]==<span class="string">'E'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i;</span><br><span class="line">                        y = j;</span><br><span class="line">                        z = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node a = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a.x==x &amp;&amp; a.y==y &amp;&amp; a.z==z)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;<span class="string">"Escaped in "</span>&lt;&lt;a.step &lt;&lt;<span class="string">" minute(s)."</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]]!=<span class="string">'#'</span>)</span><br><span class="line">                    <span class="keyword">if</span>(a.x+dx[i]&gt;=<span class="number">0</span> &amp;&amp; a.x+dx[i]&lt;l &amp;&amp; a.y+dy[i]&gt;=<span class="number">0</span> &amp;&amp; a.y+dy[i]&lt;r &amp;&amp; a.z+dz[i]&gt;=<span class="number">0</span> &amp;&amp; a.z+dz[i]&lt;c)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.push(make_node(a.x+dx[i], a.y+dy[i], a.z+dz[i], a.step+<span class="number">1</span>));</span><br><span class="line">                        mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]] = <span class="string">'#'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"Trapped!"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3287-Catch-That-Cow"><a href="#POJ3287-Catch-That-Cow" class="headerlink" title="POJ3287 Catch That Cow"></a><a href="https://vjudge.net/problem/POJ-3278" target="_blank" rel="noopener">POJ3287 Catch That Cow</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>你的牛跑了，要把它抓回来。你的位置在n，牛的位置在k，牛不会跑，你要用最少的时间走到牛的位置。你们的位置都在同一个数轴上，只有左右两个方向，你有三种走法，左走一步、右走一步或者传送到你当前坐标的二倍的位置，这三种走法都只花费一分钟。n和k都小于等于100000</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>只有三种操作，求最短时间，可以用bfs。bfs要设置一个vis数组，注意不能数组越界。还要注意当n==k的时候。一开始一直超内存，后来发现要设一个vis数组剪枝。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">make_node</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node a;</span><br><span class="line">    a.p = p;</span><br><span class="line">    a.t = t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">        q.push(make_node(n, <span class="number">0</span>));</span><br><span class="line">        vis[n] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node a = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a.p+<span class="number">1</span>==k || a.p<span class="number">-1</span>==k || a.p*<span class="number">2</span>==k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;a.t+<span class="number">1</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a.p&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a.p+<span class="number">1</span>&lt;=<span class="number">100000</span> &amp;&amp; !vis[a.p+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_node(a.p+<span class="number">1</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                    vis[a.p+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a.p*<span class="number">2</span>-k&lt;k-a.p &amp;&amp; a.p*<span class="number">2</span>&lt;=<span class="number">100000</span> &amp;&amp; !vis[a.p*<span class="number">2</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_node(a.p*<span class="number">2</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                    vis[a.p*<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a.p<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !vis[a.p<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_node(a.p<span class="number">-1</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                    vis[a.p<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.p&gt;k &amp;&amp; a.p<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !vis[a.p<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(make_node(a.p<span class="number">-1</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                vis[a.p<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3279-Fliptile"><a href="#POJ3279-Fliptile" class="headerlink" title="POJ3279 Fliptile"></a>POJ3279 Fliptile</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有n*m个方格，每个方格都有一块瓷砖，瓷砖的两面分别是黑色和白色，当你翻转瓷砖时瓷砖会从白色翻转成黑色，或者从黑色翻转成白色。样例输入为每个方格瓷砖的初始颜色，0代表白色，1代表黑色。现在让你的奶牛来将所有格子翻成白色，由于奶牛的蹄子比较大，它每次反转的时会将相邻的瓷砖也翻转过来，即上下左右的瓷砖。最后输出每个瓷砖的翻转次数，要求总的翻转次数最少，如果答案有多种，则输出字典序最小的那个答案。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>这题有个最重要的思想，就是第i层如果有黑色瓷砖，要通过第i+1层的翻转将其翻转成白色。这样只用保证前一层没有黑色即可，不用管当前层翻转成什么样，也不用管下一层。这样的话只要第一层的状态确定，后面所有的状态都确定了。因为第二层需要将第一层的黑瓷砖翻成白色的，这个过程中第二层可能会出现黑瓷砖，再用第三层将第二层翻转成白色的，再用第四层将。。。我们可以枚举第一层所有的状态，即每一块瓷砖翻或不翻，总共有2^m个，然后用第二层将第一层翻成白色。。。用最后一层将倒数第二层翻成白色，因为后面没有瓷砖来翻转最后一层了，所有我们通过判断最后一层有没有黑色瓷砖，就可以判断这个方法是否可行。</p><p>输出次数最少的那一个可以每次翻转记录一下，最后对比所有可能性的翻转次数取最小即可。</p><p>字典序最小，即输出答案时每行的字典序最小，每行的字典序即把所有数字串成一个字符串，让他们字典序最小，即将0 0 0 1 1串成00011，而00011的字典序比10010小。保证字典序最小可以先保证第一行字典序最小，第一行有2^m种可能，我们把没个瓷砖看成二进制的一位数，那第一行的所有操作就是0~(1&lt;&lt;m-1)，我们枚举的时候直接从0开始枚举就行了。</p><p>一开始写的时候怎么想都没思路，最后看了别人的题解才写出来，还是做题太少了，太菜了。。。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, turnnum, turnans;</span><br><span class="line"><span class="keyword">int</span> mp[maxn][maxn], a[maxn][maxn], fn[maxn][maxn], ans[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fn[i][j] = <span class="number">1</span>;</span><br><span class="line">turnnum++;</span><br><span class="line">a[i][j] = !a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">a[i + dx[k]][j + dy[k]] = !a[i + dx[k]][j + dy[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lp = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">turnans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lp; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(fn, <span class="number">0</span>, <span class="keyword">sizeof</span> fn);</span><br><span class="line"><span class="built_in">memcpy</span>(a, mp, <span class="keyword">sizeof</span> mp);</span><br><span class="line">turnnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">turn(<span class="number">1</span>, j);</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j - <span class="number">1</span>][k])</span><br><span class="line">turn(j, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[n][j])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == m+<span class="number">1</span> &amp;&amp; turnnum &lt; turnans)</span><br><span class="line">&#123;</span><br><span class="line">turnans = turnnum;</span><br><span class="line"><span class="built_in">memcpy</span>(ans, fn, <span class="keyword">sizeof</span> fn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (turnans == INF)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/c___c18/article/details/82465664" target="_blank" rel="noopener">POJ3279 二进制的搜索</a></p><h2 id="POJ1426-Find-The-Multiple"><a href="#POJ1426-Find-The-Multiple" class="headerlink" title="POJ1426 Find The Multiple"></a>POJ1426 Find The Multiple</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给你一个不超过200的数n，让你求一个数m，m不超过100位，m只包含0和1且（m%n）== 0。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>不知道为什么，直接定义longlong + BFS就过了。。。一开始想模拟，还超时了，菜。。。</p><p>在网上看到有个大佬在用这题讲<a href="https://blog.csdn.net/lyy289065406/article/details/6647917" target="_blank" rel="noopener">同余模定理</a>，抽空看一下。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> ll n, m=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        m = <span class="number">1</span>;</span><br><span class="line">        q.push(m);</span><br><span class="line">        <span class="keyword">if</span>(m%n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;m &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            m = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            m *= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(m%n==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;m &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(m);</span><br><span class="line">            m += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(m%n==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;m &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3126-Prime-Path"><a href="#POJ3126-Prime-Path" class="headerlink" title="POJ3126 Prime Path"></a>POJ3126 Prime Path</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>测试数据不超过一百组，每组给出两个四位素数，要求你将第一个数字变换成第二个数字。没回只能变换一位数字，而且首位数字不能变成0，变换过的数字也必须为素数。每次变换需要花1磅，问你从第一个数字变换到第二个数字最小花费是多少。</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>最少花费，肯定BFS了，先用线性素数筛打个表，每次进队的数据查表时间复杂度为O(1)，然后每一层循环，要把四位数字全换一遍，换一个数字进一次队列，用vis数组剪枝。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], pNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn] = &#123;<span class="literal">false</span>&#125;, vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, <span class="built_in">cos</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">num <span class="title">make_num</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> <span class="built_in">cos</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num x;</span><br><span class="line">    x.a = a;</span><br><span class="line">    x.<span class="built_in">cos</span> = <span class="built_in">cos</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulerSieve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == <span class="literal">false</span>)</span><br><span class="line">            prime[pNum++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eulerSieve(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;a &gt;&gt;b;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;num&gt; q;</span><br><span class="line">        q.push(make_num(a, <span class="number">0</span>));</span><br><span class="line">        vis[a] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            num x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(x.a==b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;x.<span class="built_in">cos</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y/<span class="number">1000</span>==i)   <span class="keyword">continue</span>;</span><br><span class="line">                y = i*<span class="number">1000</span>+y%<span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y/<span class="number">100</span>%<span class="number">10</span>==i) <span class="keyword">continue</span>;</span><br><span class="line">                y = (y/<span class="number">1000</span>*<span class="number">10</span>+i)*<span class="number">100</span>+y%<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y%<span class="number">100</span>/<span class="number">10</span>==i) <span class="keyword">continue</span>;</span><br><span class="line">                y = (y/<span class="number">100</span>*<span class="number">10</span>+i)*<span class="number">10</span>+y%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y%<span class="number">10</span>==i) <span class="keyword">continue</span>;</span><br><span class="line">                y = y/<span class="number">10</span>*<span class="number">10</span>+i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kuangbin专题一简单搜索&quot;&gt;&lt;a href=&quot;#kuangbin专题一简单搜索&quot; class=&quot;headerlink&quot; title=&quot;kuangbin专题一简单搜索&quot;&gt;&lt;/a&gt;kuangbin专题一简单搜索&lt;/h1&gt;&lt;p&gt;tips：大家评论的时候写一下邮箱和
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="搜索" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>tarjan求有向图的强连通分量</title>
    <link href="http://yoursite.com/2019/09/02/tarjan%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>http://yoursite.com/2019/09/02/tarjan求有向图的强连通分量/</id>
    <published>2019-09-02T11:37:49.000Z</published>
    <updated>2019-09-18T16:44:39.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tarjan求有向图的强连通分量"><a href="#tarjan求有向图的强连通分量" class="headerlink" title="tarjan求有向图的强连通分量"></a>tarjan求有向图的强连通分量</h1><p>tarjan到底是念“塔进”还是“塔扬”。好像大多数人都念“塔进”，但是英语好像是念“塔扬”。胡扯结束。。。</p><p>这个tarjan算法求的是有向图中的强连通分量，并将他们合并。</p><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p><strong>（如果会可以直接看tarjan部分）</strong>那什么是强连通分量呢？强连通嘛，就是<strong>图中任意两点能相互到达</strong>。那强连通分量就是一个图中的强连通子图。</p><p>环是最简单的强连通分量：</p><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909204020.png" alt="TIM截图20190909204020" style="zoom:50%;"></p><p>那你如果从1出发，只要转一圈就能经过所有点。</p><p>强连通分量不等于环，还有一些复杂的强连通分量，例如完全图：</p><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909204729.png" alt="TIM截图20190909204729" style="zoom:50%;"></p><p>很明显能看出从图中一点出发，可到达其他任意一个点。</p><h2 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h2><p>先上时间复杂度：O(N+M)    （其中N和M分别为点数和边数）</p><p>tarjan算法是通过对图的dfs来找出其中的强连通分量，并分类。<strong>（需掌握dfs的思想并且能熟练运用）</strong></p><h3 id="dfn数组和low数组讲解"><a href="#dfn数组和low数组讲解" class="headerlink" title="dfn数组和low数组讲解"></a>dfn数组和low数组讲解</h3><p>这里给出tarjan算法中两个重要数组的定义：</p><p>​    dfn[u]：表示当前结点i在dfs算法中第几个被访问的的点。</p><p>​    low[u]：表示当前结点i能回溯到的最小dfs序结点，<strong>dfs序即dfn[u]的值</strong>。</p><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909205034.png" alt="TIM截图20190909205034" style="zoom:50%;"></p><p>（6-&gt;1的箭头画反了，应该时1-&gt;6）</p><p>当从结点1开始dfs时，假设优先向下访问：dfn[1] = 1;    dfn[6] = 2;因为第一个访问的时结点1，所以它的dfs序是1，第二个访问的是结点6，所以它的dfs序时2。访问完结点6发现没有路了，则开始访问结点1的下一条出边。</p><p>开始访问结点2，刚刚访问的结点6是第二个访问的结点，所以结点2是第三个访问的结点，即它的dfs序为3：dfn[2] = 3;    dfn[5] = 4;    dfn[4] = 5;    dfn[3] = 6;我们顺着结点2依次访问下去，发现只有一条路，畅通无阻。</p><p>当访问到结点三的时候我们发现<strong>结点3有一条通向结点2的路</strong>，则此时我们称<strong>结点3回溯到结点2</strong>。我们还发现dfn[2]&lt;dfn[3]，即结点2在dfs中比结点3先被访问。此时我们在dfs回溯的过程中令：low[3] = dfn[2];    low[4] = dfn[2];    low[5] = dfn[2];即令回溯路上的所有点的low数组都赋值为结点2的dfs序。</p><p>由此我们经历了一遍tarjan的简化步骤，我们能发现low数组的取值为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">low[u] = min(</span><br><span class="line">    dfn[u],<span class="comment">//1.</span></span><br><span class="line">    dfn[v],<span class="comment">//2.</span></span><br><span class="line">    low[v]<span class="comment">//3.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>low数组初始化时为当前结点的dfs序，即low[u] = dfn[u];</li><li>这里的v是边（u, v）中的v，和上图中边（3, 2）类似。当发现能回溯到的结点dfs序小于自身dfs序时更新low的值</li><li>这里的（u, v）和上图中的（4, 3）类似。dfs回溯过程中时发现前面结点的low值小于自身的low值时，更新自身low值</li></ol><p>从图中可看出2， 5， 4， 3四个结点为一个环，环是最简单的强连通分量，所以2， 5， 4， 3为一个强连通分量。而单独一个结点我们也将他看成一个强连通分量，因此图中有三个强连通分量：（1）（6）（2，4，5，3）</p><p>从中我们观察出1， 6， 2的dfn值和low值相同，所以当dfn[u]==low[u]时，它就是一个强连通分量在dfs树中的起始节点</p><h3 id="tarjan算法伪代码讲解"><a href="#tarjan算法伪代码讲解" class="headerlink" title="tarjan算法伪代码讲解"></a>tarjan算法伪代码讲解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index<span class="comment">//1.</span></span><br><span class="line">    Stack.push(u)<span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">for</span> each (u, v) in E<span class="comment">//3.</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)<span class="comment">//4.</span></span><br><span class="line">            tarjan(v)<span class="comment">//dfs</span></span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)<span class="comment">//5.</span></span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])<span class="comment">//6.</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop<span class="comment">//7.</span></span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为结点u初始化dfn和low的值为dfs时的访问顺序，index为全局变量</li><li>将结点u压入栈中</li><li>遍历结点u的每一条边</li><li>如果没访问过</li><li>如果v在栈中</li><li>上面讲过，当dfn[u]==low[u]时，该节点为强连通分量根结点</li><li>将栈顶元素出栈，直到栈顶元素为u时，u出栈，则此次出栈的一系列元素为一个强连通分量</li></ol><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909205034.png" alt="TIM截图20190909205034" style="zoom:50%;"></p><p>（6-&gt;1的箭头画反了，应该时1-&gt;6）</p><ol><li>从结点1开始：dfn[1] = low[1] = 1; 结点1进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918114703.png" alt="TIM截图20190918114703" style="zoom: 50%;"></li><li>1-&gt;6：dfn[6] = low[6] = 2; 结点6进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918114957.png" alt="TIM截图20190918114957" style="zoom:50%;">结点6没有出边，无法dfs，发现dfn[6]==low[6]，栈顶元素出栈，栈顶元素正好时结点6，无需继续出栈，则结点6自己为一个单独的强联通分量。</li><li>1-&gt;2：dfn[2] = low[2] = 3；结点2进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918115433.png" alt="TIM截图20190918115433" style="zoom: 50%;">结点2有出边且为访问，开始dfs。</li><li>2-&gt;5：dfn[5] = low[5] = 4；结点5进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918120132.png" alt="TIM截图20190918120132" style="zoom: 50%;">结点5有出边且未访问，继续dfs</li><li>5-&gt;4：dfn[4] = low[4] = 5；结点4进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918120345.png" alt="TIM截图20190918120345" style="zoom:50%;">结点4有未访问的出边，继续dfs</li><li>4-&gt;3：dfn[3] = low[3] = 6；结点3进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918120518.png" alt="TIM截图20190918120518" style="zoom: 50%;">结点3有出边，但结点2已经访问过了，且结点2在栈里面，所以3可以回溯到结点2，可知dfn[2]=3, low[3]=6;  所以low[3] = dfn[2] = 3;</li><li>此时dfn[3]!=low[3]，所以不出栈。</li><li>当dfs回溯到5-&gt;4的时候，发现(low[4]=5) &gt; (low[3]=3)，所以low[4] = 3;    依此类推low[5]=3;且直到dfs回溯到结点2的时候才会进行出栈操作，因为2时强连通分量的根节点。</li><li>不难看出，依次出栈的时3、4、5、2，这四个结点为一个强连通分量</li><li>最后dfs回溯到最开始的入口，结点1出栈</li><li>由此的强连通分量有3个，分别是：（1）、（6）、（3，4，5，2）</li></ol><h2 id="tarjan算法模板"><a href="#tarjan算法模板" class="headerlink" title="tarjan算法模板"></a>tarjan算法模板</h2><h3 id="链式前向星模板"><a href="#链式前向星模板" class="headerlink" title="链式前向星模板"></a>链式前向星模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> net;</span><br><span class="line">     <span class="keyword">int</span> to;</span><br><span class="line">     <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_dege</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], belong[maxn];<span class="comment">//2.</span></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>, Bcnt;<span class="comment">//3.</span></span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    s.push(u);instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=edge[i].net)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;<span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bcnt = index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//4.</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="comment">//5.</span></span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>head[u]记得初始化，初始化为-1。</li><li>belong数组值相同的结点属于同一个强连通分量。</li><li>Bcnt用于划分强连通分量</li><li>要从每个结点都进行一次tarjan，否则有些不可达结点就无法划分强联通分量，n为结点数</li><li>dfn数组初始化为0，当dfn[u]的值不为0的时候则说明被访问过了</li></ol><h3 id="邻接矩阵模板"><a href="#邻接矩阵模板" class="headerlink" title="邻接矩阵模板"></a>邻接矩阵模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mp[maxn][maxn];<span class="comment">//1.</span></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>, Bcnt;</span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    s.push(u);instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;n; v++)<span class="comment">//2.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[u][v]==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bcnt = index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>邻接矩阵，当值为-1时表示不连通</li><li>n为结点数</li></ol><h3 id="邻接表模板"><a href="#邻接表模板" class="headerlink" title="邻接表模板"></a>邻接表模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>, Bcnt;</span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[u].push_back(make_pair(w, v));</span><br><span class="line">    <span class="comment">//G[v].push_back(make_pair(w, u));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    s.push(u);instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[u].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i].second;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//2.</span></span><br><span class="line">        G[i].clear();</span><br><span class="line">    Bcnt = index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用vector和pair实现邻接表，pair的first为路径权重，pair的second为另一端结点</li><li>初始化邻接表</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HDU1269"><a href="#HDU1269" class="headerlink" title="HDU1269"></a><a href="https://vjudge.net/problem/HDU-1269" target="_blank" rel="noopener">HDU1269</a></h3><p>题意：给你一个图，让你判断这个图是不是一整个强连通分量</p><p>题解：没什么可说的，tarjan模板题。需要注意的是有的能给的图只有点没有边，所以结束条件需要时m和n同时为0时才行。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, net;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn];</span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = index = Bcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(instack, <span class="number">0</span>, <span class="keyword">sizeof</span> instack);</span><br><span class="line">    <span class="built_in">memset</span>(belong, <span class="number">0</span>, <span class="keyword">sizeof</span> belong);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    s.push(u);</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i!=<span class="number">-1</span>; i=edge[i].net)</span><br><span class="line">    &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&lt;low[u])   low[u] = low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;m &amp;&amp; n+m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt;u &gt;&gt;v;</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">                tarjan(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = belong[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(belong[i]!=flag)</span><br><span class="line">                f = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!f) <span class="built_in">cout</span> &lt;&lt;<span class="string">"No"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;<span class="string">"Yes"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU1827"><a href="#HDU1827" class="headerlink" title="HDU1827"></a><a href="https://vjudge.net/problem/HDU-1827" target="_blank" rel="noopener">HDU1827</a></h3><p>题意：给你一些人的联系方式，但是这种联系方式时有向的，即x可以联系y不代表y可以联系到x，其实就是有向图。也给出你联系每个人的花费，如果可以让别人帮忙联系，就可以不需要花费话费。求最少需要联系多少人和花费多少话费。</p><p>题解：这道题没有那么直接，但是也能看出和强连通分量有关。这道题要求的是<strong>没有入边的强连通分量的个数</strong>，并且求出这些没有入边的强联通分量中花费最小的人。为什么是没有入边的强连通分量而不是强连通分量，因为有如入边的强联通分量可以被其他人通知到，就不需要你再亲自通知了。（一开始我理解成强连通分量的个数了(&gt;_&lt;) ）这题要用scnaf和printf，不能用cin和cout，数据量大，会超时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, net;</span><br><span class="line">&#125; edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn], fee[maxn], cost[maxn], ans;</span><br><span class="line"><span class="keyword">bool</span> instack[maxn], in[maxn];<span class="comment">//1.</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = index = ans = Bcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(instack, <span class="number">0</span>, <span class="keyword">sizeof</span> instack);</span><br><span class="line">    <span class="built_in">memset</span>(belong, <span class="number">0</span>, <span class="keyword">sizeof</span> belong);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</span><br><span class="line">        cost[i]=INF;</span><br><span class="line">    <span class="built_in">memset</span>(fee, <span class="number">0</span>, <span class="keyword">sizeof</span> fee);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    s.push(u);</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i!=<span class="number">-1</span>; i=edge[i].net)</span><br><span class="line">    &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&lt;low[u])</span><br><span class="line">                low[u] = low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fee[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">                tarjan(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=Bcnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//2.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i]; j!=<span class="number">-1</span>; j=edge[j].net)</span><br><span class="line">                <span class="keyword">if</span>(belong[i]!=belong[edge[j].to] &amp;&amp; !in[belong[edge[j].to]])</span><br><span class="line">                &#123;</span><br><span class="line">                    in[belong[edge[j].to]] = <span class="literal">true</span>;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">if</span>(!in[belong[i]])</span><br><span class="line">                cost[belong[i]] = min(cost[belong[i]], fee[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Bcnt; i++)</span><br><span class="line">            <span class="keyword">if</span>(!in[i])</span><br><span class="line">                ans+=cost[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, cnt, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>in数组表示该强连通分量是否有入边，为true则有，false则没有。</li><li>这个for循环求出有入边的强连通分量，即看看每个点的入边是否和自己在同一个强连通分量中即可。cnt为没有入边的个数。</li><li>求出没有入边的强连通分量中的最小花费，cost[i]代表第i个强连通分量的花费</li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://www.byvoid.com/zhs/blog/scc-tarjan" target="_blank" rel="noopener">BYVoid有向图强连通分量的tarjan算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tarjan求有向图的强连通分量&quot;&gt;&lt;a href=&quot;#tarjan求有向图的强连通分量&quot; class=&quot;headerlink&quot; title=&quot;tarjan求有向图的强连通分量&quot;&gt;&lt;/a&gt;tarjan求有向图的强连通分量&lt;/h1&gt;&lt;p&gt;tarjan到底是念“塔进”
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>差分约束</title>
    <link href="http://yoursite.com/2019/08/01/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2019/08/01/差分约束/</id>
    <published>2019-08-01T06:53:59.000Z</published>
    <updated>2019-09-18T16:39:24.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h1><p><strong>差分约束系统</strong>是求解一组特殊的不等式组的方法。</p><h2 id="差分约束举例"><a href="#差分约束举例" class="headerlink" title="差分约束举例"></a>差分约束举例</h2><p>差分约束是有n个变量和m个不等式组成的。其中每个不等式都是形如：$x_i-x_j \leq b_k(i,j\in[1,n], k\in[1,m])$  或 $x_i-x_j \geq b_k(i,j\in[1,n], k\in[1,m])$ 。</p><p>其中x为n个变量，b为m个不等式右边的值，用b的值来约束x的差称为差分约束。求一组解：$x_1=a_1,\quad x_2=a_2,\cdots x_n=a_n$使得所有约束条件(即m个不等式)均成立，则称差分约束有解，否则无解。</p><p>例如：<br>$$<br>(1)x_1-x_3 \leq 5;\quad<br>(2)x_3-x_5 \leq 4;\quad<br>$$<br>$$<br>(3)x_3-x_2 \leq 1;\quad<br>(4)x_1-x_5 \leq 10;\quad<br>(5)x_2-x_5 \leq 2;\quad<br>$$</p><p>观察$ x_1-x_5 $的关系，有如下三种关系：</p><ol><li>(4)                $x_1-x_5 \leq 10$</li><li>(1)+(2)         $x_1-x_5 \leq 9$</li><li>(1)+(3)+(5)   $x_1-x_5 \leq 8 $</li></ol><p>因为要满足所有等式的关系，所以取其中最大的3.$x_1-x_5 \leq 8$  因为8一定小于9和10嘛，如果$x_1-x_5$小于等于8了，那他们一定小于等于9和10。</p><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p>观察可发现 $x_i-x_j \leq b_k$ 可转换为：$x_i \leq b_k+x_j$ 。与求最短路公式中的dis[j]&lt;dis[i]+w[i, j]非常相似，那差分约束问题是不是也可以转化成最短路问题来求解呢？肯定是可以的！先来看个例子：</p><p><img src="/2019/08/01/差分约束/TIM截图20190801164055-1564649436098.png" alt="TIM截图20190801164055" style="zoom:50%;"></p><p>仔细观察图中可发现总共有三条路径：</p><ol><li>5 -&gt; 1                      长度为10</li><li>5 -&gt; 3 -&gt; 1               长度为9</li><li>5 -&gt; 2 -&gt; 3 -&gt; 1        长度为8</li></ol><p>很容易发现从5到1的最短路径是8。那为什么求差分约束问题能和最短路问题联系到一起呢？此处要先了解最短路知识，不懂的可以看一看我前面写的博客：1.<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/" target="_blank" rel="noopener">dijkstra</a>    2.<a href="https://zhangzef.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/" target="_blank" rel="noopener">SPFA</a>    3.<a href="https://zhangzef.com/2019/07/30/%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd/" target="_blank" rel="noopener">Floyd</a></p><h2 id="差分约束和最短路问题"><a href="#差分约束和最短路问题" class="headerlink" title="差分约束和最短路问题"></a>差分约束和最短路问题</h2><p>对于每个不等式$x_i-x_j \leq b_k$，我们都从结点j向结点i连一条长度为$b_k$的有向边。此时再看上面给出的那些不等式所转化成的图，是否和给出的图一样呢，最后求解的答案也一样。那么我们将差分约束问题转化成最短路问题，由最短路知识可知，当图中存在可达到的负环时，最短路一定无解。所以可以用SPFA来判断该差分约束问题是否有解。</p><p>这时候就有一个问题了，在最短路中有些点是不可达的，当遇到不可达的负环用SPFA一定判断不出来，但此时差分约束却是无解的。怎么办呢？有两种方法，其实本质都是一样的：</p><ol><li>我们新定义一个结点，可以是$x_0$，让它向所有其它结点连一条边，让这些边的权值为0。因为SPFA是一个bfs的过程(有些题目需要把spfa改成dfs的形式，但是并不影响它访问的结点个数，只是访问顺序不一样)，所以从这个结点出发一定能到达所有结点，而且不会影响结果的正确性。</li><li>第二种方法就比较暴力了，现在问题是有的结点访问不到怎么办，spfa又是求单源最短路，那我们直接一个for循环，每个结点都当一次源点，求n次单源最短路，这样就能访问到所有结点了。</li></ol><p>两种方法的时间复杂度我不太会分析，但是感觉好像差不多一样的。</p><h2 id="变化技巧"><a href="#变化技巧" class="headerlink" title="变化技巧"></a>变化技巧</h2><h3 id="不等式转化"><a href="#不等式转化" class="headerlink" title="不等式转化"></a>不等式转化</h3><p>有时候题中会给出三种不等式，但是求最短路只能有一种不等式，这时候我们就可以把其他不等式变化成一样的不等式，进而转化成图。</p><table><thead><tr><th style="text-align:center">题意</th><th style="text-align:center">转化</th><th style="text-align:center">连边</th></tr></thead><tbody><tr><td style="text-align:center">$x_i-x_j \leq b_k$</td><td style="text-align:center">$x_i-x_j \leq b_k$</td><td style="text-align:center">add(j, i, $b_k$)</td></tr><tr><td style="text-align:center">$x_i-x_j \geq b_k $</td><td style="text-align:center">$x_j-x_i \leq -b_k$</td><td style="text-align:center">add(i, j, -$b_k$)</td></tr><tr><td style="text-align:center">$x_i=x_j$</td><td style="text-align:center">$x_i-x_j \leq 0$, $x_j-x_i \leq 0$</td><td style="text-align:center">add(i, j, 0), add(j, i, 0)</td></tr></tbody></table><h3 id="最短路与最长路和差分约束的关系"><a href="#最短路与最长路和差分约束的关系" class="headerlink" title="最短路与最长路和差分约束的关系"></a>最短路与最长路和差分约束的关系</h3><p>有最短路了一定也有最长路，那他们和差分约束有什么关系呢？</p><p>当我们要求差分约束的最小值时，一定希望所有不等式都是大于等于号，这样求出来的一定是最小值。但是当我们有m个约束条件（即不等式），我们想要满足所有大于等于的不等式，我们一定得找到所有$ b_k $中最大的那一个，这样如果满足了最大的那个$ b_k $不等式，其他的大于等于不等式也一定都满足了。所以求$x_i-x_j$的最小值，就是求图中的最长路。所以，<strong>求最长路就是求差分约束中的最小值</strong>。求最长路的时候有正环则无解。</p><p>同理<strong>求最短路就是求差分约束的最大值</strong>。求最短路的时候有负环则无解。</p><p>什么？你问我最长路怎么求？把最短路算法中的小于号改成大于号不就行了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.org/problem/P1993" target="_blank" rel="noopener">洛谷P1993</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://oi-wiki.org" target="_blank" rel="noopener">OI-WiKi（一个算法竞赛的百科）</a></li><li><a href="https://zh.wikipedia.org/wiki/差分约束系统" target="_blank" rel="noopener">维基百科：差分约束系统</a></li><li><a href="https://www.luogu.org/blog/user33173/solution-p1993" target="_blank" rel="noopener">P1993小K的农场 题解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;差分约束&quot;&gt;&lt;a href=&quot;#差分约束&quot; class=&quot;headerlink&quot; title=&quot;差分约束&quot;&gt;&lt;/a&gt;差分约束&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;差分约束系统&lt;/strong&gt;是求解一组特殊的不等式组的方法。&lt;/p&gt;
&lt;h2 id=&quot;差分约束举例&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图的边存储--链式前向星</title>
    <link href="http://yoursite.com/2019/07/31/%E5%9B%BE%E7%9A%84%E8%BE%B9%E5%AD%98%E5%82%A8-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    <id>http://yoursite.com/2019/07/31/图的边存储-链式前向星/</id>
    <published>2019-07-31T11:01:36.000Z</published>
    <updated>2019-09-18T16:39:36.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的边存储–链式前向星"><a href="#图的边存储–链式前向星" class="headerlink" title="图的边存储–链式前向星"></a>图的边存储–链式前向星</h1><p>链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感觉好像没怎么听说过。还要定义结构体，而且需要辅助数组，感觉挺麻烦的。还不如直接用STL的vector+pair定义的邻接表好用。但是后来发现大家写SPFA的时候都用的链式前向星，感觉还是写个博客学习一下吧，以前都没听说过，太菜了。。。</p><p>边存储结构存的都是有向边！！！</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>适用范围广，基本上所有图论的题都能用链式前向星来存储。</li><li>存储效率高，像邻接表一样不会存储不存在的边</li><li>可以用来替代邻接表，用vector实现邻接表好像容易爆内存(看别人说的)好像也确实，vector在容量不够时会重新开辟一个两倍于原来大小的数组。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>邻接表的缺点它都有，<ul><li>无法判断重边(必须遍历查找)</li><li>无法操作某个特定的边(必须遍历查找)</li></ul></li><li>相对于邻接矩阵来说不容易实现和理解</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> net;<span class="comment">//1.</span></span><br><span class="line">     <span class="keyword">int</span> to;</span><br><span class="line">     <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;<span class="comment">//2.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_dege</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];<span class="comment">//3.</span></span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=edge[i].net)<span class="comment">//4.</span></span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>net是next，有时候定义next可能会和系统关键字重复，所以定义为net。net指向当前边的出发结点的下一条边在edge数组中的下标。SPFA是一个bfs的过程，进行广搜时会先遍历某个顶点的所有出边，net即指向当前结点的下一条出边。to即当前边的尾结点。w即权重。</li><li>head[u]即存储u结点的第一个出边在edge数组中的下标。cnt即记录当前存储到edge数组的第几位了，用来设置数组下标。</li><li>链式前向星是反着存储的，即先输入的边存在后面，有些类似于栈，后进先出。当a的第一条出边存入edge数组中，net等于head[u]，即-1。(所有head初始化为-1，-1表示没有边存入)之后head[u]被赋值为cnt，即刚输入的那条边在edge数组中的下标。当a的第二条边存入edge数组时，net等于head[u]，此时head[u]存的是上一次存储以u为出边的边在edge数组中的下标。每次head[u]存储的都是上一个u的边，所以遍历的时候是先遍历最后输入u的边。</li><li>链式前向星遍历结点u所有出边的方法，当等于-1时表示没有下一条边了，遍历结束。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/2019/07/31/图的边存储-链式前向星/TIM截图20190731195256.png" alt="TIM截图20190731195256" style="zoom:50%;"></p><p>输入顺序为：</p><table><thead><tr><th style="text-align:left">u = 0</th><th style="text-align:left">v = 1</th></tr></thead><tbody><tr><td style="text-align:left">u = 1</td><td style="text-align:left">v = 3</td></tr><tr><td style="text-align:left">u = 0</td><td style="text-align:left">v = 2</td></tr><tr><td style="text-align:left">u = 2</td><td style="text-align:left">v = 3</td></tr><tr><td style="text-align:left">u = 1</td><td style="text-align:left">v = 2</td></tr><tr><td style="text-align:left">u = 3</td><td style="text-align:left">v = 4</td></tr><tr><td style="text-align:left">u = 4</td><td style="text-align:left">v = 2</td></tr></tbody></table><p>手动模拟一下</p><table><thead><tr><th>edge[0].to = 1</th><th>edge[0].net = -1</th><th>head[0] = 0</th><th>cnt = 0</th></tr></thead><tbody><tr><td>edge[1].to = 3</td><td>edge[1].net = -1</td><td>head[1] = 0</td><td>cnt = 1</td></tr><tr><td>edge[2].to = 2</td><td>edge[2].net = 0</td><td>head[0] = 2</td><td>cnt = 2</td></tr><tr><td>edge[3].to = 3</td><td>edge[3].net = -1</td><td>head[2] = 0</td><td>cnt = 3</td></tr><tr><td>edge[4].to = 2</td><td>edge[4].net = 0</td><td>head[1] = 4</td><td>cnt = 4</td></tr><tr><td>edge[5].to = 4</td><td>edge[5].net = -1</td><td>head[3] = 5</td><td>cnt = 5</td></tr><tr><td>edge[6].to = 2</td><td>edge[6].net = -1</td><td>head[4] = 6</td><td>cnt = 6</td></tr></tbody></table><p>上图中0的出边有两条，在edge数组中的存储位置分别为0、2，最后head[0] = 2；当遍历以0为起点的边时，先从edge[2]开始遍历，可发现edge[2].net = 0;即以0为起点的最后一条边。可看出，遍历和输入顺序是相反的，但是并不影响结果。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/acdreamers/article/details/16902023(" target="_blank" rel="noopener">不知道为什么404了</a></li><li><a href="https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F" target="_blank" rel="noopener">ACM图论之存图方式</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的边存储–链式前向星&quot;&gt;&lt;a href=&quot;#图的边存储–链式前向星&quot; class=&quot;headerlink&quot; title=&quot;图的边存储–链式前向星&quot;&gt;&lt;/a&gt;图的边存储–链式前向星&lt;/h1&gt;&lt;p&gt;链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="图的存储" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>最短路--Floyd</title>
    <link href="http://yoursite.com/2019/07/30/%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd/"/>
    <id>http://yoursite.com/2019/07/30/最短路-Floyd/</id>
    <published>2019-07-30T07:42:20.000Z</published>
    <updated>2019-07-30T08:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–Floyd"><a href="#最短路–Floyd" class="headerlink" title="最短路–Floyd"></a>最短路–Floyd</h1><p>Floyd是用来求全局任意两点之间的最短路的。</p><p>Floyd很好理解，依次用每个点去松弛其它所有边，感觉没什么好讲的。理解了<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">dijkstra</a>和<a href="https://zhangzef.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/#more" target="_blank" rel="noopener">SPFA</a>之后，感觉Floyd就很简单易懂了，直接上代码吧。</p><p>时间复杂度：O(n^3)</p><p>空间复杂度：O(n^2)</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)<span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            d[i][j] = min(d[i][j], d[i][k]+d[k][j]);</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>其中n为图中顶点个数，k依次枚举所有顶点去松弛其它所有边。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–Floyd&quot;&gt;&lt;a href=&quot;#最短路–Floyd&quot; class=&quot;headerlink&quot; title=&quot;最短路–Floyd&quot;&gt;&lt;/a&gt;最短路–Floyd&lt;/h1&gt;&lt;p&gt;Floyd是用来求全局任意两点之间的最短路的。&lt;/p&gt;
&lt;p&gt;Floyd很好理解，依
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路--SPFA</title>
    <link href="http://yoursite.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/"/>
    <id>http://yoursite.com/2019/07/26/最短路-SPFA/</id>
    <published>2019-07-26T09:20:52.000Z</published>
    <updated>2019-09-18T16:40:00.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–SPFA"><a href="#最短路–SPFA" class="headerlink" title="最短路–SPFA"></a>最短路–SPFA</h1><p>SPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijkstra，但是有一种特殊的数据专门来卡SPFA，只能让dijkstra过，SPFA过不去，那就是网格图，我稍后会讲为什么网格图可以卡掉SPFA。</p><p>但是为什么SPFA跑不过dijkstra，大家还要用SPFA？因为dijkstra只能计算不带负环的图，当图中出现负环，dijkstra就会一直卡在负环里出不来了。如果不太懂可以看一看我的上一篇博客：<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">Dijkstra</a> </p><p>当图中存在可到达的负环，则该图一定不存在最短路，因为负环可以一直当做最短路来松弛其他边，那么最短路就能无限小，所以不存在最短路。</p><p><img src="/2019/07/26/最短路-SPFA/TIM截图20190726174245.png" alt="TIM截图20190726174245" style="zoom:50%;"></p><p>SPFA也是用来求<strong>单源</strong>最短路，它当然也不能在存在可达负环的时候计算最短路，但是他有一个神奇的功能：<strong>判断图中是否存在可达负环</strong>。</p><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a><strong>Bellman-Ford</strong></h2><p>SPFA是Bellman-Ford的队列优化，在一般情况下比Bellman-Ford快很多。这里介绍Bellman-Ford是希望可以更好地理解SPFA，因为两者本质区别不大。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>算法总共跑n-1轮就能确定所有点的最短路。总共有n个点，x1, x2, x3, x4…xn，其中x1为源点，第一轮一定可以确定离源点最近的点的最短路，即x2的最短路。依次类推，如果图中不存在负环，则一定能在n-1轮推出所有点的最短路。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>下面把敦爷讲课的时候的代码放出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n<span class="number">-1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]]+w[i])</span><br><span class="line">dis[v[i]] = dis[u[i]]+w[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>观察上面的Bellman-Ford可发现，当dis[u]没有被更新的时候，它依然会用dis[u]去松弛其它边，这样就做了很多冗余的操作，我们用一个队列来优化它，就是当有一个点被更新了，如果这个点没在队列里面，就把它放到队列里面去。这样一个点很久没有被更新过的话，就不会用它去更新其它边。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>此处建议先看懂我的上一篇博客：<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">Dijkstra</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[maxn], viscnt[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[s].push_back(make_pair(w, t));<span class="comment">//2.</span></span><br><span class="line">    G[t].push_back(make_pair(w, s));<span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//4.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span><span class="comment">//5.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//6.</span></span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = (i==s)?<span class="number">0</span>:INF;</span><br><span class="line">        inq[i] = <span class="literal">false</span>;</span><br><span class="line">        viscnt[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(make_pair(dis[s], s));<span class="comment">//7.</span></span><br><span class="line">    inq[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.front();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;<span class="comment">//8.</span></span><br><span class="line">        q.pop();</span><br><span class="line">        inq[x] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(viscnt[x]++&gt;n)<span class="comment">//9.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[x].size(); i++)<span class="comment">//10.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=G[x][i].second, w=G[x][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+w&lt;dis[y])<span class="comment">//11.</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x]+w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_pair(dis[y], y));</span><br><span class="line">                    inq[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>viscnt[i]用来计数第<strong>i</strong>个点被更新了几次，如果更新次数超过n，则说明图中存在负环。inq[i]表示第<strong>i</strong>个点是否在队列里面。存放pair的vector用来存放边和边权，G[i] [j]存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边。G[i] [j].second存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的另一个端点。G[i] [j].first存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的权重。maxn为自己定义的常量。</li><li>将边添加至vector中，s、w、t 说明同上。</li><li>无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。</li><li>初始化vector，清空所有先前加入的边。</li><li>SPFA当图中<strong>存在负环</strong>时返回<strong>true</strong>，<strong>不存在</strong>时返回<strong>false</strong>。</li><li>初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。viscnt和inq设为0和false。</li><li>将源点压入队列。inq[s]设为true。</li><li>依次取队首元素。取出后inq[i]设为false。</li><li>每次访问一个点，令这个点的viscnt++，当这个点的访问次数超过n次，则说明图中存在负环。</li><li>依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重。</li><li>进行松弛操作，如果某个点松弛操作成功，则把它压入队列。</li></ol><h2 id="如何卡SPFA"><a href="#如何卡SPFA" class="headerlink" title="如何卡SPFA"></a>如何卡SPFA</h2><p>因为SPFA没回更新的时候用的是一条边去更新，被更新过的点入队。</p><p>比如说我们有一条链</p><p><img src="/2019/07/26/最短路-SPFA/TIM截图20190727121644.png" alt="TIM截图20190727121644" style="zoom:50%;"></p><p>当我们用边0-1去更新后面所有边之后，如果边0-1又被更新，则后面的所有边都要被依次再更新一遍。</p><p>这样SPFA的时间复杂度就会变得非常高</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://www.cometoj.com/live/10810/replay?replayId=1&amp;page=1" target="_blank" rel="noopener">2019ccpc夏令营敦爷讲的图论</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–SPFA&quot;&gt;&lt;a href=&quot;#最短路–SPFA&quot; class=&quot;headerlink&quot; title=&quot;最短路–SPFA&quot;&gt;&lt;/a&gt;最短路–SPFA&lt;/h1&gt;&lt;p&gt;SPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijks
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路--Dijkstra</title>
    <link href="http://yoursite.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/"/>
    <id>http://yoursite.com/2019/07/25/最短路--Dijkstra/</id>
    <published>2019-07-25T06:47:11.000Z</published>
    <updated>2019-09-18T16:39:42.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–Dijkstra"><a href="#最短路–Dijkstra" class="headerlink" title="最短路–Dijkstra"></a>最短路–Dijkstra</h1><p>Dijkstra是单源最短路算法，用于求<strong>正权</strong>图源点到每个顶点的最短路。Dijkstra用到了一些BFS的思想</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>初始化dis数组和vis数组。<ol><li>dis[i]表示源点到第<strong>i</strong>个点的距离，初始化为INF，表示无穷大。（INF为自己定义）</li><li>vis[i]数组表示第<strong>i</strong>个点的最短路是否用于处理过未求出最短路的点。（当用优先队列的时候则不用vis数组）</li></ol></li><li>找出当前最短dis[i]，并且vis[i]为false的点。如果找不到，则最短路求解完成，算法结束。</li><li>令vis[i]为true，表示已经使用过该最短路处理其dis[i]，防止重复使用。依次遍历其余所有点，令dis[j] = min(dis[j], dis[i]+w[i] [j])<ol><li>w[i] [j]表示点i到点j的距离。这一步表示源点到<strong>i</strong>加上<strong>i</strong>到<strong>j</strong>的距离和源点到<strong>j</strong>的距离哪个小。</li></ol></li></ol><p><img src="/2019/07/25/最短路--Dijkstra/TIM截图20190725160913.png" alt="TIM截图20190725160913" style="zoom:50%;"></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="邻接矩阵版"><a href="#邻接矩阵版" class="headerlink" title="邻接矩阵版"></a>邻接矩阵版</h3><p>时间复杂度为O(n*n)    n为顶点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span><span class="comment">//1.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//2.</span></span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = w[s][i];</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//3.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = INF, x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)<span class="comment">//4.</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;mn)</span><br><span class="line">            &#123;</span><br><span class="line">                mn = dis[j];</span><br><span class="line">                x=j;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mn==INF)<span class="comment">//5.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        vis[x] = <span class="literal">true</span>;<span class="comment">//6.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            dis[j] = min(dis[j], dis[x]+w[x][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>n为结点个数，s为源点。</li><li>初始化dis数组和vis数组</li><li>依次遍历每个结点</li><li>找出当先未使用过的最短路，并把下标存入x</li><li>如果全部使用过则算法结束</li><li>vis[x]设为true，比较dis[j]和dis[x]+w[x] [j]的大小</li></ol><h3 id="优先队列版"><a href="#优先队列版" class="headerlink" title="优先队列版"></a>优先队列版</h3><p>用优先队列优化dijkstra大部分时间优于普通版，但是在完全图时普通版更好。</p><p>时间复杂度：O((m+n)logm)    其中n为顶点数，m为边数。所以当完全图时普通版更好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[s].push_back(make_pair(w, t));<span class="comment">//2.</span></span><br><span class="line">    G[t].push_back(make_pair(w, s));<span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//4.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//5.</span></span><br><span class="line">        dis[i] = (i==s)?<span class="number">0</span>:INF;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;,</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;,</span><br><span class="line">    greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;<span class="comment">//6.</span></span><br><span class="line">    q.push(make_pair(dis[s], s));<span class="comment">//7.</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.top();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;<span class="comment">//8.</span></span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[x].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=G[x][i].second, w=G[x][i].first;<span class="comment">//9.</span></span><br><span class="line">            <span class="keyword">if</span>(dis[x]+w&lt;dis[y])<span class="comment">//10.</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x]+w;</span><br><span class="line">                q.push(make_pair(dis[y], y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>存放pair的vector用来存放边和边权，因为pair比较大小是first优先，所以pair的first放的是权重。G[i] [j]存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边。G[i] [j].second存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的另一个端点。G[i] [j].first存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的权重。maxn为自己定义的常量。</li><li>将边添加至vector中，s、w、t 说明同上。</li><li>无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。</li><li>初始化vector，清空所有先前加入的边。</li><li>初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。</li><li>定义优先队列，第一个参数为数据类型，比较pair类型，pair的first优先。第二个参数为存储容器，和先前存边的vector定义相同。第三个参数表示小顶堆(greater为小顶堆，less为大顶堆)。</li><li>将源点压入队列。</li><li>x存放当前未访问过的权值最小边的一端结点编号。</li><li>依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重</li><li>该步骤通邻接矩阵dijkstra相似</li></ol><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p>hdoj1874</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://blog.csdn.net/sinat_30062549/article/details/47025277" target="_blank" rel="noopener">dijkstra几大模板（这里面的优先队列模板好像时错的，我只参考了他的stl用法）</a></li><li><a href="https://blog.csdn.net/u013569304/article/details/51147000" target="_blank" rel="noopener">C++ pair的比较大小</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–Dijkstra&quot;&gt;&lt;a href=&quot;#最短路–Dijkstra&quot; class=&quot;headerlink&quot; title=&quot;最短路–Dijkstra&quot;&gt;&lt;/a&gt;最短路–Dijkstra&lt;/h1&gt;&lt;p&gt;Dijkstra是单源最短路算法，用于求&lt;strong&gt;正权
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/07/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/07/22/并查集/</id>
    <published>2019-07-22T02:33:37.000Z</published>
    <updated>2019-09-18T16:39:17.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种树型数据结构，用于<strong>查找</strong>不相交的<strong>子集</strong>，并将他们<strong>合并</strong>在一起，简称并查集。并查集分为<strong>拆分</strong>、<strong>查找</strong>和<strong>合并</strong>三个操作。</p><h2 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li>pre数组记录所有结点的前驱结点，根节点的前驱结点是它自己</li><li>find函数先找到x的根节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];<span class="comment">//1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//2.</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )<span class="comment">//3.</span></span><br><span class="line">          r=pre[r];</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>记录前驱结点</li><li>查找根节点</li><li>找到根节点 r</li></ol><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ol><li><p>join函数先找到两个变量的根节点</p><ul><li><p>​    如果他们相同则说明两个变量在同一个集合中</p></li><li><p>​    如果不同则将其中一个根节点设置为另外一个根节点的前驱</p></li></ul></li></ol><p><img src="/2019/07/22/并查集/TIM截图20190722191109.png" alt="TIM截图20190722191109" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//1.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        pre[fx ]=fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>判断x y是否连通，如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起。</li></ol><h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>路径压缩是在寻找根结点的过程中，将子集中所有的点的前驱设置为根结点。</p><p>为什么要进行路径压缩呢？因为在并查集合并过程中，他有可能变成一个<strong>单链表</strong>，这样每次寻找根结点要遍历子集中所有的结点。进行路径压缩之后，每次寻找根结点只需访问他的父结点就可找到根结点。</p><p><img src="/2019/07/22/并查集/TIM截图20190722182225.png" alt="TIM截图20190722182225"></p><p>优化后的<strong><u>find</u></strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                            </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                   </span><br><span class="line">          r=pre[r];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )<span class="comment">//1.</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ];<span class="comment">//2.</span></span><br><span class="line">         pre[ i ]= r ;<span class="comment">//3.</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>路径压缩</li><li>在改变上级之前用临时变量j记录下他的值</li><li>把上级改为根节点</li></ol><h3 id="按秩-Rank-合并"><a href="#按秩-Rank-合并" class="headerlink" title="按秩(Rank)合并"></a>按秩(Rank)合并</h3><p>按秩合并就是在合并过程中将元素所在深度小的集合合并到元素所在深度大的集合</p><p>为什么要按秩合并呢？因为如果将元素深度大的集合合并到小的集合，那么合并后的集合深度则等于较大的深度加一。如果将深度小的集合合并到深度大的集合，则合并后的集合深度不变。</p><p><img src="/2019/07/22/并查集/TIM截图20190722182240.png" alt="TIM截图20190722182240"></p><p>优化后的<strong><u>join</u></strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(rank[fx]&gt;rank[fy])<span class="comment">//1.</span></span><br><span class="line">        pre[fy] = pre[fx];<span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre[fx] = fy;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx]==rank[fy])<span class="comment">//3.</span></span><br><span class="line">            rank[fy]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>rank数组为当前结点秩的值</li><li>只需要比较根结点的rank值就够了</li><li>修改时也只用修改根结点的rank值</li></ol><h2 id="并查集的精简实现"><a href="#并查集的精简实现" class="headerlink" title="并查集的精简实现"></a>并查集的精简实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) pre[i]=i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> pre[x]=x?x:pre[x]=get(pre[x]); &#125;<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; pre[get(x)] = get[y]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//2.</span></span><br><span class="line">    pre[rank[find(x)&gt;rank[find(y)?find(y):find(x)] = pre[rank[find(x)&gt;rank[find(y)?find(x):find(y)];</span><br><span class="line"><span class="keyword">if</span>(rank[find(x)]==rank[find(y)]) rank[find(y)]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>根结点的pre为0。</li><li>带秩合并，还没验证，不能确定对错。</li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="noopener">维基百科：并查集</a></li><li><a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">并查集详解——图文解说，简单易懂（转）</a></li><li><a href="https://www.acwing.com/blog/content/97/" target="_blank" rel="noopener">并查集笔记&amp;模板</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;并查集是一种树型数据结构，用于&lt;strong&gt;查找&lt;/strong&gt;不相交的&lt;strong&gt;子集&lt;/strong&gt;，并将他们&lt;str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>可以评论了！！！</title>
    <link href="http://yoursite.com/2018/11/02/%E5%8F%AF%E4%BB%A5%E8%AF%84%E8%AE%BA%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2018/11/02/可以评论了！！！/</id>
    <published>2018-11-01T16:35:39.000Z</published>
    <updated>2018-11-01T16:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来吐槽吧"><a href="#来吐槽吧" class="headerlink" title="来吐槽吧"></a>来吐槽吧</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;来吐槽吧&quot;&gt;&lt;a href=&quot;#来吐槽吧&quot; class=&quot;headerlink&quot; title=&quot;来吐槽吧&quot;&gt;&lt;/a&gt;来吐槽吧&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello Word!</title>
    <link href="http://yoursite.com/2018/11/01/Hello-Word/"/>
    <id>http://yoursite.com/2018/11/01/Hello-Word/</id>
    <published>2018-10-31T17:17:19.000Z</published>
    <updated>2018-10-31T17:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HELLO-WORD"><a href="#HELLO-WORD" class="headerlink" title="HELLO WORD!!!"></a>HELLO WORD!!!</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HELLO-WORD&quot;&gt;&lt;a href=&quot;#HELLO-WORD&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORD!!!&quot;&gt;&lt;/a&gt;HELLO WORD!!!&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
