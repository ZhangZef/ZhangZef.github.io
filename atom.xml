<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>__int64-Saturday</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-11T09:05:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张泽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>差分约束</title>
    <link href="http://yoursite.com/2019/08/01/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2019/08/01/差分约束/</id>
    <published>2019-08-01T06:53:59.000Z</published>
    <updated>2019-08-11T09:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h1><p><strong>差分约束系统</strong>是求解一组特殊的不等式组的方法。</p><h2 id="差分约束举例"><a href="#差分约束举例" class="headerlink" title="差分约束举例"></a>差分约束举例</h2><p>差分约束是有n个变量和m个不等式组成的。其中每个不等式都是形如：$x_i-x_j \leq b_k(i,j\in[1,n], k\in[1,m])$  或 $x_i-x_j \geq b_k(i,j\in[1,n], k\in[1,m])$ 。</p><p>其中x为n个变量，b为m个不等式右边的值，用b的值来约束x的差称为差分约束。求一组解：$x_1=a_1,\quad x_2=a_2,\cdots x_n=a_n$使得所有约束条件(即m个不等式)均成立，则称差分约束有解，否则无解。</p><p>例如：<br>$$<br>(1)x_1-x_3 \leq 5;\quad<br>(2)x_3-x_5 \leq 4;\quad<br>$$<br>$$<br>(3)x_3-x_2 \leq 1;\quad<br>(4)x_1-x_5 \leq 10;\quad<br>(5)x_2-x_5 \leq 2;\quad<br>$$</p><p>观察$ x_1-x_5 $的关系，有如下三种关系：</p><ol><li>(4)                $x_1-x_5 \leq 10$</li><li>(1)+(2)         $x_1-x_5 \leq 9$</li><li>(1)+(3)+(5)   $x_1-x_5 \leq 8 $</li></ol><p>因为要满足所有等式的关系，所以取其中最大的3.$x_1-x_5 \leq 8$  因为8一定小于9和10嘛，如果$x_1-x_5$小于等于8了，那他们一定小于等于9和10。</p><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p>观察可发现 $x_i-x_j \leq b_k$ 可转换为：$x_i \leq b_k+x_j$ 。与求最短路公式中的dis[j]&lt;dis[i]+w[i, j]非常相似，那差分约束问题是不是也可以转化成最短路问题来求解呢？肯定是可以的！先来看个例子：</p><p><img src="/2019/08/01/差分约束/TIM截图20190801164055-1564649436098.png" alt="TIM截图20190801164055"></p><p>仔细观察图中可发现总共有三条路径：</p><ol><li>5 -&gt; 1                      长度为10</li><li>5 -&gt; 3 -&gt; 1               长度为9</li><li>5 -&gt; 2 -&gt; 3 -&gt; 1        长度为8</li></ol><p>很容易发现从5到1的最短路径是8。那为什么求差分约束问题能和最短路问题联系到一起呢？此处要先了解最短路知识，不懂的可以看一看我前面写的博客：1.<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/" target="_blank" rel="noopener">dijkstra</a>    2.<a href="https://zhangzef.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/" target="_blank" rel="noopener">SPFA</a>    3.<a href="https://zhangzef.com/2019/07/30/%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd/" target="_blank" rel="noopener">Floyd</a></p><h2 id="差分约束和最短路问题"><a href="#差分约束和最短路问题" class="headerlink" title="差分约束和最短路问题"></a>差分约束和最短路问题</h2><p>对于每个不等式$x_i-x_j \leq b_k$，我们都从结点j向结点i连一条长度为$b_k$的有向边。此时再看上面给出的那些不等式所转化成的图，是否和给出的图一样呢，最后求解的答案也一样。那么我们将差分约束问题转化成最短路问题，由最短路知识可知，当图中存在可达到的负环时，最短路一定无解。所以可以用SPFA来判断该差分约束问题是否有解。</p><p>这时候就有一个问题了，在最短路中有些点是不可达的，当遇到不可达的负环用SPFA一定判断不出来，但此时差分约束却是无解的。怎么办呢？有两种方法，其实本质都是一样的：</p><ol><li>我们新定义一个结点，可以是$x_0$，让它向所有其它结点连一条边，让这些边的权值为0。因为SPFA是一个bfs的过程(有些题目需要把spfa改成dfs的形式，但是并不影响它访问的结点个数，只是访问顺序不一样)，所以从这个结点出发一定能到达所有结点，而且不会影响结果的正确性。</li><li>第二种方法就比较暴力了，现在问题是有的结点访问不到怎么办，spfa又是求单源最短路，那我们直接一个for循环，每个结点都当一次源点，求n次单源最短路，这样就能访问到所有结点了。</li></ol><p>两种方法的时间复杂度我不太会分析，但是感觉好像差不多一样的。</p><h2 id="变化技巧"><a href="#变化技巧" class="headerlink" title="变化技巧"></a>变化技巧</h2><h3 id="不等式转化"><a href="#不等式转化" class="headerlink" title="不等式转化"></a>不等式转化</h3><p>有时候题中会给出三种不等式，但是求最短路只能有一种不等式，这时候我们就可以把其他不等式变化成一样的不等式，进而转化成图。</p><table><thead><tr><th style="text-align:center">题意</th><th style="text-align:center">转化</th><th style="text-align:center">连边</th></tr></thead><tbody><tr><td style="text-align:center">$x_i-x_j \leq b_k$</td><td style="text-align:center">$x_i-x_j \leq b_k$</td><td style="text-align:center">add(j, i, $b_k$)</td></tr><tr><td style="text-align:center">$x_i-x_j \geq b_k $</td><td style="text-align:center">$x_j-x_i \leq -b_k$</td><td style="text-align:center">add(i, j, -$b_k$)</td></tr><tr><td style="text-align:center">$x_i=x_j$</td><td style="text-align:center">$x_i-x_j \leq 0$, $x_j-x_i \leq 0$</td><td style="text-align:center">add(i, j, 0), add(j, i, 0)</td></tr></tbody></table><h3 id="最短路与最长路和差分约束的关系"><a href="#最短路与最长路和差分约束的关系" class="headerlink" title="最短路与最长路和差分约束的关系"></a>最短路与最长路和差分约束的关系</h3><p>有最短路了一定也有最长路，那他们和差分约束有什么关系呢？</p><p>当我们要求差分约束的最小值时，一定希望所有不等式都是大于等于号，这样求出来的一定是最小值。但是当我们有m个约束条件（即不等式），我们想要满足所有大于等于的不等式，我们一定得找到所有$ b_k $中最大的那一个，这样如果满足了最大的那个$ b_k $不等式，其他的大于等于不等式也一定都满足了。所以求$x_i-x_j$的最小值，就是求图中的最长路。所以，<strong>求最长路就是求差分约束中的最小值</strong>。求最长路的时候有正环则无解。</p><p>同理<strong>求最短路就是求差分约束的最大值</strong>。求最短路的时候有负环则无解。</p><p>什么？你问我最长路怎么求？把最短路算法中的小于号改成大于号不就行了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.org/problem/P1993" target="_blank" rel="noopener">洛谷P1993</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://oi-wiki.org" target="_blank" rel="noopener">OI-WiKi（一个算法竞赛的百科）</a></li><li><a href="https://zh.wikipedia.org/wiki/差分约束系统" target="_blank" rel="noopener">维基百科：差分约束系统</a></li><li><a href="https://www.luogu.org/blog/user33173/solution-p1993" target="_blank" rel="noopener">P1993小K的农场 题解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;差分约束&quot;&gt;&lt;a href=&quot;#差分约束&quot; class=&quot;headerlink&quot; title=&quot;差分约束&quot;&gt;&lt;/a&gt;差分约束&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;差分约束系统&lt;/strong&gt;是求解一组特殊的不等式组的方法。&lt;/p&gt;
&lt;h2 id=&quot;差分约束举例&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>图的边存储--链式前向星</title>
    <link href="http://yoursite.com/2019/07/31/%E5%9B%BE%E7%9A%84%E8%BE%B9%E5%AD%98%E5%82%A8-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    <id>http://yoursite.com/2019/07/31/图的边存储-链式前向星/</id>
    <published>2019-07-31T11:01:36.000Z</published>
    <updated>2019-08-11T09:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的边存储–链式前向星"><a href="#图的边存储–链式前向星" class="headerlink" title="图的边存储–链式前向星"></a>图的边存储–链式前向星</h1><p>链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感觉好像没怎么听说过。还要定义结构体，而且需要辅助数组，感觉挺麻烦的。还不如直接用STL的vector+pair定义的邻接表好用。但是后来发现大家写SPFA的时候都用的链式前向星，感觉还是写个博客学习一下吧，以前都没听说过，太菜了。。。</p><p>边存储结构存的都是有向边！！！</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>适用范围广，基本上所有图论的题都能用链式前向星来存储。</li><li>存储效率高，像邻接表一样不会存储不存在的边</li><li>可以用来替代邻接表，用vector实现邻接表好像容易爆内存(看别人说的)好像也确实，vector在容量不够时会重新开辟一个两倍于原来大小的数组。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>邻接表的缺点它都有，<ul><li>无法判断重边(必须遍历查找)</li><li>无法操作某个特定的边(必须遍历查找)</li></ul></li><li>相对于邻接矩阵来说不容易实现和理解</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> net;<span class="comment">//1.</span></span><br><span class="line">     <span class="keyword">int</span> to;</span><br><span class="line">     <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;<span class="comment">//2.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_dege</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];<span class="comment">//3.</span></span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=edge[i].net)<span class="comment">//4.</span></span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>net是next，有时候定义next可能会和系统关键字重复，所以定义为net。net指向当前边的出发结点的下一条边在edge数组中的下标。SPFA是一个bfs的过程，进行广搜时会先遍历某个顶点的所有出边，net即指向当前结点的下一条出边。to即当前边的尾结点。w即权重。</li><li>head[u]即存储u结点的第一个出边在edge数组中的下标。cnt即记录当前存储到edge数组的第几位了，用来设置数组下标。</li><li>链式前向星是反着存储的，即先输入的边存在后面，有些类似于栈，后进先出。当a的第一条出边存入edge数组中，net等于head[u]，即-1。(所有head初始化为-1，-1表示没有边存入)之后head[u]被赋值为cnt，即刚输入的那条边在edge数组中的下标。当a的第二条边存入edge数组时，net等于head[u]，此时head[u]存的是上一次存储以u为出边的边在edge数组中的下标。每次head[u]存储的都是上一个u的边，所以遍历的时候是先遍历最后输入u的边。</li><li>链式前向星遍历结点u所有出边的方法，当等于-1时表示没有下一条边了，遍历结束。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/2019/07/31/图的边存储-链式前向星/TIM截图20190731195256.png" alt="TIM截图20190731195256"></p><p>输入顺序为：</p><table><thead><tr><th style="text-align:left">u = 0</th><th style="text-align:left">v = 1</th></tr></thead><tbody><tr><td style="text-align:left">u = 1</td><td style="text-align:left">v = 3</td></tr><tr><td style="text-align:left">u = 0</td><td style="text-align:left">v = 2</td></tr><tr><td style="text-align:left">u = 2</td><td style="text-align:left">v = 3</td></tr><tr><td style="text-align:left">u = 1</td><td style="text-align:left">v = 2</td></tr><tr><td style="text-align:left">u = 3</td><td style="text-align:left">v = 4</td></tr><tr><td style="text-align:left">u = 4</td><td style="text-align:left">v = 2</td></tr></tbody></table><p>手动模拟一下</p><table><thead><tr><th>edge[0].to = 1</th><th>edge[0].net = -1</th><th>head[0] = 0</th><th>cnt = 0</th></tr></thead><tbody><tr><td>edge[1].to = 3</td><td>edge[1].net = -1</td><td>head[1] = 0</td><td>cnt = 1</td></tr><tr><td>edge[2].to = 2</td><td>edge[2].net = 0</td><td>head[0] = 2</td><td>cnt = 2</td></tr><tr><td>edge[3].to = 3</td><td>edge[3].net = -1</td><td>head[2] = 0</td><td>cnt = 3</td></tr><tr><td>edge[4].to = 2</td><td>edge[4].net = 0</td><td>head[1] = 4</td><td>cnt = 4</td></tr><tr><td>edge[5].to = 4</td><td>edge[5].net = -1</td><td>head[3] = 5</td><td>cnt = 5</td></tr><tr><td>edge[6].to = 2</td><td>edge[6].net = -1</td><td>head[4] = 6</td><td>cnt = 6</td></tr></tbody></table><p>上图中0的出边有两条，在edge数组中的存储位置分别为0、2，最后head[0] = 2；当遍历以0为起点的边时，先从edge[2]开始遍历，可发现edge[2].net = 0;即以0为起点的最后一条边。可看出，遍历和输入顺序是相反的，但是并不影响结果。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/acdreamers/article/details/16902023(" target="_blank" rel="noopener">不知道为什么404了</a></li><li><a href="https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F" target="_blank" rel="noopener">ACM图论之存图方式</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的边存储–链式前向星&quot;&gt;&lt;a href=&quot;#图的边存储–链式前向星&quot; class=&quot;headerlink&quot; title=&quot;图的边存储–链式前向星&quot;&gt;&lt;/a&gt;图的边存储–链式前向星&lt;/h1&gt;&lt;p&gt;链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图的存储" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>最短路--Floyd</title>
    <link href="http://yoursite.com/2019/07/30/%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd/"/>
    <id>http://yoursite.com/2019/07/30/最短路-Floyd/</id>
    <published>2019-07-30T07:42:20.000Z</published>
    <updated>2019-07-30T08:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–Floyd"><a href="#最短路–Floyd" class="headerlink" title="最短路–Floyd"></a>最短路–Floyd</h1><p>Floyd是用来求全局任意两点之间的最短路的。</p><p>Floyd很好理解，依次用每个点去松弛其它所有边，感觉没什么好讲的。理解了<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">dijkstra</a>和<a href="https://zhangzef.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/#more" target="_blank" rel="noopener">SPFA</a>之后，感觉Floyd就很简单易懂了，直接上代码吧。</p><p>时间复杂度：O(n^3)</p><p>空间复杂度：O(n^2)</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)<span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            d[i][j] = min(d[i][j], d[i][k]+d[k][j]);</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>其中n为图中顶点个数，k依次枚举所有顶点去松弛其它所有边。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–Floyd&quot;&gt;&lt;a href=&quot;#最短路–Floyd&quot; class=&quot;headerlink&quot; title=&quot;最短路–Floyd&quot;&gt;&lt;/a&gt;最短路–Floyd&lt;/h1&gt;&lt;p&gt;Floyd是用来求全局任意两点之间的最短路的。&lt;/p&gt;
&lt;p&gt;Floyd很好理解，依
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路--SPFA</title>
    <link href="http://yoursite.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/"/>
    <id>http://yoursite.com/2019/07/26/最短路-SPFA/</id>
    <published>2019-07-26T09:20:52.000Z</published>
    <updated>2019-08-11T09:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–SPFA"><a href="#最短路–SPFA" class="headerlink" title="最短路–SPFA"></a>最短路–SPFA</h1><p>SPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijkstra，但是有一种特殊的数据专门来卡SPFA，只能让dijkstra过，SPFA过不去，那就是网格图，我稍后会讲为什么网格图可以卡掉SPFA。</p><p>但是为什么SPFA跑不过dijkstra，大家还要用SPFA？因为dijkstra只能计算不带负环的图，当图中出现负环，dijkstra就会一直卡在负环里出不来了。如果不太懂可以看一看我的上一篇博客：<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">Dijkstra</a> </p><p>当图中存在可到达的负环，则该图一定不存在最短路，因为负环可以一直当做最短路来松弛其他边，那么最短路就能无限小，所以不存在最短路。</p><p><img src="/2019/07/26/最短路-SPFA/TIM截图20190726174245.png" alt="TIM截图20190726174245"></p><p>SPFA也是用来求<strong>单源</strong>最短路，它当然也不能在存在可达负环的时候计算最短路，但是他有一个神奇的功能：<strong>判断图中是否存在可达负环</strong>。</p><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a><strong>Bellman-Ford</strong></h2><p>SPFA是Bellman-Ford的队列优化，在一般情况下比Bellman-Ford快很多。这里介绍Bellman-Ford是希望可以更好地理解SPFA，因为两者本质区别不大。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>算法总共跑n-1轮就能确定所有点的最短路。总共有n个点，x1, x2, x3, x4…xn，其中x1为源点，第一轮一定可以确定离源点最近的点的最短路，即x2的最短路。依次类推，如果图中不存在负环，则一定能在n-1轮推出所有点的最短路。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>下面把敦爷讲课的时候的代码放出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n<span class="number">-1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]]+w[i])</span><br><span class="line">dis[v[i]] = dis[u[i]]+w[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>观察上面的Bellman-Ford可发现，当dis[u]没有被更新的时候，它依然会用dis[u]去松弛其它边，这样就做了很多冗余的操作，我们用一个队列来优化它，就是当有一个点被更新了，如果这个点没在队列里面，就把它放到队列里面去。这样一个点很久没有被更新过的话，就不会用它去更新其它边。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>此处建议先看懂我的上一篇博客：<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">Dijkstra</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[maxn], viscnt[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[s].push_back(make_pair(w, t));<span class="comment">//2.</span></span><br><span class="line">    G[t].push_back(make_pair(w, s));<span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//4.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span><span class="comment">//5.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//6.</span></span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = (i==s)?<span class="number">0</span>:INF;</span><br><span class="line">        inq[i] = <span class="literal">false</span>;</span><br><span class="line">        viscnt[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(make_pair(dis[s], s));<span class="comment">//7.</span></span><br><span class="line">    inq[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.front();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;<span class="comment">//8.</span></span><br><span class="line">        q.pop();</span><br><span class="line">        inq[x] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(viscnt[x]++&gt;n)<span class="comment">//9.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[x].size(); i++)<span class="comment">//10.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=G[x][i].second, w=G[x][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+w&lt;dis[y])<span class="comment">//11.</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x]+w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_pair(dis[y], y));</span><br><span class="line">                    inq[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>viscnt[i]用来计数第<strong>i</strong>个点被更新了几次，如果更新次数超过n，则说明图中存在负环。inq[i]表示第<strong>i</strong>个点是否在队列里面。存放pair的vector用来存放边和边权，G[i] [j]存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边。G[i] [j].second存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的另一个端点。G[i] [j].first存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的权重。maxn为自己定义的常量。</li><li>将边添加至vector中，s、w、t 说明同上。</li><li>无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。</li><li>初始化vector，清空所有先前加入的边。</li><li>SPFA当图中<strong>存在负环</strong>时返回<strong>true</strong>，<strong>不存在</strong>时返回<strong>false</strong>。</li><li>初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。viscnt和inq设为0和false。</li><li>将源点压入队列。inq[s]设为true。</li><li>依次取队首元素。取出后inq[i]设为false。</li><li>每次访问一个点，令这个点的viscnt++，当这个点的访问次数超过n次，则说明图中存在负环。</li><li>依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重。</li><li>进行松弛操作，如果某个点松弛操作成功，则把它压入队列。</li></ol><h2 id="如何卡SPFA"><a href="#如何卡SPFA" class="headerlink" title="如何卡SPFA"></a>如何卡SPFA</h2><p>因为SPFA没回更新的时候用的是一条边去更新，被更新过的点入队。</p><p>比如说我们有一条链</p><p><img src="/2019/07/26/最短路-SPFA/TIM截图20190727121644.png" alt="TIM截图20190727121644"></p><p>当我们用边0-1去更新后面所有边之后，如果边0-1又被更新，则后面的所有边都要被依次再更新一遍。</p><p>这样SPFA的时间复杂度就会变得非常高</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://www.cometoj.com/live/10810/replay?replayId=1&amp;page=1" target="_blank" rel="noopener">2019ccpc夏令营敦爷讲的图论</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–SPFA&quot;&gt;&lt;a href=&quot;#最短路–SPFA&quot; class=&quot;headerlink&quot; title=&quot;最短路–SPFA&quot;&gt;&lt;/a&gt;最短路–SPFA&lt;/h1&gt;&lt;p&gt;SPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijks
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路--Dijkstra</title>
    <link href="http://yoursite.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/"/>
    <id>http://yoursite.com/2019/07/25/最短路--Dijkstra/</id>
    <published>2019-07-25T06:47:11.000Z</published>
    <updated>2019-08-11T09:11:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–Dijkstra"><a href="#最短路–Dijkstra" class="headerlink" title="最短路–Dijkstra"></a>最短路–Dijkstra</h1><p>Dijkstra是单源最短路算法，用于求<strong>正权</strong>图源点到每个顶点的最短路。Dijkstra用到了一些BFS的思想</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>初始化dis数组和vis数组。<ol><li>dis[i]表示源点到第<strong>i</strong>个点的距离，初始化为INF，表示无穷大。（INF为自己定义）</li><li>vis[i]数组表示第<strong>i</strong>个点的最短路是否用于处理过未求出最短路的点。（当用优先队列的时候则不用vis数组）</li></ol></li><li>找出当前最短dis[i]，并且vis[i]为false的点。如果找不到，则最短路求解完成，算法结束。</li><li>令vis[i]为true，表示已经使用过该最短路处理其dis[i]，防止重复使用。依次遍历其余所有点，令dis[j] = min(dis[j], dis[i]+w[i] [j])<ol><li>w[i] [j]表示点i到点j的距离。这一步表示源点到<strong>i</strong>加上<strong>i</strong>到<strong>j</strong>的距离和源点到<strong>j</strong>的距离哪个小。</li></ol></li></ol><p><img src="/2019/07/25/最短路--Dijkstra/TIM截图20190725160913.png" alt="TIM截图20190725160913"></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="邻接矩阵版"><a href="#邻接矩阵版" class="headerlink" title="邻接矩阵版"></a>邻接矩阵版</h3><p>时间复杂度为O(n*n)    n为顶点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span><span class="comment">//1.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//2.</span></span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = w[s][i];</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//3.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = INF, x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)<span class="comment">//4.</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;mn)</span><br><span class="line">            &#123;</span><br><span class="line">                mn = dis[j];</span><br><span class="line">                x=j;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mn==INF)<span class="comment">//5.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        vis[x] = <span class="literal">true</span>;<span class="comment">//6.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            dis[j] = min(dis[j], dis[x]+w[x][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>n为结点个数，s为源点。</li><li>初始化dis数组和vis数组</li><li>依次遍历每个结点</li><li>找出当先未使用过的最短路，并把下标存入x</li><li>如果全部使用过则算法结束</li><li>vis[x]设为true，比较dis[j]和dis[x]+w[x] [j]的大小</li></ol><h3 id="优先队列版"><a href="#优先队列版" class="headerlink" title="优先队列版"></a>优先队列版</h3><p>用优先队列优化dijkstra大部分时间优于普通版，但是在完全图时普通版更好。</p><p>时间复杂度：O((m+n)logm)    其中n为顶点数，m为边数。所以当完全图时普通版更好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[s].push_back(make_pair(w, t));<span class="comment">//2.</span></span><br><span class="line">    G[t].push_back(make_pair(w, s));<span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//4.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//5.</span></span><br><span class="line">        dis[i] = (i==s)?<span class="number">0</span>:INF;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;,</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;,</span><br><span class="line">    greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;<span class="comment">//6.</span></span><br><span class="line">    q.push(make_pair(dis[s], s));<span class="comment">//7.</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.top();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;<span class="comment">//8.</span></span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[x].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=G[x][i].second, w=G[x][i].first;<span class="comment">//9.</span></span><br><span class="line">            <span class="keyword">if</span>(dis[x]+w&lt;dis[y])<span class="comment">//10.</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x]+w;</span><br><span class="line">                q.push(make_pair(dis[y], y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>存放pair的vector用来存放边和边权，因为pair比较大小是first优先，所以pair的first放的是权重。G[i] [j]存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边。G[i] [j].second存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的另一个端点。G[i] [j].first存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的权重。maxn为自己定义的常量。</li><li>将边添加至vector中，s、w、t 说明同上。</li><li>无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。</li><li>初始化vector，清空所有先前加入的边。</li><li>初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。</li><li>定义优先队列，第一个参数为数据类型，比较pair类型，pair的first优先。第二个参数为存储容器，和先前存边的vector定义相同。第三个参数表示小顶堆(greater为小顶堆，less为大顶堆)。</li><li>将源点压入队列。</li><li>x存放当前未访问过的权值最小边的一端结点编号。</li><li>依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重</li><li>该步骤通邻接矩阵dijkstra相似</li></ol><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p>hdoj1874</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://blog.csdn.net/sinat_30062549/article/details/47025277" target="_blank" rel="noopener">dijkstra几大模板（这里面的优先队列模板好像时错的，我只参考了他的stl用法）</a></li><li><a href="https://blog.csdn.net/u013569304/article/details/51147000" target="_blank" rel="noopener">C++ pair的比较大小</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–Dijkstra&quot;&gt;&lt;a href=&quot;#最短路–Dijkstra&quot; class=&quot;headerlink&quot; title=&quot;最短路–Dijkstra&quot;&gt;&lt;/a&gt;最短路–Dijkstra&lt;/h1&gt;&lt;p&gt;Dijkstra是单源最短路算法，用于求&lt;strong&gt;正权
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/07/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/07/22/并查集/</id>
    <published>2019-07-22T02:33:37.000Z</published>
    <updated>2019-08-11T09:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种树型数据结构，用于<strong>查找</strong>不相交的<strong>子集</strong>，并将他们<strong>合并</strong>在一起，简称并查集。并查集分为<strong>拆分</strong>、<strong>查找</strong>和<strong>合并</strong>三个操作。</p><h2 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li>pre数组记录所有结点的前驱结点，根节点的前驱结点是它自己</li><li>find函数先找到x的根节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];<span class="comment">//1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//2.</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )<span class="comment">//3.</span></span><br><span class="line">          r=pre[r];</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>记录前驱结点</li><li>查找根节点</li><li>找到根节点 r</li></ol><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ol><li><p>join函数先找到两个变量的根节点</p><ul><li><p>​    如果他们相同则说明两个变量在同一个集合中</p></li><li><p>​    如果不同则将其中一个根节点设置为另外一个根节点的前驱</p></li></ul></li></ol><p><img src="/2019/07/22/并查集/TIM截图20190722191109.png" alt="TIM截图20190722191109"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//1.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        pre[fx ]=fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>判断x y是否连通，如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起。</li></ol><h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>路径压缩是在寻找根结点的过程中，将子集中所有的点的前驱设置为根结点。</p><p>为什么要进行路径压缩呢？因为在并查集合并过程中，他有可能变成一个<strong>单链表</strong>，这样每次寻找根结点要遍历子集中所有的结点。进行路径压缩之后，每次寻找根结点只需访问他的父结点就可找到根结点。</p><p><img src="/2019/07/22/并查集/TIM截图20190722182225.png" alt="TIM截图20190722182225"></p><p>优化后的<strong><u>find</u></strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                            </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                   </span><br><span class="line">          r=pre[r];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )<span class="comment">//1.</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ];<span class="comment">//2.</span></span><br><span class="line">         pre[ i ]= r ;<span class="comment">//3.</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>路径压缩</li><li>在改变上级之前用临时变量j记录下他的值</li><li>把上级改为根节点</li></ol><h3 id="按秩-Rank-合并"><a href="#按秩-Rank-合并" class="headerlink" title="按秩(Rank)合并"></a>按秩(Rank)合并</h3><p>按秩合并就是在合并过程中将元素所在深度小的集合合并到元素所在深度大的集合</p><p>为什么要按秩合并呢？因为如果将元素深度大的集合合并到小的集合，那么合并后的集合深度则等于较大的深度加一。如果将深度小的集合合并到深度大的集合，则合并后的集合深度不变。</p><p><img src="/2019/07/22/并查集/TIM截图20190722182240.png" alt="TIM截图20190722182240"></p><p>优化后的<strong><u>join</u></strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(rank[fx]&gt;rank[fy])<span class="comment">//1.</span></span><br><span class="line">        pre[fy] = pre[fx];<span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre[fx] = fy;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx]==rank[fy])<span class="comment">//3.</span></span><br><span class="line">            rank[fy]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>rank数组为当前结点秩的值</li><li>只需要比较根结点的rank值就够了</li><li>修改时也只用修改根结点的rank值</li></ol><h2 id="并查集的精简实现"><a href="#并查集的精简实现" class="headerlink" title="并查集的精简实现"></a>并查集的精简实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) pre[i]=i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> pre[x]=x?x:pre[x]=get(pre[x]); &#125;<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; pre[get(x)] = get[y]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//2.</span></span><br><span class="line">    pre[rank[find(x)&gt;rank[find(y)?find(y):find(x)] = pre[rank[find(x)&gt;rank[find(y)?find(x):find(y)];</span><br><span class="line"><span class="keyword">if</span>(rank[find(x)]==rank[find(y)]) rank[find(y)]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>根结点的pre为0。</li><li>带秩合并，还没验证，不能确定对错。</li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="noopener">维基百科：并查集</a></li><li><a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">并查集详解——图文解说，简单易懂（转）</a></li><li><a href="https://www.acwing.com/blog/content/97/" target="_blank" rel="noopener">并查集笔记&amp;模板</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;并查集是一种树型数据结构，用于&lt;strong&gt;查找&lt;/strong&gt;不相交的&lt;strong&gt;子集&lt;/strong&gt;，并将他们&lt;str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>可以评论了！！！</title>
    <link href="http://yoursite.com/2018/11/02/%E5%8F%AF%E4%BB%A5%E8%AF%84%E8%AE%BA%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2018/11/02/可以评论了！！！/</id>
    <published>2018-11-01T16:35:39.000Z</published>
    <updated>2018-11-01T16:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来吐槽吧"><a href="#来吐槽吧" class="headerlink" title="来吐槽吧"></a>来吐槽吧</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;来吐槽吧&quot;&gt;&lt;a href=&quot;#来吐槽吧&quot; class=&quot;headerlink&quot; title=&quot;来吐槽吧&quot;&gt;&lt;/a&gt;来吐槽吧&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello Word!</title>
    <link href="http://yoursite.com/2018/11/01/Hello-Word/"/>
    <id>http://yoursite.com/2018/11/01/Hello-Word/</id>
    <published>2018-10-31T17:17:19.000Z</published>
    <updated>2018-10-31T17:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HELLO-WORD"><a href="#HELLO-WORD" class="headerlink" title="HELLO WORD!!!"></a>HELLO WORD!!!</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HELLO-WORD&quot;&gt;&lt;a href=&quot;#HELLO-WORD&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORD!!!&quot;&gt;&lt;/a&gt;HELLO WORD!!!&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
