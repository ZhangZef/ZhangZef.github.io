<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhangzef</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-17T14:00:03.461Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张泽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#杂记</title>
    <link href="http://yoursite.com/2019/10/16/C%20Sharp%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/10/16/C Sharp杂记/</id>
    <published>2019-10-16T15:47:08.000Z</published>
    <updated>2019-10-17T14:00:03.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Sharp杂记"><a href="#C-Sharp杂记" class="headerlink" title="C Sharp杂记"></a>C Sharp杂记</h1><p>写一些在学C#时不会的一些用法，在百度上搜出来的答案要不没正确的，要不是就是瞎xx说，要不就是说的不清不楚的。</p><h2 id="Wpf"><a href="#Wpf" class="headerlink" title="Wpf"></a>Wpf</h2><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><h4 id="label标签的内容居中显示"><a href="#label标签的内容居中显示" class="headerlink" title="label标签的内容居中显示"></a>label标签的内容居中显示</h4><p>注意，是内容、内容、内容。。。如图：<img src="/2019/10/16/C Sharp杂记/TIM截图20191016235316.png" alt="TIM截图20191016235316" style="zoom:33%;"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Label Name=&quot;alb&quot; Content=&quot;20&quot; FontSize=&quot;60&quot; Margin=&quot;10,10,-2.333,-12.333&quot; Height=&quot;163&quot; HorizontalContentAlignment=&quot;Center&quot; VerticalContentAlignment=&quot;Center&quot;/&gt;</span><br></pre></td></tr></table></figure><p>是HorizontalContentAlignment和VerticalContentAlignment两个属性，一个是水平居中，一个是垂直居中，也可以设置其他对齐方式。</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="保留n位小数"><a href="#保留n位小数" class="headerlink" title="保留n位小数"></a>保留n位小数</h3><p>这里以两位小数为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double x;</span><br><span class="line">x.ToString(&quot;0.00&quot;);</span><br></pre></td></tr></table></figure><p>如代码所示，想保留几位就在小数点后面放几个0。</p><p>或者这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double a = 10.9876544;</span><br><span class="line">int b;</span><br><span class="line">b = Convert.ToInt32(a * 100);</span><br><span class="line">a = Convert.ToDouble(b);</span><br><span class="line">a /= 100;</span><br></pre></td></tr></table></figure><p>就是先将a乘100后转化乘整型，这样它的小数部分就丢弃了，之后再转化成double，再除以100。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-Sharp杂记&quot;&gt;&lt;a href=&quot;#C-Sharp杂记&quot; class=&quot;headerlink&quot; title=&quot;C Sharp杂记&quot;&gt;&lt;/a&gt;C Sharp杂记&lt;/h1&gt;&lt;p&gt;写一些在学C#时不会的一些用法，在百度上搜出来的答案要不没正确的，要不是就是瞎xx说
      
    
    </summary>
    
      <category term="C#" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C#方法" scheme="http://yoursite.com/tags/C-%E6%96%B9%E6%B3%95/"/>
    
      <category term="Wpf" scheme="http://yoursite.com/tags/Wpf/"/>
    
  </entry>
  
  <entry>
    <title>Git教程</title>
    <link href="http://yoursite.com/2019/10/15/Git%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/15/Git教程/</id>
    <published>2019-10-15T14:53:37.000Z</published>
    <updated>2019-10-26T09:19:37.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git教程"><a href="#Git教程" class="headerlink" title="Git教程"></a>Git教程</h1><blockquote><p>  本教程参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的Git教程</a></p></blockquote><p>Git是一个分布式版本控制系统</p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>安装过程请自行百度👀</p><p>安装之后要在命令行中设置自己的用户名和邮箱，需要在命令行中输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h2 id="版本库-repository"><a href="#版本库-repository" class="headerlink" title="版本库(repository)"></a>版本库(repository)</h2><p>版本库：你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>创建版本库很简单，即用git打开一个空文件夹，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init//初始化一个仓库</span><br></pre></td></tr></table></figure><p>要想将文件添加到仓库中，需要分两步</p><p>第一步先把文件放到仓库目录或子目录中，然后输入如下命令(例如文件名为：readme.txt)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt//将readme.txt文件添加到仓库中</span><br></pre></td></tr></table></figure><p>第二步需要用git commit提交到仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;wrote a readme file&quot;//将修改提交到仓库并说明</span><br></pre></td></tr></table></figure><p>其中- m “xxx”是对本次提交的说明，等同于注释，有助于别人对你提交的理解。</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>查看当前仓库的状态(例如什么文件被修改了)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>若想查看哪个文件具体修改了什么，可以用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff readme.txt//查看readme.txt文件具体修改了什么内容</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>版本退回有如下几个命令用于查看历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log//1.</span><br><span class="line">git log --pretty=oneline//2.</span><br><span class="line">git reflog//3.</span><br></pre></td></tr></table></figure><ol><li>查看详细历史提交记录(包括commit_id、作者、日期、提交注释)，确定要退回哪个版本，每个版本都有一个commit_id</li><li>可以让每个版本只输出一行，简化输出信息(只显示commit_id和提交注释)</li><li>查看历史命令</li></ol><p>版本退回命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^//1.</span><br></pre></td></tr></table></figure><ol><li>退回到当前版本的上一个版本，如果想退回上上一个版本就是… HEAD^^，前一百个版本可以用HEAD~100表示。–hard参数暂不讲解。这里的HEAD^也可以替换为想要退回版本的commit_id，由于commit_id很长，只用写前几位能区别于别的版本就行。</li></ol><blockquote><p>  例：</p><p>  ​       1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</p><p>  ​       e475afc93c209a690c39c13a46716e8fa000c366 add distributed</p><p>  ​       eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</p><p>  这是我当前有的版本，我想回到add distributed版本，我可以再commit_id处填写”HEAD^”或者”e4751fc”</p></blockquote><p>带有(HEAD -&gt; master)的即为当前版本</p><p>当退回某一个版本之后再用git log就不能看到原来版本的commit_id了，此时可以用git reflog来查看历史命令，找到commit_id</p><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>工作区就是我们创建的仓库文件夹。工作区有一个隐藏文件夹是.git，这里是版本库。版本库里面有一个<strong>stage</strong>（或index）叫暂存区，还有一个git自动创建的<strong>master</strong>分支，以及指向master分支的指针<strong>HEAD</strong> 。</p><p>当我们git add时是把文件提交到stage中，git commit时是把stage中的所有修改一次性提交到分支中</p><p><img src="/2019/10/15/Git教程/1571154124471.png" alt="1571154124471" style="zoom:67%;"></p><p>当你commit过之后，没有对工作区的文件进行修改，那么版本库就变成这样：</p><p><img src="/2019/10/15/Git教程/1571154156433.png" alt="1571154156433" style="zoom:67%;"></p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>Git管理的是修改而非文件</p><p>当你对文件readme.txt进行如下操作时：第一次修改readme.txt-&gt;git add-&gt;第二次修改readme.txt-&gt;git commit。会发现master中的readme.txt文件是第一次修改过的而非第二此修改过的。</p><p>如果想让master中的readme.txt文件是第二次修改的：第一次修改readme.txt-&gt;git add(有没有都行)-&gt;第二次修改readme.txt-&gt;git add-&gt;git commit</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>例如撤销对readme.txt文件的修改：</p><h4 id="当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时"><a href="#当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时" class="headerlink" title="当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时"></a>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt//1.</span><br></pre></td></tr></table></figure><ol><li>把readme.txt文件在工作区的修改全部撤销</li></ol><h4 id="当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改"><a href="#当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改" class="headerlink" title="当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改"></a>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改</h4><p>在commit之前可以先用git status查看哪个文件被修改了，撤销可用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><h4 id="已经提交了不合适的修改到版本库时，想要撤销本次提交"><a href="#已经提交了不合适的修改到版本库时，想要撤销本次提交" class="headerlink" title="已经提交了不合适的修改到版本库时，想要撤销本次提交"></a>已经提交了不合适的修改到版本库时，想要撤销本次提交</h4><p>直接使用版本退回就好了呀</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>例如删除工作区中的readme.txt文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt//删除</span><br><span class="line">git commit//提交</span><br></pre></td></tr></table></figure><p>在提交之前如果发现删错了可以用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>git是分布式版本控制，同一个git仓库可以分布到不同的机器上面。而拿一个机器来当作服务器，全天24小时开机，其他人久都可以从这台服务器上把仓库克隆到自己的电脑上了，并且可以把各自的提交推送到服务器仓库中，也可以从服务器仓库拉取别人的提交。</p><p>现在我们不需要自己搭建服务器了，我们可以使用GitHub或者码云，但是在国内GitHub速度比较慢。。。下面先以GitHub为例讲解远程仓库。（码云的用法会在后面说到）</p><ol><li><p>创建SSH Key：在用户主目录下看看有没有（<strong>.ssh</strong>）目录，如果有再看看这个目录下有没有（<strong>id_rsa</strong>）和（<strong>id_rsa.pub</strong>）这两个文件，如果都有则可以直接跳到下一步。如果没有，则在用户主目录下用git bash here（Windows）或者用shell（Linux）打开，输入如下命令创建SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>这里要把邮箱换成自己的邮箱，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到（.<strong>ssh</strong>）目录，里面有（<strong>id_rsa</strong>）和（<strong>id_rsa.pub</strong>）两个文件，这两个就是SSH Key的秘钥对，（<strong>id_rsa</strong>）是私钥，不能泄露出去，（<strong>id_rsa.pub</strong>）是公钥，可以放心地告诉任何人。</p></li><li><p>​    登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴（<strong>id_rsa.pub</strong>）文件的内容，然后就可以在SSH keys界面看到你添加的密钥。<img src="/2019/10/15/Git教程/TIM图片20191023233056.png" alt="TIM图片20191023233056" style="zoom: 25%;"></p></li></ol><p>SSH Key用于绑定将你的电脑和GitHub绑定，GitHub是开源仓库，你在上面提交的代码可以被别人看到。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>先在GitHub创建一个仓库：</p><p><img src="/2019/10/15/Git教程/1571903139993.png" alt="1571903139993" style="zoom: 25%;"></p><p>（这是仓库创建好的样子）我创建了一个名叫test的仓库，刚刚创建的仓库是空的。现在GitHub告诉我们可以从这个仓库克隆出新的仓库，也可以把一个已有的仓库与之关联，然后把本地仓库的内容推送到GitHub仓库。</p><p>我这里是在本地也新建了一个叫test的仓库，并且在仓库根目录创建了一个（<strong>README.md</strong>）的文件。之后根据前面讲过的命令，或者GitHub上面提示的命令将本地test仓库与GitHub上的远程仓库相关联，需要在新建的空文件夹下<strong>依次</strong>运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;wrote a readme file&quot;//1.</span><br><span class="line">git remote add origin https://github.com/ZhangZef/test.git//2.</span><br><span class="line">git push -u origin master//3.</span><br></pre></td></tr></table></figure><ol><li>这里双引号里面为提交注解，前面讲过</li><li>这里要把网址换成自己的GitHub仓库地址，提示页面中给出了。origin就是远程仓库的名字，在git中默认这样叫，也可以改成别的，不过不推荐，修改不利于以后和别人合作或者自己忘了。</li><li>git push是把当前分支master推送到远程仓库。由于远程库是空的，我们第一次推送时加上<strong>-u</strong>参数，git不但会把本地的master分支内容推送到远程新的master分支，还会把本地master分支和远程master分支关联起来，在以后的推送和拉取时可以简化命令。</li><li>如果已有本地仓库可直接执行后两个命令。</li></ol><p>这是推送成功后的样子：</p><p><img src="/2019/10/15/Git教程/1571907461557.png" alt="1571907461557" style="zoom: 25%;"></p><p>以后只要本地提交过，直接运行：（<strong>git push origin master</strong>）命令就可以提交</p><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p>将远程仓库克隆到本地可以用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:ZhangZef/test.git</span><br></pre></td></tr></table></figure><p>注意要把仓库地址换成自己的地址</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建并合并分支"><a href="#创建并合并分支" class="headerlink" title="创建并合并分支"></a>创建并合并分支</h3><p>在git中，master是主分支。master是指向提交的分支，而HEAD是指向当前分支的指针。</p><p>一开始，master分支是一条线，git用master指向最新提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点，每次提交，master就向前移动一步。</p><p><img src="/2019/10/15/Git教程/0.png" alt="0"></p><p>当我们新建了一个分支dev（自己命名）的时候，git就会新建一个叫dev的指针，指向master相同的提交。再把HEAD指向dev就表示当前分支在dev：</p><p><img src="/2019/10/15/Git教程/0-1571917859671.png" alt="0" style="zoom:67%;"></p><p>从现在开始，你对工作区的修改和提交就是针对dev分支的了，每提交一次，dev分支就向前挪一步：</p><p><img src="/2019/10/15/Git教程/1.png" alt="1" style="zoom:67%;"></p><p>我们要想把dev合并到主分支master上，就是把master指针指向dev的位置就可以了：</p><p><img src="/2019/10/15/Git教程/0-1571918122818.png" alt="0" style="zoom:67%;"></p><p>这时候我们可以把dev分支给删去，他不会修改工作区的任何内容，只会将dev指针删掉：</p><p><img src="/2019/10/15/Git教程/2.png" alt="2" style="zoom:67%;"></p><p>下面来实际进行上述操作，创建并切换分支用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev//1.</span><br><span class="line">git branch dev//2.</span><br><span class="line">git checkout dev//3.</span><br><span class="line">git branch//4.</span><br></pre></td></tr></table></figure><ol><li>git checkout命令加上-b参数表示创建并切换，dev处可换成你起的分支名</li><li>git branch + name表示创建分支</li><li>切换到分支</li><li>查看当前分支，名字前面带*号的表示当前HEAD指向的分支</li></ol><p>我们创建一个新分支dev，并转向dev分支，并在dev分支中做修改然后提交：</p><p><img src="/2019/10/15/Git教程/TIM截图20191024201504.png" alt="TIM截图20191024201504" style="zoom: 50%;"></p><p>之后我们将dev的改变合并到master分支上，先将转向master分支，之后用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/Git教程/TIM截图20191024201742.png" alt="TIM截图20191024201742" style="zoom:50%;"></p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>之后我们就可以将dev删除了，之后运行branch命令就看到只有master分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/Git教程/TIM截图20191024202014.png" alt="TIM截图20191024202014" style="zoom:50%;"></p><p>还有switch命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch -c dev//1.</span><br><span class="line">git switch master//2.</span><br></pre></td></tr></table></figure><ol><li>这个也是创先并转向新分支</li><li>这个是转向分支，和checkout用法类似</li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git branch//1.</span><br><span class="line">git branch &lt;name&gt;//2.</span><br><span class="line">git checkout &lt;name&gt;//3.</span><br><span class="line">git switch &lt;name&gt;//4.</span><br><span class="line">git checkout -b &lt;name&gt;//5.</span><br><span class="line">git switch -c &lt;name&gt;//6.</span><br><span class="line">git merge &lt;name&gt;//7.</span><br><span class="line">git branch -d &lt;name&gt;//8.</span><br></pre></td></tr></table></figure><ol><li>查看分支</li><li>创建分支</li><li>转向分支</li><li>转向分支</li><li>创建并转向分支</li><li>创建并转向分支</li><li>合并分支</li><li>删除分支</li></ol><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当新建的分支和原来的分支同时向前推进，导致生成了分叉，这时候就发生了冲突，这节要来解决冲突。</p><p>我们先新建一个分支dev，并在dev分支修改文件并提交，这样dev分支就比master分支超前了一个提交：</p><p><img src="/2019/10/15/Git教程/TIM截图20191025103056.png" alt="TIM截图20191025103056" style="zoom:50%;"></p><p>之后我们再切换回master分支，系统就提示我们当前分支比master分支超前了一个分支（这里他显示的超前两次，是因为我的master分支修改过之后没有对远程仓库提交，它显示的‘origin/master’意思是远程仓库的master分支）：</p><p><img src="/2019/10/15/Git教程/TIM截图20191025103326.png" alt="TIM截图20191025103326" style="zoom:50%;"></p><p>之后我们再在master修改一次并提交：</p><p><img src="/2019/10/15/Git教程/TIM截图20191025103617.png" alt="TIM截图20191025103617" style="zoom:50%;"></p><p>会发现合并的时候git会提示我们发生冲突（conflict），这时分支的状态是这样的：</p><p><img src="/2019/10/15/Git教程/123.png" alt="123" style="zoom:50%;"></p><p>我们可以用（<strong>git status</strong>）来查看哪些文件发生了冲突：</p><p><img src="/2019/10/15/Git教程/TIM截图20191025103907.png" alt="TIM截图20191025103907" style="zoom:50%;"></p><p>这时git提示我们README.md文件发生了冲突，要我们手动解决冲突，之后我们打开README.md文件查看：</p><p><img src="/2019/10/15/Git教程/TIM截图20191025104405.png" alt="TIM截图20191025104405" style="zoom: 25%;"></p><p>会发现两个分支中的提交分别在文件中提示出来，我们手动修改后再提交即可：</p><p><img src="/2019/10/15/Git教程/TIM截图20191025104558.png" alt="TIM截图20191025104558" style="zoom:50%;"></p><p>这是修改过的文件，我们将修改过的文件提交后可以用如下命令查看分支合并状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/Git教程/TIM截图20191025105148.png" alt="TIM截图20191025105148" style="zoom:50%;"></p><p>可以看到我们的分支已经合并完成，这时可以将dev分支删除。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>git无法自动合并冲突分支，合并后必须手动解决冲突，再提交，用如下命令可以查看分支合并图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>在一般情况，合并分支时git会使用<strong>Fast forward</strong>模式进行合并。在这种模式下删除分支后会丢掉分支信息。</p><h4 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast forward"></a>fast forward</h4><p>那么什么是fast forward模式呢？假设现在有两个分支，一个是主分支master，另一个是dev分支。</p><blockquote><p>  当我们在dev分支做了一个提交为“new 444444”：<img src="/2019/10/15/Git教程/TIM截图20191025175943.png" alt="TIM截图20191025175943" style="zoom: 33%;">当HEAD指向dev时我们可以看到“new 444444”这次提交，当我们将HEAD指向master时则看不到这个“new 444444”提交：<img src="/2019/10/15/Git教程/TIM截图20191025180219.png" alt="TIM截图20191025180219" style="zoom:33%;"></p><p>  这次我们使用fast forward模式进行合并，合并之后的分支图如图所示：<img src="/2019/10/15/Git教程/TIM截图20191025180416.png" alt="TIM截图20191025180416" style="zoom:33%;">可以看出git将“new 444444”这次提交和master分支强行糅合到了一块儿。</p></blockquote><blockquote><p>  接下来我们来看关闭 fast forward模式的合并是什么样子的，这次我先删除了dev分支，又创建了新的dev分支，以避免和前面的混淆，其他操作类似，这次在dev的提交换成了“new 666666”：<img src="/2019/10/15/Git教程/TIM截图20191025181057.png" alt="TIM截图20191025181057" style="zoom:33%;"></p><p>  可看出这次合并之后git并没有将“new 666666”这次提交和master分支强行糅合在一起。</p></blockquote><p>可用两张图总结一下，第一张为fast forward合并，第二张为非fast forward合并：</p><p><img src="/2019/10/15/Git教程/TIM截图20191025181609.png" alt="TIM截图20191025181609" style="zoom: 50%;"></p><p><img src="/2019/10/15/Git教程/TIM截图20191025181621-1571998714315.png" alt="TIM截图20191025181621" style="zoom:50%;"></p><p>看到廖雪峰老师对fast forward这里讲解的不是很清楚，我对这里也有点迷，就动手实践了一下，唠叨唠叨。关闭fast forward可以避免丢失信息，对以后的代码分析很有用（看网上说的👀），不过fast forward模式确实将一部分信息给抹去了，比如上面第一个图，我们就看不出曾经有过dev的痕迹，而第二张图则可以看出原来有某个分支提交了这个功能。</p><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="/2019/10/15/Git教程/23456.png" alt="23456" style="zoom: 67%;"></p><p>如图michael在他自己的分支上工作，bob在他自己的分支上工作，他们每次完成工作都把自己的分支合并到dev分支，当dev分支上的项目稳定下来，则将dev合并到master上。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>当你正在dev分支中做某项工作时，突然通知让你去修复master分支中的一个非常紧急bug-001，但是你手头的工作一时半会儿也做不完。这时候要先保护工作现场，就像调用函数时，系统会先保护工作现场，将各寄存器中的值压入栈中，再去调用别的函数。</p><p>git也提供了一个保护工作现场的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>可以将当前未提交的修改先存起来，以便bug修复完成后恢复现场。恢复现场的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git stash list//1.</span><br><span class="line">git stash apply//2.</span><br><span class="line">git stash pop//3.</span><br></pre></td></tr></table></figure><ol><li>这个命令用于查看当前有哪些被保存起来的工作现场，这个list其实是一个栈结构，即后进先出。</li><li>第二条和第三条命令都是恢复工作现场，但是apply不会删除list中的记录，想要删除还要用（<strong>git stash drop</strong>），而pop是应用并删除。</li></ol><p>master分支中存在bug，那么说明dev分支中一定也存在bug。那么怎么方便快捷地修复dev上的bug呢？</p><p>要先再master分支中查看那个bug分支的commit_id（例如是aadbd3d……，取前几位就行），然后转到转到dev分支使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick aadbd3e</span><br></pre></td></tr></table></figure><p>这样就可以将那次bug修复直接合并到dev分支中，不过还需要手动解决冲突并提交。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>当新开发功能时，肯定不能从master分支中修改。这时候要从dev分支新建一个feature分支来开发新功能，但是当你开发完新功能提交过还<strong>未合并</strong>时又被要求取消这个功能，这时候用（<strong>git branch -d + 分支名</strong>）是删除不了的，因为分支还未合并。git会提示你要用（<strong>-D</strong>）来删除（例如分支名为feature）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D feature</span><br></pre></td></tr></table></figure><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。查看远程仓库的信息（第一个是查看信息，第二个是查看详细信息，remote中文翻译是偏僻的、偏远的😁）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/Git教程/TIM截图20191026002026.png" alt="TIM截图20191026002026" style="zoom: 50%;"></p><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上（比如说要推送master分支，origin是远程仓库的意思）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><strong>master</strong>分支是主分支，因此要时刻与远程同步；</li><li><strong>dev</strong>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>想要抓取分支，先要获取你的工程在GitHub上的地址，先在GitHub中打开你的工程，之后（这个按钮是将地址信息复制到粘贴板）：</p><p><img src="/2019/10/15/Git教程/TIM截图20191026003033.png" alt="TIM截图20191026003033" style="zoom:33%;"></p><p>之后使用（<strong>git clone</strong>）命令，例如上图中的工程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:ZhangZef/test.git</span><br></pre></td></tr></table></figure><p>但是在GitHub上我的工程有两个分支，一个是master分支，一个是dev分支，当你clone之后使用（<strong>git branch</strong>）命令时会发现只有一个master分支，这时候想将dev分支也抓取下来要用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>后面带上（<strong>origin/dev</strong>）意思是将本地仓的dev分支和远程仓库的dev分支相关联，以后推送拉取的时候git会自动寻找远程仓库和当前推送拉取分支相关联的分支，如果远程仓库没有关联分支：</p><ul><li>拉取时则会<strong>拉取失败</strong></li><li>而推送时没有<strong>关联分支</strong>且无<strong>同名分支</strong>则会自动在远程仓库<strong>创建新分支</strong>，但是创建的新分支并<strong>不会</strong>和本地仓库的分支相<strong>关联</strong>，还要手动将远程仓库的分支和本地分支相关联</li><li>而推送时没有<strong>关联分支</strong>且有<strong>同名分支</strong>则不会发生任何事，没有推送上去，也没有创建新分支</li></ul><p>要想关联远程仓库和本地仓库的分支可用如下命令（例如要关联分支是dev）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure><p>当然你也可以指定将本地dev和远程仓库的其他分支相关联，修改origin后面的分支名字即可，但是并<strong>不推荐</strong></p><h4 id="解决推送冲突"><a href="#解决推送冲突" class="headerlink" title="解决推送冲突"></a>解决推送冲突</h4><p>当你的小伙伴向远程仓库的dev推送分支推送之后，你再向远程仓库推送时git会提示你产生冲突，并且提示你要用（<strong>git pull</strong>）命令：</p><p><img src="/2019/10/15/Git教程/TIM截图20191026005345.png" alt="TIM截图20191026005345" style="zoom:50%;"></p><p>此时就使用（<strong>git pull</strong>）将远程仓库的分支抓取下来，手动解决冲突再合并（拉取失败时记得关联远程仓库的分支和本地仓库分支）。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>当解决冲突时，后push的人要先pull，再add…commit…push，这样分支图就会变得很杂乱。利用git的<strong>rebase</strong>（变基）操作可以将解决冲突时的分支图整理成一条直线。（不太理解rebase的操作，回来再写吧，先跳过去）</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>标签用于标记某个commit，方便使用。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt;//1.</span><br><span class="line">git tag &lt;name&gt; &lt;commit_id&gt;//2.</span><br><span class="line">git tag//3.</span><br><span class="line">git show &lt;tagname&gt;//4.</span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;......&quot;//5.</span><br></pre></td></tr></table></figure><ol><li>创建一个标签，默认指向当前HEAD指向的提交</li><li>指定某一个commit创建标签，用于指定以前的提交未添加标签</li><li>查看所有标签</li><li>显示某个标签（标签指向的commit）的信息</li><li>可以指定某个标签的注解</li></ol><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;//1.</span><br><span class="line">git push origin &lt;tagname&gt;//2.</span><br><span class="line">git push origin --tags//3.</span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;//4.</span><br></pre></td></tr></table></figure><ol><li>删除本地的某个标签</li><li>将某个标签推送到远程仓库</li><li>一次性推送全部尚未推送到远程的本地标签</li><li>删除远程标签，要先删除本地的标签，再使用这个命令删除远程的标签</li></ol><h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><p>想要修改别人的文件，就要先fork到自己的仓库，然后才能进行修改提交。当你想要别人能接受你的提交，你就可以在GitHub上发起一个pull request，之后要看别人接受不接受了。</p><h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><p>由于GitHub是国外的网站，国内用户访问时速度有时候令人抓狂。这时候你可以使用国内的git托管服务<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a></p><p>不过码云的免费git仓库有<strong>5人</strong>的成员上限。</p><p>添加SSH Key的步骤就略过了。</p><p>在码云上的git操作和GitHub类似，就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git教程&quot;&gt;&lt;a href=&quot;#Git教程&quot; class=&quot;headerlink&quot; title=&quot;Git教程&quot;&gt;&lt;/a&gt;Git教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  本教程参考&lt;a href=&quot;https://www.liaoxuefeng.com/w
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="码云" scheme="http://yoursite.com/tags/%E7%A0%81%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>《现代操作系统（第四版）》 课后习题答案--第一章</title>
    <link href="http://yoursite.com/2019/10/07/%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://yoursite.com/2019/10/07/《现代操作系统（第四版）》-课后习题答案-第一章/</id>
    <published>2019-10-07T09:26:30.000Z</published>
    <updated>2019-10-14T12:56:56.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《现代操作系统（第四版）》-课后习题答案–第一章"><a href="#《现代操作系统（第四版）》-课后习题答案–第一章" class="headerlink" title="《现代操作系统（第四版）》 课后习题答案–第一章"></a>《现代操作系统（第四版）》 课后习题答案–第一章</h1><p>自己写的，可能会有错误，望大家指正。</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote><p>  操作系统的两大主要作用是什么？（Page. 1）</p></blockquote><p>解：</p><ol><li>为用户程序提供一个更好、更简单、更清晰的计算机模型。</li><li>管理cpu、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口等设备。</li></ol><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><blockquote><p>  在1.4节中描述了9中不同类型的操作系统，列举每种操作系统的应用（每种系统一种应用）。（Page. 20）</p></blockquote><p>解：</p><ol><li>大型机操作系统（Mainframe Operating Systems）：<ul><li>批处理系统应用于保险公司的索赔处理或连锁商店的索赔报告</li><li>事务处理系统应用于银行支票处理或航班预定</li><li>分时系统应用于大型数据库的查询</li></ul></li><li>服务器操作系统（Server Operating Systems）：<ul><li>应用于Web站点保存页面并处理进来的请求</li></ul></li><li>多处理器操作系统（Multiprocessor Operating Systems）：<ul><li>Windows和Linux都可以运行在多核处理器上，可谓计算机带来更高的性能</li></ul></li><li>个人计算机操作系统（Personal Computer Operating Systems）：<ul><li>应用于文字处理、电子表格、游戏和Internet访问</li></ul></li><li>掌上计算机操作系统（Handheld Computer Operating Systems）：<ul><li>手机的操作系统如Android和ios</li></ul></li><li>嵌入式操作系统（Embedded Operating Systems）：<ul><li>应用于微波炉、冰箱、电视机、智能家居、汽车等</li></ul></li><li>传感器节点操作系统（Sensor-Node Operating Systems）：<ul><li>应用于建筑物周边保护、国土边界保卫、森林火灾探测、气象预测等</li></ul></li><li>实时操作系统（Real-Time Operating Systems）：<ul><li>硬实时系统应用于工业过程控制、民用航空、军事等</li><li>软实时系统应用于数字音频或多媒体系统等</li></ul></li><li>智能卡操作系统（Smart Card Operating Systems）：<ul><li>应用于电子支付等</li></ul></li></ol><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><blockquote><p>  分时操作系统和多道程序系统的区别是什么？（Page. 6）</p></blockquote><p>解：</p><ul><li>分时操作系统：按一定时间间隔将计算机的轮流分配给程序使用，由于间隔非常短，所以就像每个程序独占一样。</li><li>多道程序系统：将内存分为几部分存放不同的程序，一个程序不能让cpu和I/O设备始终忙碌，当cpu的正在执行的作业需要等待某个动作完成才能继续进行（如I/O操作完成），如果是单道程序设计此时cpu会等待，而多道程序设计则会让cpu开始处理另一个作业，提高了cpu的利用率。</li><li>区别：分时操作系统是按一定时间间隔将计算资源分配给不同的程序，而多道程序系统则是在当前作业进行其他动作时才回去处理别的作业。</li></ul><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><blockquote><p>  为了使用高速缓存，主存被划分为若干cache行，通常每行长32或64字节。每次缓存一整个cache行。每次缓存一整行而不是一个字节或一个字，这样做的优点是什么？</p></blockquote><p>解：</p><p>因为程序局部性原理，即当要访问某一个字或字节，则其后面的数据被访问的概率很大，这样就可以提高缓存命中的概率。</p><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><blockquote><p>  在早期计算机中，每个字节的读写直接由CPU处理（即没有DMA）。对于多道程序而言这种组织方式有什么含义？</p></blockquote><p>解：</p><p>DMA（Direct Memory Access）直接存储器访问：当cpu要进行I/O操作时只需要对DMA控制器进行设置，之后DMA控制器会完成cpu给定的工作，而cpu可在此时空闲下来去处理别的事情。</p><p>如果每个字节的读写是由cpu读写，则在I/O操作时cpu就不能处理其他程序作业，此时cpu将被I/O操作占用，无法空闲下来，由于I/O操作远慢于cpu的处理速度，cpu运行效率会大幅度下降。若有DMA控制器则在较慢的I/O操作时cpu可以空闲下来去运行别的作业，会使进行I/O操作时cpu效率大幅度提高，也提高了多道程序设计的收益（多道程序概念看第三题）。</p><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><blockquote><p>  与访问I/O设备相关的指令通常是特权指令，也就是说，他们能在内核态执行而在用户态则不行，说明为什么这些指令是特权指令。</p></blockquote><p>解：</p><p>特权指令：具有特殊权限的指令，只能由操作系统调用，在系统的内核态运行。</p><ol><li>操作系统的一个主要任务就是给用户提供一个良好的计算机模型，然而这一任务的一个主要准则就是弱化用户对硬件的感知，而I/O操作就是对硬件的直接操作。</li><li>进行I/O操作时操作系统往往要检查相应权限，如果I/O操作可以由用户任意调用，则会容易引发系统崩溃。</li></ol><h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><blockquote><p>  系列计算机的思想在20世界60年代由IBM引入System/360大型机。现在这种思想是消亡还是存活？</p></blockquote><p>解：</p><p>这还用问吗，看看不同版本的ipad、surface、相同系列不同配置的电脑。。。</p><h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><blockquote><p>  缓慢采用GUI的一个原因是支持他的硬件的成本高昂，为了支持25行80列的单色文本屏幕，需要多少视频RAM？对于1024x768像素24位色彩图需要多少RAM？在1980年每Kb 5美元，这些RAM成本是多少？现在成本多少？</p></blockquote><ol><li>每个文本一个字节，则25行80列最大就是25×80字节，即2000字节视频RAM</li><li>1024×768个像素，每个像素24位，一字节有8位，则总共是1024×768×24÷8，即2359296字节，2304KB。</li><li>1980年成本是11520美元，在今天按jd金士顿8g 2400的内存价格算是0.03125人民币每KB（进制为1024），则其成本是72人民币，按当前美元汇率是10.0732美元。<img src="/2019/10/07/《现代操作系统（第四版）》-课后习题答案-第一章/TIM截图20191007235417.png" alt="TIM截图20191007235417" style="zoom:50%;"> <img src="/2019/10/07/《现代操作系统（第四版）》-课后习题答案-第一章/TIM截图20191007235755.png" alt="TIM截图20191007235755" style="zoom: 25%;"></li></ol><h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><blockquote><p>  在建立一个操作系统时有几个设计目的，例如资源利用、及时性、健壮性等，请列举两个可能相互矛盾的设计目的。</p></blockquote><p>解：</p><p>考虑硬实时操作系统，其及时性和可靠性较高，但是健壮性较差，当出错时会导致后续工作无法进行。</p><h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><blockquote><p>  内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同的模式有什么帮助。</p></blockquote><p>解：</p><ul><li>内核态：可以无限制地对系统存储、外部设备进行访问，具有最高级别的权限，可以执行cpu的所有指令。</li><li>用户态：访问受限制，无法访问外部设备，无法执行特权指令。</li><li>区别：相对与用户态，内核态拥有的权力更高，而用户态访问设备都需要内核态来帮助。</li><li>对操作系统的帮助：<ul><li>可以使用户程序不需要接触底层物理设备的细节，仅由一个函数来实现一系列复杂的工作。</li><li>保护硬件信息，对用户程序进行限制，当用户程序需要进行某些硬件访问，可以向操作系统申请，操作系统会检查它的权限。</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>  这几题都是偏思维题，觉得这种题要先列举这些东西的性质，再对比总结。</p><p>  有些名词书上没有讲解，在网上的资料也比较少，可能不太准确</p></blockquote><h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><blockquote><p>  一个255GB大小的磁盘有65535个柱面，每个柱面255个扇区。每个扇区512字节。这个磁盘有多少盘片和磁头？假设平均寻道时间为11ms,平均旋转延迟为7ms,读取速度100MB/s,计算从一个扇区读取400kb需要的平均时间。</p></blockquote><p>解：</p><p><img src="/2019/10/07/《现代操作系统（第四版）》-课后习题答案-第一章/TIM截图20191008155307.png" alt="TIM截图20191008155307" style="zoom:33%;"></p><p>如图，红色为一个柱面，蓝色为扇区，即每个盘面有若干柱面，每个柱面有若干扇区，每个盘面有一个磁头，每个盘片有两个盘面，也即两个磁头。（用触摸板画的👀）</p><ul><li>由此可得每个盘面的存储容量为255×512×65535=‭8556249600‬B=‭8355712.5KB≈8160MB≈8G</li><li>所以盘面数即磁头数为255÷8≈32</li><li>所以共有16个盘片</li><li>平均时间=寻道时间+旋转延迟+读取时间：11ms+7ms+400kb÷(100MB/s×1024÷1000)≈22ms</li></ul><h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><blockquote><p>  下面哪一条指令只能在内核态使用？</p><ul><li>a 禁止所有的中断</li><li>b 读日期-时间时钟</li><li>c 设置日期-时间时钟</li><li>d 改变存储器映像</li></ul></blockquote><p>解：a、c、d</p><h2 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h2><blockquote><p>  考虑一个有两个CPU的系统，且每一个CPU有两个线程（超线程）。假设有三个程序P0、P1、P2，分别以运行时间5ms, 10ms,20ms开始，运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻赛，并且一旦设定就不改变CPU。</p></blockquote><p>不太理解他的线程要怎么算，看百度百科英特尔超线程技术是将cpu内部使用频率较高的部件复制一份，这样就可以提高使用频率较低的部件的使用效率，就可以把他看成两个逻辑线程。但是看网上答案都没有考虑两个线程同时工作的问题。</p><h2 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h2><blockquote><p>  一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns, 这台机器每秒可执行多少条指令？</p></blockquote><p>解：</p><p>1s = 1000000000ns</p><p>分成四级流水线，应该是一条指令分成四部分，即每条指令执行时间为4ns，四级流水线图示：</p><p><img src="/2019/10/07/《现代操作系统（第四版）》-课后习题答案-第一章/TIM截图20191008170610.png" alt="TIM截图20191008170610" style="zoom:33%;"></p><p>由图可推算出10亿ns可运行1000000000-3条指令</p><h2 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h2><blockquote><p>  假设一个计算机系统有高速缓存、内存(RAM)以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要1ns, RAM需要10ns, 磁盘需要10ms。如果缓存命中率是95%， 内存的是99%（缓存失效时），读取一个词的平均时间是多少？</p></blockquote><p>解：</p><p>10ms = 10000000ns</p><p>平均时间即：</p><ul><li><p>1ns×0.95(缓存命中)</p></li><li><p>+10ns×0.05×0.99(缓存未命中内存命中)</p></li><li><p>+10000000ns×0.05×0.01(缓存内存都未命中)</p></li><li><p>=5001.455ns</p></li></ul><h2 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h2><blockquote><p>  在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？</p></blockquote><p>不太懂。。。</p><h2 id="第十七题"><a href="#第十七题" class="headerlink" title="第十七题"></a>第十七题</h2><blockquote><p>  什么是陷阱指令？在操作系统中解释他的用途。</p></blockquote><p>解：</p><p>在网上看到好像和tarp指令类似的还有一个叫访管指令(还有人说两个大致相等，没搞明白两个有啥关系)，好像是因为内核态又叫管态，用户态又叫目态。</p><p>trap指令是一个非特权指令，他是从用户态进入到内核态唯一的入口，该指令允许用户程序调用特权指令。</p><h2 id="第十八题"><a href="#第十八题" class="headerlink" title="第十八题"></a>第十八题</h2><blockquote><p>  分时系统中为什么需要进程表？在只有一个进程存在的个人计算机系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？</p></blockquote><p>解：</p><p>进程表是用来管理进程，当分时系统将某些进程挂起时，他们将进入进程表，分时系统从进程表中取出另一个需要处理的进程。</p><p>当只有一个进程时不需要，因为他无需管理其他进程。</p><h2 id="第十九题"><a href="#第十九题" class="headerlink" title="第十九题"></a>第十九题</h2><blockquote><p>  说明有没有理由在一个非空的目录中安装一个文件系统。如果这样做，如何做？</p></blockquote><p>不太懂，希望有大佬能帮我解答一下。</p><h2 id="第二十题"><a href="#第二十题" class="headerlink" title="第二十题"></a>第二十题</h2><blockquote><p>  对于下列系统调用，给出引起失败的条件：fork,exec以及unlink.</p></blockquote><p>解：</p><ul><li>fork：如果在进程表中没有空闲的内存用于创建子进程，则调用失败</li><li>exec：当其参数中执行的文件名称错误时</li><li>unlink：要删除的目录不存在或者权限不足时</li></ul><h2 id="第二十一题"><a href="#第二十一题" class="headerlink" title="第二十一题"></a>第二十一题</h2><blockquote><p>  下列资源能使用哪种多路复用（时间、空间或者两者皆可）：CPU、内存、磁盘、网卡、打印机、键盘以及显示器？</p></blockquote><p>解：</p><ul><li>时间复用：CPU、网卡、打印机、键盘</li><li>空间复用：内存、磁盘、</li><li>两者皆可：显示器</li></ul><h2 id="第二十二题"><a href="#第二十二题" class="headerlink" title="第二十二题"></a>第二十二题</h2><blockquote><p>  在count = write(fd, buffer,nbytes);调用中，是否能将函数返回值传递给 count除nbtes变量以外的任何值吗？如果能，为什么？（这点书上翻译错了。。。）</p></blockquote><p>解：</p><p>write返回值：通常与参数nbytes相同，否则表示出错。</p><ol><li>若返回-1，表示write系统调用错误。</li><li>若返回值为0，则表示没有写入任何数据</li></ol><h2 id="第二十三题"><a href="#第二十三题" class="headerlink" title="第二十三题"></a>第二十三题</h2><blockquote><p>  有一个文件，其文件描述符是fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。有如下系统调用：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   lseek(fd, <span class="number">3</span>, SEEK_SET);</span><br><span class="line">&gt;   read(fd, &amp;buffer, <span class="number">4</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  其中lseek调用寻找文件中的字节3。在读操作完成之后，buffer中的内容是什么？</p></blockquote><p>解：</p><p>lseek：用于修改指针在文件中的位置。三个参数分别为文件描述、文件中的位置、说明相对于文件的起始位置，当前位置还是结尾。其返回值是文件中的绝对位置。</p><p>set我查的有start sth. happening的意思，也许在这里就是开始的意思吧，这个名字起的好抽象，以前都不知道set还有开始的意思。。。所以SEEK_SET就是从文件的开头，从开头算起第三个就是字符<strong>1</strong>了。</p><p>那read就是从字符1开始算4个字符即：1，5，9，2</p><blockquote><p>  我不太清楚他的指针是什么机制，但是当运行如下代码</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;   lseek(fd, <span class="number">0</span>, SEEK_SET);<span class="comment">//将指针设置在文件的起始位置</span></span><br><span class="line">&gt;   <span class="comment">//懒得打开Linux试了，还要重启换系统</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>如果文件起始位置是1，写的时候是不会从0开始写的，因为0不是一个位置，而是从1开始写，也即指针位置的下一个位置，那么lseek就会把指针设置在下一个要读写位置的前面，即每次读写都从指针的下一位开始读写（好像有些类似STL中的rbegin迭代器，我也记不清楚了）。<strong>但是</strong>，这个说法和书上的说法相<strong>矛盾</strong>，书上Page. 32的1.6.2中说“在顺序读(写)时，该指针通常指向要读(写)的下一个字节”。</li><li>如果文件起始位置是0，那么lseek会将指针设置在第0位，按书上说，下一次将在第0位开始读(写)，所以题目中的3可能指的就是文件中的第四个字符。</li></ul></blockquote><h2 id="第二十四题"><a href="#第二十四题" class="headerlink" title="第二十四题"></a>第二十四题</h2><blockquote><p>  假设一个10MB的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第100号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要1ms，当文件的开始部分存储在的扇区旋转到磁头下需要5ms，并且读的速率是200MB/s。</p></blockquote><p>解：</p><p>读取文件时间：(10MB) ÷ (200MB/s) = 0.05s = 50ms</p><p>总时间：50ms + 50ms + 5ms = 105ms</p><h2 id="第二十五题"><a href="#第二十五题" class="headerlink" title="第二十五题"></a>第二十五题</h2><blockquote><p>  块特殊文件和字符特殊文件的基本差别是什么？</p></blockquote><p>解：</p><p>如果一个硬件设备是以字符流的方式被访问的话，那就应该将它归于字符设备；反过来，如果一个设备是随机（无序的）访问的，那么它就属于块设备。块设备常见的是硬盘，而字符设备常见的是键盘等。</p><p>块特殊文件和字符特殊文件又叫做块设备和字符设备，在百度查块特殊文件和字符特殊文件基本查不到什么有用的资料，还能索引到有道词典的翻译是什么鬼？？？辣鸡百度。。。而查块设备和字符设备还能查到一些有用的东西。</p><h2 id="第二十六题"><a href="#第二十六题" class="headerlink" title="第二十六题"></a>第二十六题</h2><blockquote><p>  在图1-17的例子中库调用称为read，而系统调用自身称为read，这两者都有相问的名字是正常的吗？ 如果不是，哪一个更重要？</p><p>  <img src="/2019/10/07/《现代操作系统（第四版）》-课后习题答案-第一章/IMG_20191009_002644.jpg" alt="IMG_20191009_002644" style="zoom: 15%;"></p></blockquote><p>解：</p><p>书上Page. 29说“第七步：跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分配给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成”，</p><p>即这些系统调用其实没有名字，只是一些编号。应该在用户态的read更重要，因为他要写成代码，更抽象且容易被理解。</p><h2 id="第二十七题"><a href="#第二十七题" class="headerlink" title="第二十七题"></a>第二十七题</h2><blockquote><p>  现代操作系统将进程的地址空间从机器物理内存中分离出来，列举这种设计的两个好处。</p></blockquote><p>解：</p><ol><li>他为虚拟内存提出奠定了基础，如果进程地址空间和机器内存一一对应，则就不可能有虚拟内存存在。</li><li>防止其他恶意程序或者有bug的程序修改别的程序的内存。</li></ol><h2 id="第二十八题"><a href="#第二十八题" class="headerlink" title="第二十八题"></a>第二十八题</h2><blockquote><p>  对程序员而言，系统调用就像对其他库过程的调用一样。有无必要让程序员了解哪一个库过程导致了系统调用？在什么情形下，为什么？</p></blockquote><p>解：</p><p>我认为，一个好的库，应该是更抽象、美观。他应该让程序员忽略那些硬件细节和系统细节以达到更高效的开发。</p><h2 id="第二十九题"><a href="#第二十九题" class="headerlink" title="第二十九题"></a>第二十九题</h2><blockquote><p>  图1-23说明有一批UNIX的系统调用没有与之相等价的Win32 API，对于所列出的每一个没有Win32等价的调用，若程序员要把一个UNIX程序转换到Windows下运行，会有什么后果？</p><p>  <img src="/2019/10/07/《现代操作系统（第四版）》-课后习题答案-第一章/IMG_20191009_181417.jpg" alt="IMG_20191009_181417" style="zoom:15%;"></p></blockquote><p>解：</p><ul><li>link：在win32中文件将不能以另一个名字出现在其他目录中</li><li>mount和unmount：在win32中不能合并两个文件系统，也就必须分清楚哪些文件是在哪个驱动器上面。</li><li>chmod：在Win32中不能灵活改变文件的保护属性</li><li>kill：在Win32中不能杀死失常的程序</li></ul><h2 id="第三十题"><a href="#第三十题" class="headerlink" title="第三十题"></a>第三十题</h2><blockquote><p>  可移植的操作系统是能从一个系统体系结构到另一个体系结构的移动不需要任何修改的操作系统。请解释为什么建立一个完全可移植性的操作系统是不可行的。描述一下在设计一个髙度可移植的操作系统时你设计的两个高级层是什么样的。</p></blockquote><p>解：</p><ol><li>因为不同的硬件往往都有着自己独有的指令集，而某些硬件专用于实现一些功能，不同功能的指令集往往各不相同。即使功能相同的硬件指令集也不尽相同。</li><li>应该有一个用于屏蔽硬件细节吧，类似于计算机网络中的物理层。另一个不知道。。。（什么鬼问题，我对操作系统还不了解了，上来问这种劝退问题）</li></ol><h2 id="第三十一题"><a href="#第三十一题" class="headerlink" title="第三十一题"></a>第三十一题</h2><blockquote><p>  请解释在建立基于微内核的操作系统时策略与机制的分离带来的好处。</p></blockquote><p>解：</p><p>让内核体积更小，将复杂的策略实现交给用户态，使内核做的事情更加专一，效率更高。</p><h2 id="第三十二题"><a href="#第三十二题" class="headerlink" title="第三十二题"></a>第三十二题</h2><blockquote><p>  虚拟机由于很多因素而十分流行，然而他们也有一些缺点，给出一个缺点。</p></blockquote><p>解：</p><p>虚拟机建立在宿主操作系统之上，会给处理器和内存带来很大的开销来使虚拟机看似和宿主操作系统相同。</p><h2 id="第三十三题"><a href="#第三十三题" class="headerlink" title="第三十三题"></a>第三十三题</h2><blockquote><p>  下面是单位转换的练习：</p><p>  a)一微年是多少秒？</p><p>  b)微米常称为micron。那么gigamicron是多长？</p><p>  c) 1TB存储器中有多少字节？</p><p>  d)地球的质量是6000 yottagram, 换算成kilogram是多少？</p></blockquote><p>解：</p><ul><li>0.000001×365×24×3600 = 31.536s</li><li>1000000000×0.000001 = 1000m</li><li>2^40字节</li><li>6×10^21 kg</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq475703980/article/details/82534394" target="_blank" rel="noopener">《现代操作系统（中文第四版）》课后习题答案 第一章 引论</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《现代操作系统（第四版）》-课后习题答案–第一章&quot;&gt;&lt;a href=&quot;#《现代操作系统（第四版）》-课后习题答案–第一章&quot; class=&quot;headerlink&quot; title=&quot;《现代操作系统（第四版）》 课后习题答案–第一章&quot;&gt;&lt;/a&gt;《现代操作系统（第四版）》 
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="现代操作系统" scheme="http://yoursite.com/tags/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="课后习题" scheme="http://yoursite.com/tags/%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="http://yoursite.com/2019/10/06/Maven/"/>
    <id>http://yoursite.com/2019/10/06/Maven/</id>
    <published>2019-10-06T07:54:24.000Z</published>
    <updated>2019-10-06T10:19:50.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p><a href="https://pan.baidu.com/s/1h8P7aILAm9oJ2LD9ZKdGpA" target="_blank" rel="noopener">视频分享</a>     提取码：x8tf</p><h2 id="Maven的好处及概要"><a href="#Maven的好处及概要" class="headerlink" title="Maven的好处及概要"></a>Maven的好处及概要</h2><h3 id="maven的好处及核心"><a href="#maven的好处及核心" class="headerlink" title="maven的好处及核心"></a>maven的好处及核心</h3><p>普通项目通过把jar包复制进工程，而Maven则是建立一个jar包仓库，通过坐标（即公司名称+项目名称+版本号）来向仓库中寻找坐标</p><p>maven的两大核心：</p><ul><li>依赖管理：对jar包的管理过程</li><li>项目构建：项目在编码完成后，对项目进行编译、测试、打包、部署等一系列操作通过命令来实现<ul><li>通过maven命令将web项目发布到tomcat：mvn tomcat:run</li></ul></li></ul><h2 id="maven的配置及仓库"><a href="#maven的配置及仓库" class="headerlink" title="maven的配置及仓库"></a>maven的配置及仓库</h2><h3 id="maven的组成"><a href="#maven的组成" class="headerlink" title="maven的组成"></a>maven的组成</h3><p>maven文件组成： <img src="/2019/10/06/Maven/TIM截图20191006165336.png" alt="TIM截图20191006165336" style="zoom:50%;"></p><p>查询maven版本信息：cmd中键入mvn -v</p><h3 id="maven仓库类型"><a href="#maven仓库类型" class="headerlink" title="maven仓库类型"></a>maven仓库类型</h3><p><img src="/2019/10/06/Maven/TIM截图20191006171645-1570353500475.png" alt="TIM截图20191006171645" style="zoom:50%;"></p><h2 id="maven项目标准目录结构"><a href="#maven项目标准目录结构" class="headerlink" title="maven项目标准目录结构"></a>maven项目标准目录结构</h2><ul><li>src：项目源码<ul><li>main：主要代码<ul><li>java：java代码</li><li>recources：配置文件</li><li>webapp：页面素材：jsp文件、css文件等等</li></ul></li><li>test：单元测试<ul><li>java：单元测试类</li></ul></li><li>tarjet：存放编译后的文件（不属于maven标准目录结构）</li></ul></li><li>pom.xml：maven项目核心配置文件</li></ul><h2 id="maven常用的命令"><a href="#maven常用的命令" class="headerlink" title="maven常用的命令"></a>maven常用的命令</h2><h3 id="clean：清理命令"><a href="#clean：清理命令" class="headerlink" title="clean：清理命令"></a>clean：清理命令</h3><p>将已生成的.class文件清理掉（将根目录下的tarjet目录清理掉）</p><h3 id="compile：编译命令"><a href="#compile：编译命令" class="headerlink" title="compile：编译命令"></a>compile：编译命令</h3><p>将.java文件编译成.class文件</p><h3 id="test：测试命令"><a href="#test：测试命令" class="headerlink" title="test：测试命令"></a>test：测试命令</h3><p>将项目根目录下：test/java目录下的单元测试类全部执行</p><p>类名必须是XxxxTest.java</p><h3 id="package：打包命令"><a href="#package：打包命令" class="headerlink" title="package：打包命令"></a>package：打包命令</h3><p>动态打包：</p><ul><li>web project ……war包</li><li>java project ……jar包</li></ul><p>将项目打包到根目录下target目录</p><h3 id="install：安装命令"><a href="#install：安装命令" class="headerlink" title="install：安装命令"></a>install：安装命令</h3><p>解决本地多个项目公用一个jar包</p><p>将项目打包到本地仓库</p><h3 id="maven项目的生命周期"><a href="#maven项目的生命周期" class="headerlink" title="maven项目的生命周期"></a>maven项目的生命周期</h3><p>在maven项目中存在三套生命周期，每一套生命周期都是相互独立，即执行每一套生命周期中的命令时不会执行其他生命周期中的命令。在一套生命周期中，执行后面的命令，前面的命令会自动执行。</p><p>例：当执行install时命令执行顺序：compile -&gt; test -&gt; package -&gt; install</p><ul><li>CleanLifeCycle：清理生命周期<ul><li>Clean命令</li></ul></li><li>DefaultLifeCycle：默认生命周期（主要）<ul><li>compile命令</li><li>test命令</li><li>package命令</li><li>install命令</li><li>deploy命令</li></ul></li><li>SiteLifeCy：站点生命周期<ul><li>site命令</li></ul></li></ul><h2 id="maven整合struts2框架"><a href="#maven整合struts2框架" class="headerlink" title="maven整合struts2框架"></a>maven整合struts2框架</h2><ol><li>通过工具生成web.xml</li><li>添加struts2依赖</li><li>创建struts.xml</li><li>创建action类</li><li>在web.xml中配置struts2框架核心过滤器</li><li>编写action中方法</li><li>在struts.xml中配置</li></ol><h2 id="maven概念模型"><a href="#maven概念模型" class="headerlink" title="maven概念模型"></a>maven概念模型</h2><p><img src="https://img2018.cnblogs.com/blog/1320926/201906/1320926-20190618153818847-285359880.png" alt="img" style="zoom:60%;"></p><p>概念模型即两大核心：</p><ul><li>依赖管理：通过pom.xml文件完成</li><li>项目构建：通过生命周期完成</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1h8P7aILAm9oJ2LD9ZKdGpA&quot; 
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="依赖管理" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Spring--二、Spring基于注解的IOC及IOC的案例</title>
    <link href="http://yoursite.com/2019/10/04/Spring--%E4%BA%8C%E3%80%81Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC%E5%8F%8AIOC%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/10/04/Spring--二、Spring基于注解的IOC及IOC的案例/</id>
    <published>2019-10-04T04:37:47.000Z</published>
    <updated>2019-10-28T15:43:47.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring–二、Spring基于注解的IOC及IOC案例"><a href="#Spring–二、Spring基于注解的IOC及IOC案例" class="headerlink" title="Spring–二、Spring基于注解的IOC及IOC案例"></a>Spring–二、Spring基于注解的IOC及IOC案例</h1><p>视频：<a href="https://www.bilibili.com/video/av47952931/?p=1" target="_blank" rel="noopener">Spring5教程IDEA版-4天-2018黑马</a></p><p><a href="https://pan.baidu.com/s/1V5WhXOqkjQ0CuEA8Zj504A" target="_blank" rel="noopener">教学资源</a>    提取码：cwbz</p><p>基于注解的IOC配置和xml配置实现的功能都是一样的，都是降低程序间的耦合，只是配置的形式不一样。</p><h2 id="Spring中IOC的常用注解"><a href="#Spring中IOC的常用注解" class="headerlink" title="Spring中IOC的常用注解"></a>Spring中IOC的常用注解</h2><h3 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h3><ol><li>用于创建对象的：作用和在xml配置文件中写一个<strong>bean</strong>标签实现的功能相同</li><li>用于注入数据的：作用和在xml配置中的bean标签中写一个<strong>property</strong>标签功能相同</li><li>用于改变作用范围的：作用和bean标签使用<strong>scope</strong>属性实现功能相同</li><li>和生命周期相关：作用和在bean标签中使用<strong>init-method</strong>和<strong>destory-method</strong>作用相同</li></ol><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h5 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h5><p>在基于注解的配置中，我们还要将aop的jar包拷贝到lib目录</p><h4 id="使用-Component注解配置管理的资源"><a href="#使用-Component注解配置管理的资源" class="headerlink" title="使用@Component注解配置管理的资源"></a>使用@Component注解配置管理的资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账户的业务层实现类  </span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"accountService"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//账户的持久层实现类 </span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"accountDao"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> DBAssit dbAssit; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当我们使用注解注入时，set方法不用写。</p><h4 id="创建Spring的xml配置文件并开启对注解的支持"><a href="#创建Spring的xml配置文件并开启对注解的支持" class="headerlink" title="创建Spring的xml配置文件并开启对注解的支持"></a>创建Spring的xml配置文件并开启对注解的支持</h4><p>导入约束时需要多导入一个context名称空间下的约束，并且告知Spring在创建容器时要扫描的包。</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>相当于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用于创建对象的"><a href="#用于创建对象的" class="headerlink" title="用于创建对象的"></a>用于创建对象的</h4><h5 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h5><ul><li>作用：把资源让Spring来管理，相当于在xml中配置一个bean。</li><li>属性：<ul><li>value：指定bean的id。如果不指定value属性，默认bean的id是当前类的类名，首字母小写。</li></ul></li></ul><h5 id="Controller-Service-Repository"><a href="#Controller-Service-Repository" class="headerlink" title="@Controller     @Service     @Repository"></a>@Controller     @Service     @Repository</h5><p>这三个注解和Component注解的衍生，作用及属性都是一模一样的，只不过提供了更加明确的语义化：</p><ul><li>@Controller：一般用于<strong>表现层</strong>的注解</li><li>@Service：一般用于<strong>业务层</strong>的注解</li><li>@Repository：一般用于<strong>持久层</strong>的注解</li></ul><p>细节：如果注解中有且只有一个属性要赋值时，且名称是value，value在赋值时可以不写。</p><h4 id="用于注入数据的"><a href="#用于注入数据的" class="headerlink" title="用于注入数据的"></a>用于注入数据的</h4><p>相当于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h5><p>在Spring的IOC容器中寻找变量自动按类型匹配。（容器中的变量即用@Component或其他三个注解的对象）当使用注解注入属性时，set方法可以忽略。它只能注入其他bean类型。</p><p>作用：</p><ul><li>当只有一个变量的类型匹配时则成功。</li><li>当有多个变量的类型匹配时，使用要注解的对象变量名称作为bean的id，在Spring的IOC容器中查找，找到了就可以注入成功，找不到就报错。</li></ul><p>出现位置：</p><p>​    可以是变量上，也可以是方法上。</p><h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><p>作用：在自动按照类型注入的基础之上，再按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowired一起使用；但是给方法参数注入时，可以独立使用。</p><p>属性：value：指定bean的id。</p><h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><p>作用：直接按照Bean的id注入。它也只能注入其他bean类型。</p><p>属性：name：指定bean的id</p><h5 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h5><p>作用：注入基本数据类型和String类型数据的</p><p>属性： value：用于指定值（可以支持Spring的SpEL表达式：${表达式}）</p><h4 id="用于改变作用范围的"><a href="#用于改变作用范围的" class="headerlink" title="用于改变作用范围的"></a>用于改变作用范围的</h4><p>相当于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">scope</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h5><p>作用： 指定bean的作用范围。 </p><p>属性： value：指定范围的值。 取值：<strong>singleton</strong>    <strong>prototype</strong>    request    session    globalsession</p><h4 id="和生命周期相关（了解）"><a href="#和生命周期相关（了解）" class="headerlink" title="和生命周期相关（了解）"></a>和生命周期相关（了解）</h4><p>相当于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">init-method</span>=<span class="string">""</span> <span class="attr">destroy-method</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h5><p>作用： 用于指定初始化方法。</p><h5 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h5><p>作用： 用于指定销毁方法。</p><h3 id="关于Spring注解和XML的选择问题"><a href="#关于Spring注解和XML的选择问题" class="headerlink" title="关于Spring注解和XML的选择问题"></a>关于Spring注解和XML的选择问题</h3><ul><li>注解的优势： 配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。 </li><li>XML的优势： 修改时，不用改源码。不涉及重新编译和部署。</li></ul><p>两者比较：<img src="/2019/10/04/Spring--二、Spring基于注解的IOC及IOC的案例/1570196055969.png" alt="1570196055969" style="zoom:50%;"></p><h2 id="案例使用xml方式和注解方式实现单表的CRUD操作"><a href="#案例使用xml方式和注解方式实现单表的CRUD操作" class="headerlink" title="案例使用xml方式和注解方式实现单表的CRUD操作"></a>案例使用xml方式和注解方式实现单表的CRUD操作</h2><p>CRUD即增(Create)、查(Retrieve)、改(Update)、删(Delete)</p><p>此处可看链接视频的P35-P38</p><h2 id="改造基于注解的IOC案例，使用纯注解的方式实现"><a href="#改造基于注解的IOC案例，使用纯注解的方式实现" class="headerlink" title="改造基于注解的IOC案例，使用纯注解的方式实现"></a>改造基于注解的IOC案例，使用纯注解的方式实现</h2><p>经过上面的改造，我们还有几种配置需要从xml改成注解配置。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>作用： 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 </p><p>属性： value:用于指定配置类的字节码</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>作用： 用于指定spring在初始化容器时要扫描的包。作用和在spring的xml配置文件中的： &lt;context:component-scan base-package=”com.itheima”/&gt;是一样的。 </p><p>属性： basePackages：用于指定要扫描的包。和该注解中的value属性作用一样。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.itheima"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>作用： 该注解只能写在方法上，表明使用此方法创建一个对象，将方法的返回值放入spring容器。 </p><p>属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）（当不写时默认为当前方法的名字）。</p><p>细节：当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象，查找方式和Autowired注解的作用是一样的。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"dbAssit"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> DBAssit <span class="title">createDBAssit</span><span class="params">(DataSource dataSource)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DBAssit(dataSource); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>作用： 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解。当然，写上也没问题。 有import的为父配置类，导入的是子配置类。</p><p>属性： value[]：用于指定其他配置类的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.itheima.spring"</span>) </span><br><span class="line"><span class="meta">@Import</span>(&#123; JdbcConfig.class&#125;) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><p>作用：用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。</p><p>属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbc.properties文件： </span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver </span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/day44_ee247_spring</span></span><br><span class="line">jdbc.username=root </span><br><span class="line">jdbc.password=<span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="Spring和Junit的整合"><a href="#Spring和Junit的整合" class="headerlink" title="Spring和Junit的整合"></a>Spring和Junit的整合</h2><p>JUnit是一个Java编程语言的单元测试框架。</p><h3 id="问题及解决思路"><a href="#问题及解决思路" class="headerlink" title="问题及解决思路"></a>问题及解决思路</h3><p>在测试类中，每个测试方法都有以下两行代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">IAccountService as = ac.getBean(<span class="string">"accountService"</span>,IAccountService.class);</span><br></pre></td></tr></table></figure><p>这两行代码的作用分别是获取容器和创建业务层对象，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。但是测试人员不会管你使用的到底是什么框架，所以可能他根本不知道容器是个什么东西，所以我们需要的是<strong>程序能自动帮我们创建容器</strong>。</p><p>Junit的一个注解可以让我们替换他的运行器，这时我们可以用这个注解将运行器替换为spring框架的运行器，它可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="导入jar包-1"><a href="#导入jar包-1" class="headerlink" title="导入jar包"></a>导入jar包</h4><p>导入spring-test的jar包和spring-aop的jar包。</p><h4 id="使用-RunWith注解替换原有运行器"><a href="#使用-RunWith注解替换原有运行器" class="headerlink" title="使用@RunWith注解替换原有运行器"></a>使用@RunWith注解替换原有运行器</h4><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="使用-ContextConfiguration指定spring配置文件的位置"><a href="#使用-ContextConfiguration指定spring配置文件的位置" class="headerlink" title="使用@ContextConfiguration指定spring配置文件的位置"></a>使用@ContextConfiguration指定spring配置文件的位置</h4><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) </span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations= &#123;<span class="string">"classpath:bean.xml"</span>&#125;) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>@ContextConfiguration注解： </p><ul><li>locations属性：用于指定配置文件的位置。如果是类路径下，需要用classpath:表明 </li><li>classes属性：用于指定注解的类。当不使用xml配置时，需要用此属性指定注解类的位置。</li></ul><h4 id="使用-Autowired给测试类中的变量注入数据"><a href="#使用-Autowired给测试类中的变量注入数据" class="headerlink" title="使用@Autowired给测试类中的变量注入数据"></a>使用@Autowired给测试类中的变量注入数据</h4><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class) </span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations= &#123;<span class="string">"classpath:bean.xml"</span>&#125;) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123; </span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> IAccountService as ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么不把测试类配到xml中"><a href="#为什么不把测试类配到xml中" class="headerlink" title="为什么不把测试类配到xml中"></a>为什么不把测试类配到xml中</h3><ol><li>当我们在xml中配置了一个bean，spring加载配置文件创建容器时，就会创建对象。</li><li>测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。</li></ol><p>接下来请看下一篇。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring–二、Spring基于注解的IOC及IOC案例&quot;&gt;&lt;a href=&quot;#Spring–二、Spring基于注解的IOC及IOC案例&quot; class=&quot;headerlink&quot; title=&quot;Spring–二、Spring基于注解的IOC及IOC案例&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring--一、Spring概述及Spring中基于XML的IOC配置</title>
    <link href="http://yoursite.com/2019/10/02/Spring--%E4%B8%80%E3%80%81Spring%E6%A6%82%E8%BF%B0%E5%8F%8ASpring%E4%B8%AD%E5%9F%BA%E4%BA%8EXML%E7%9A%84IOC%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/</id>
    <published>2019-10-02T10:48:40.000Z</published>
    <updated>2019-10-06T10:19:45.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring–一、Spring概述及Spring中基于XML的IOC配置"><a href="#Spring–一、Spring概述及Spring中基于XML的IOC配置" class="headerlink" title="Spring–一、Spring概述及Spring中基于XML的IOC配置"></a>Spring–一、Spring概述及Spring中基于XML的IOC配置</h1><p>视频：<a href="https://www.bilibili.com/video/av47952931/?p=1" target="_blank" rel="noopener">Spring5教程IDEA版-4天-2018黑马</a></p><p><a href="https://pan.baidu.com/s/1V5WhXOqkjQ0CuEA8Zj504A" target="_blank" rel="noopener">教学资源</a>    提取码：cwbz</p><h2 id="Spring的概述（了解）"><a href="#Spring的概述（了解）" class="headerlink" title="Spring的概述（了解）"></a>Spring的概述（了解）</h2><h3 id="spring是什么"><a href="#spring是什么" class="headerlink" title="spring是什么"></a>spring是什么</h3><p>Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</p><h3 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h3><blockquote><p>  <strong>方便解耦，简化开发</strong></p><p>  通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p></blockquote><blockquote><p>  <strong>AOP编程的支持</strong></p><p>  通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p></blockquote><blockquote><p>  <strong>声明式事务的支持</strong></p><p>  可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。</p></blockquote><blockquote><p>  <strong>方便程序的测试</strong></p><p>  可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</p></blockquote><blockquote><p>  <strong>方便集成各种优秀框架</strong></p><p>  Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。</p></blockquote><blockquote><p>  <strong>降低JavaEE API的使用难度</strong></p><p>  Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。</p></blockquote><blockquote><p>  <strong>Java源码是经典学习范例</strong></p><p>  Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。</p></blockquote><h3 id="Spring的体系结构"><a href="#Spring的体系结构" class="headerlink" title="Spring的体系结构"></a>Spring的体系结构</h3><p><img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570021394756.png" alt="1570021394756" style="zoom:50%;"></p><p>Spring的两大核心为：AOP和IOC</p><p>AOP部分为：AOP、Aspects、Instrumentation、Messaging</p><p>IOC（核心容器）部分为Core Container部分</p><h2 id="IOC的概念和作用"><a href="#IOC的概念和作用" class="headerlink" title="IOC的概念和作用"></a>IOC的概念和作用</h2><h3 id="程序的耦合与解耦"><a href="#程序的耦合与解耦" class="headerlink" title="程序的耦合与解耦"></a>程序的耦合与解耦</h3><p>程序的耦合即程序间的依赖关系：①类之间的依赖关系。②方法间的依赖关系。</p><p>解耦即降低程序间的依赖关系，实际开发中应做到编译期不依赖，运行时才依赖：</p><ol><li>使用反射（Class.forName()）来创建对象，避免使用new来创建对象。</li><li>通过读取配置文件来获取要创建的对象的全限定类名。<ol><li>配置文件内容：唯一标识=全限定类名（key=value）</li></ol></li></ol><h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><p>在实际开发中我们可以把三层（参考JavaEE三层结构：Web(表现)层、业务层、DAO(数据)层）的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 </p><p>那么，这个读取配置文件，创建和获取三层对象的类就是工厂。</p><p>建议了解单例多例对象来提高工厂模式解耦效率。</p><h3 id="控制翻转-Inversion-Of-Control（IOC）"><a href="#控制翻转-Inversion-Of-Control（IOC）" class="headerlink" title="控制翻转-Inversion Of Control（IOC）"></a>控制翻转-Inversion Of Control（IOC）</h3><p>控制反转（IOC）即把创建对象的权利交给框架，是框架的重要特征，它包括依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）</p><p>原来我们创建对象是用new来<strong>主动</strong>创建的，即我们的项目对资源的使用是直接关联的，如图：<img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570085897052.png" alt="1570085897052" style="zoom:50%;"></p><p>现在，我们引入框架的工厂来帮我们创建生产对象，他负责给我们从指定容器中获取指定对象的类，这时候这个对象获取过来是不是我能用的，我们的应用本身已经无法得知了，工厂能得到哪个对象是根据配置文件中的全限定类名（key=value）获得的，我们的应用本身没有自主控制权。而原来的直接new的方法则应用本身是有自主控制权的。所以这种工厂模式降低了我们程序间的依赖关系，如图：<img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570086617087.png" alt="1570086617087" style="zoom:50%;"></p><p>即IOC用来削减计算机程序间的耦合。</p><h2 id="使用Spring的IOC解决程序耦合"><a href="#使用Spring的IOC解决程序耦合" class="headerlink" title="使用Spring的IOC解决程序耦合"></a>使用Spring的IOC解决程序耦合</h2><h3 id="Spring的开发包"><a href="#Spring的开发包" class="headerlink" title="Spring的开发包"></a>Spring的开发包</h3><p>官网：<a href="http://spring.io/" target="_blank" rel="noopener">http://spring.io/</a></p><p>Spring的目录结构：</p><ul><li>dcos：API和开发规范</li><li>libs：jar包和源码</li><li>schema：约束</li></ul><h3 id="Spring基于XML的IOC细节"><a href="#Spring基于XML的IOC细节" class="headerlink" title="Spring基于XML的IOC细节"></a>Spring基于XML的IOC细节</h3><h4 id="Spring中工厂的类结构图"><a href="#Spring中工厂的类结构图" class="headerlink" title="Spring中工厂的类结构图"></a>Spring中工厂的类结构图</h4><p><img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/1570088592204.png" alt="1570088592204" style="zoom:50%;"></p><p><img src="/2019/10/02/Spring--一、Spring概述及Spring中基于XML的IOC配置/TIM截图20191003153640.png" alt="TIM截图20191003153640" style="zoom:50%;"></p><h5 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h5><p>BeanFactory 才是Spring 容器中的顶层接口。ApplicationContext 是它的子接口。</p><p>BeanFactory 和ApplicationContext 的区别：创建对象的时间点不一样。</p><ul><li>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。单例对象适用。常用此接口，Spring会根据对象的单例多例来选择。</li><li>BeanFactory：什么使用什么时候创建对象。多例对象适用。</li></ul><h5 id="ApplicationContext接口的实现类"><a href="#ApplicationContext接口的实现类" class="headerlink" title="ApplicationContext接口的实现类"></a>ApplicationContext接口的实现类</h5><ul><li>ClassPathXmlApplicationContext：<br>它是从类的根路径下加载配置文件 推荐使用这种</li><li>FileSystemXmlApplicationContext：<br>它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</li><li>AnnotationConfigApplicationContext:<br>当我们使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。</li></ul><h4 id="IOC中bean标签和管理对象细节"><a href="#IOC中bean标签和管理对象细节" class="headerlink" title="IOC中bean标签和管理对象细节"></a>IOC中bean标签和管理对象细节</h4><h5 id="bean标签"><a href="#bean标签" class="headerlink" title="bean标签"></a>bean标签</h5><p>作用：</p><ul><li>用于配置对象让spring来创建的。 </li><li><p>默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</p><p>属性：</p></li><li><p>id：给对象在容器中提供一个唯一标识。用于获取对象。</p></li><li>class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</li><li>scope：指定对象的作用范围。<ul><li>singleton :默认值，单例的.</li><li>prototype :多例的. </li><li>request :WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中. </li><li>session :WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中.</li><li>global session :WEB项目中,应用在Portlet环境.如果没有Portlet环境那么globalSession相当于session. </li></ul></li><li>init-method：指定类中的初始化方法名称。</li><li>destroy-method：指定类中销毁方法名称。</li></ul><h5 id="bean的作用范围和生命周期"><a href="#bean的作用范围和生命周期" class="headerlink" title="bean的作用范围和生命周期"></a>bean的作用范围和生命周期</h5><p>单例对象：scope=”singleton” </p><ul><li>一个应用只有一个对象的实例。它的作用范围就是整个引用。 </li><li>生命周期： <ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。 </li><li>对象活着：只要容器在，对象一直活着。 </li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。 </li></ul></li></ul><p>多例对象：scope=”prototype” </p><ul><li>每次访问对象时，都会重新创建对象实例。 </li><li>生命周期： <ul><li>对象出生：当使用对象时，创建新的对象实例。</li><li>对象活着：只要对象在使用中，就一直活着。 </li><li>对象死亡：当对象长时间不用时，被java的垃圾回收器回收了。</li></ul></li></ul><h5 id="实例化bean的三种方式"><a href="#实例化bean的三种方式" class="headerlink" title="实例化bean的三种方式"></a>实例化bean的三种方式</h5><p>第一种方式：使用默认无参构造函数 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在默认情况下： 它会根据默认无参构造函数来创建类对象。如果bean中没有默认无参构造函数，将会创建失败。--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方式：spring管理静态工厂-使用静态工厂的方法创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*模拟一个静态工厂，创建业务层实现类*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title">createAccountService</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此种方式是:</span></span><br><span class="line"><span class="comment">使用StaticFactory类中的静态方法createAccountService创建对象，并存入spring容器</span></span><br><span class="line"><span class="comment">id属性：指定bean的id，用于从容器中获取</span></span><br><span class="line"><span class="comment">class属性：指定静态工厂的全限定类名</span></span><br><span class="line"><span class="comment">factory-method属性：指定生产对象的静态方法</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.factory.StaticFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">"createAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三种方式：spring管理实例工厂-使用实例工厂的方法创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*模拟一个实例工厂，创建业务层实现类</span></span><br><span class="line"><span class="comment">*此工厂创建对象，必须现有工厂实例对象，再调用方法 </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">createAccountService</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此种方式是： </span></span><br><span class="line"><span class="comment">先把工厂的创建交给spring来管理。 然后在使用工厂的bean来调用里面的方法 </span></span><br><span class="line"><span class="comment">factory-bean属性：用于指定实例工厂bean的id。 </span></span><br><span class="line"><span class="comment">factory-method属性：用于指定实例工厂中创建对象的方法。</span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instancFactory"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.factory.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-bean</span>=<span class="string">"instancFactory"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">factory-method</span>=<span class="string">"createAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring的依赖注入"><a href="#Spring的依赖注入" class="headerlink" title="Spring的依赖注入"></a>Spring的依赖注入</h4><h5 id="依赖注入的概念"><a href="#依赖注入的概念" class="headerlink" title="依赖注入的概念"></a>依赖注入的概念</h5><p>依赖注入是Spring框架核心IOC的具体实现</p><p>什么是依赖注入呢？即在当前类需要其他类的对象时，由Spring为我们提供，而不是自己创建，我们只需要在配置文件中说明依赖关系的维护。</p><p>依赖注入：</p><ul><li>能注入的数据有三类：<ul><li>基本类型和String</li><li>其他bean类型（在配置文件或注解配置过的bean）</li><li>复杂类型/集合类型</li></ul></li><li>注入的方式：<ul><li>使用构造函数提供</li><li>使用set方法提供</li><li>使用注解提供（下一篇）</li></ul></li></ul><h5 id="构造函数的依赖注入"><a href="#构造函数的依赖注入" class="headerlink" title="构造函数的依赖注入"></a>构造函数的依赖注入</h5><p>就是通过类的构造函数，给成员变量赋值。赋值操作是通过配置文件的方式，让Spring框架来帮我们注入。一般这种方式用于不经常更变的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是我们需要调用的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="keyword">private</span> Date birthday; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, </span></span></span><br><span class="line"><span class="function"><span class="params">                              Integer age, Date birthday)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用构造函数的方式，给service中的属性传值 </span></span><br><span class="line"><span class="comment">要求： </span></span><br><span class="line"><span class="comment">类中需要提供一个对应参数列表的构造函数。 </span></span><br><span class="line"><span class="comment">涉及的标签： constructor-arg （bean标签内部）</span></span><br><span class="line"><span class="comment">       属性： </span></span><br><span class="line"><span class="comment">        index:指定参数在构造函数参数列表的索引位置 </span></span><br><span class="line"><span class="comment">        type:指定参数在构造函数中的数据类型</span></span><br><span class="line"><span class="comment">        name:指定参数在构造函数中的名称 用这个找给谁赋值</span></span><br><span class="line"><span class="comment">=======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== </span></span><br><span class="line"><span class="comment">        value:它能赋的值是基本数据类型和String类型 </span></span><br><span class="line"><span class="comment">        ref:它能赋的值是其他bean类型，也就是说，必须得是在配置文件中配置过的bean </span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring注入的类型默认为字符串，要注入其他bean类型时，他不能强制转换成该类型，需要另外在配置文件中创建一个bean类型，让该类型的构造函数帮我们创建好，再将该类型通过配置文件传入要注入的对象。</p><p>优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。</p><p>弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。</p><h5 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h5><p>就是利用类中提供set方法类设置成员变量的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="keyword">private</span> Date birthday; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过配置文件给bean中的属性传值：使用set方法的方式 </span></span><br><span class="line"><span class="comment">涉及的标签： property（bean标签里面）</span></span><br><span class="line"><span class="comment">属性： </span></span><br><span class="line"><span class="comment">name：找的是类中set方法后面的部分 </span></span><br><span class="line"><span class="comment">ref：给属性赋值是其他bean类型的 </span></span><br><span class="line"><span class="comment">value：给属性赋值是基本数据类型和string类型的 </span></span><br><span class="line"><span class="comment">实际开发中，此种方式用的较多。 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优势：创建对象时没有明确的限制，可以直接使用默认构造函数</p><p>弊端：如有某个成员必须有值，则获取对象可能set方法没有执行</p><h5 id="复杂类型注入"><a href="#复杂类型注入" class="headerlink" title="复杂类型注入"></a>复杂类型注入</h5><p>本质上还是使用set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String[] myStrs; </span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; myList; </span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mySet; </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; myMap; </span><br><span class="line">    <span class="keyword">private</span> Properties myProps; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStrs</span><span class="params">(String[] myStrs)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myList = myList; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProps</span><span class="params">(Properties myProps)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(Arrays.toString(myStrs)); </span><br><span class="line">        System.out.println(myList); </span><br><span class="line">        System.out.println(mySet); </span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注入集合数据 </span></span><br><span class="line"><span class="comment">List结构的： array,list,set </span></span><br><span class="line"><span class="comment">Map结构的 map,entry,props,prop </span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 给数组注入数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入list集合数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="tag">&lt;/<span class="name">array</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入set集合数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入Map数据 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testA"</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 注入properties数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testA"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testB"</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用P名称空间注入数据"><a href="#使用P名称空间注入数据" class="headerlink" title="使用P名称空间注入数据"></a>使用P名称空间注入数据</h5><p>通过再xml中导入p名称空间，使用p：propertyName来注入数据，本质还是调用set方法（视频里没讲，可能是少了一集）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl4</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="keyword">private</span> Date birthday; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(name+<span class="string">","</span>+age+<span class="string">","</span>+birthday); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl4"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">p:name</span>=<span class="string">"test"</span> <span class="attr">p:age</span>=<span class="string">"21"</span> <span class="attr">p:birthday-ref</span>=<span class="string">"now"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来请看下一篇。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring–一、Spring概述及Spring中基于XML的IOC配置&quot;&gt;&lt;a href=&quot;#Spring–一、Spring概述及Spring中基于XML的IOC配置&quot; class=&quot;headerlink&quot; title=&quot;Spring–一、Spring概述及Sp
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot</title>
    <link href="http://yoursite.com/2019/10/02/Spring-boot/"/>
    <id>http://yoursite.com/2019/10/02/Spring-boot/</id>
    <published>2019-10-02T09:12:34.000Z</published>
    <updated>2019-10-02T09:19:49.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Spring-Boot"><a href="#一、Spring-Boot" class="headerlink" title="一、Spring Boot"></a>一、Spring Boot</h1><h2 id="0、前导内容"><a href="#0、前导内容" class="headerlink" title="0、前导内容"></a>0、前导内容</h2><p>（看了尚硅谷的视频看了几集才发现需要学前导内容，先滚去看Spring和Maven了，笔记回来再更新）</p><p>需要先掌握：</p><ul><li>Spring框架的使用经验</li><li>熟练使用Maven进行项目构建和依赖管理</li><li>熟练使用Eclipse或者IDEA</li></ul><h2 id="1、Spring-Boot-简介"><a href="#1、Spring-Boot-简介" class="headerlink" title="1、Spring Boot 简介"></a>1、Spring Boot 简介</h2><blockquote><p>  简化Spring应用开发的一个框架</p><p>  整个Spring技术栈的一个大整合</p><p>  JavaEE开发的一站式解决方案</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>微服务：架构风格</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行沟通</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软件单元</p><p>微服务文档：<a href="https://martinfowler.com/articles/microservices.html#microservicesAndSoa" target="_blank" rel="noopener">英文原版</a>  <a href="http://blog.cuicc.com/blog/2015/07/22/microservices/" target="_blank" rel="noopener">简体中文</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Spring-Boot&quot;&gt;&lt;a href=&quot;#一、Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;一、Spring Boot&quot;&gt;&lt;/a&gt;一、Spring Boot&lt;/h1&gt;&lt;h2 id=&quot;0、前导内容&quot;&gt;&lt;a href=&quot;#0、前
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>记--20190923</title>
    <link href="http://yoursite.com/2019/09/23/%E8%AE%B0-20190923/"/>
    <id>http://yoursite.com/2019/09/23/记-20190923/</id>
    <published>2019-09-23T12:17:55.000Z</published>
    <updated>2019-09-23T13:22:47.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记–20190923"><a href="#记–20190923" class="headerlink" title="记–20190923"></a>记–20190923</h1><p>今天的心情可能就像过山车一样，落起落落落落落。。。到晚上的时候已经麻木，什么都无所谓了。。。</p><h2 id="蓝桥杯报销"><a href="#蓝桥杯报销" class="headerlink" title="蓝桥杯报销"></a>蓝桥杯报销</h2><p>关于蓝桥杯报销的事跑了挺长时间了，可能是自己办事能力太差了，每次都像无头苍蝇一样到处乱撞。问了计算机院的老师，还问了16级的辅导员，跑了新区老区，今天终于给他弄完了，不过最后做的不太好，忘记将报销明细给记下来算一算，挺失误的。其实最后挺感谢16级的辅导员的，还是她帮我找的老师去算报销，要不然又得问一大堆人。。。最后办完专门给老师发了个短信谢谢老师。</p><h2 id="ACM省赛单项奖学金审核"><a href="#ACM省赛单项奖学金审核" class="headerlink" title="ACM省赛单项奖学金审核"></a>ACM省赛单项奖学金审核</h2><p>前一段时间导员给我说我的ACM省赛单项奖学金没有过审，我突然一愣，一脸懵逼。当时老师说级别不够，然后我觉得不可能啊，就问老师能不能申诉，可能是自己语气不太好，老师直接说不能。（自己有时候脾气太急了）后来问了学长啥的，又和老师联系了一下，老师也帮忙问了问。最后让我去行政楼问，还专门叮嘱我是去咨询，不是去质问。</p><p>今天去了行政楼，那个老师说这个奖从今年开始都不算了。WTM……当时就想怼一句，这个奖不算哪个省赛的奖还有资格算？？？最后说了两句，心里火大的很，可能语气也不太好，就走了。。。</p><h2 id="三好学生"><a href="#三好学生" class="headerlink" title="三好学生"></a>三好学生</h2><p>本来想着今年有希望能申请三好学生的，后来公布名单的时候没有我，心里挺失落的，就和前面那个人综合测评差了0.3分，正正好到我前面一个人，实力不行，无话可说。今天班长和我说我们专业多出来一个三好学生名额，最后导员说我文化课成绩不够年级前百分之三十，没有给我，行吧，莫得办法，菜就是菜。。。</p><h2 id="关于考研"><a href="#关于考研" class="headerlink" title="关于考研"></a>关于考研</h2><p>今天听了某考研机构的讲课，突然感觉要开始学英语和数学了，虽然他讲的有些夸张，想让我们报辅导班，但是英语和数学确实得拉长战线，感觉好紧张啊，还想啃一啃西瓜书和两本黑砖头的操作系统和计网的书了，光这三本砖头就够我看的了，感觉时间不够啊，还要准备接下来的区域赛，卧槽，压力好大啊。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己在办事能力和与人交流能力上差太多了，以后对老师和找别人办事一定要忍住脾气，对别人一定要谦逊有礼貌，办完事别忘说谢谢，麻烦您了，和别人打声招呼。对未来这学期的规划也该做一做了，考研英语数学，看书，ACM区域赛。希望能在区域赛拿个牌子，要是什么都没拿到，大学四年真的是废了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记–20190923&quot;&gt;&lt;a href=&quot;#记–20190923&quot; class=&quot;headerlink&quot; title=&quot;记–20190923&quot;&gt;&lt;/a&gt;记–20190923&lt;/h1&gt;&lt;p&gt;今天的心情可能就像过山车一样，落起落落落落落。。。到晚上的时候已经麻木，什么
      
    
    </summary>
    
      <category term="日志" scheme="http://yoursite.com/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #587 (Div. 3) 比赛&amp;补题</title>
    <link href="http://yoursite.com/2019/09/21/Codeforces-Round-587-Div-3-%E6%AF%94%E8%B5%9B-%E8%A1%A5%E9%A2%98/"/>
    <id>http://yoursite.com/2019/09/21/Codeforces-Round-587-Div-3-比赛-补题/</id>
    <published>2019-09-21T09:50:46.000Z</published>
    <updated>2019-09-22T10:10:10.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-587-Div-3-比赛-amp-补题"><a href="#Codeforces-Round-587-Div-3-比赛-amp-补题" class="headerlink" title="Codeforces Round #587 (Div. 3) 比赛&amp;补题"></a>Codeforces Round #587 (Div. 3) 比赛&amp;补题</h1><p>tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁</p><p>想开始打一打cf，刷题刷的太少了，太吃亏了。</p><h2 id="1216A-Prefixes"><a href="#1216A-Prefixes" class="headerlink" title="1216A. Prefixes"></a>1216A. Prefixes</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个字符串，长度为偶数，只包含小写字母a和b，你可以变换其中任意一个字母，把a换成b或者把b换成a。要求最后结果中的字符串任意偶数前缀a和b的数量相同。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>只需要保证第i个字母和第i+1个字母不相同就行了，i每次递增2。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n, ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n &gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'a'</span>)</span><br><span class="line">                s[i] = <span class="string">'b'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s[i] = <span class="string">'a'</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216B-Shooting"><a href="#1216B-Shooting" class="headerlink" title="1216B. Shooting"></a>1216B. Shooting</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给你几个罐子，每个罐子的耐久度为ai，你要将所有罐子击碎，当你要击碎第i个罐子时，你需要射击(ai*x+1)次，其中x为你已经击碎的罐子，可认为你将一个罐子击碎才会去射击下一个罐子。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>x是重点，只要反向排一下序就行了，有些类似哈夫曼树。一开始以为最后让依次输出第i个罐子是第几次被射击的，后来WA了一次才发现是让依次输出射击的是第几个罐子。。。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ai, index;</span><br><span class="line">&#125;ax[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(A a, A b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.ai&gt;b.ai;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;ax[i].ai;</span><br><span class="line">        ax[i].index = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>, ans=<span class="number">0</span>;</span><br><span class="line">    sort(ax, ax+n, cmp1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=(ax[i].ai*x+<span class="number">1</span>);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;ax[<span class="number">0</span>].index;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">' '</span> &lt;&lt;ax[i].index;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216C-White-Sheet"><a href="#1216C-White-Sheet" class="headerlink" title="1216C. White Sheet"></a>1216C. White Sheet</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给你一个白纸的左下角和右上角坐标，还有两张黑纸的左下角和右上角坐标，保证这三张纸的边缘都平行于坐标轴，问你黑纸是否能完全覆盖住白纸。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>坐标范围1e6，可以依次遍历白纸边缘的每一个点，看他是否在黑纸内，递增要设成0.5，不能设成1，最后没时间了，不知道思路对不对，回来再来补吧。（补：果然过了，太智障了。。。）</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">int</span> x3, y3, x4, y4;</span><br><span class="line">    <span class="keyword">int</span> x5, y5, x6, y6;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;x1 &gt;&gt;y1 &gt;&gt;x2 &gt;&gt;y2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;x3 &gt;&gt;y3 &gt;&gt;x4 &gt;&gt;y4;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;x5 &gt;&gt;y5 &gt;&gt;x6 &gt;&gt;y6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=x1; i&lt;=x2; i+=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=x4&amp;&amp;i&gt;=x3&amp;&amp;y1&lt;=y4&amp;&amp;y1&gt;=y3) || (i&lt;=x6&amp;&amp;i&gt;=x5&amp;&amp;y1&lt;=y6&amp;&amp;y1&gt;=y5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=y1; i&lt;=y2; i+=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=y4&amp;&amp;i&gt;=y3&amp;&amp;x1&lt;=x4&amp;&amp;x1&gt;=x3) || (i&lt;=y6&amp;&amp;i&gt;=y5&amp;&amp;x1&lt;=x6&amp;&amp;x1&gt;=x5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=x2; i&gt;=x1; i-=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=x4&amp;&amp;i&gt;=x3&amp;&amp;y2&lt;=y4&amp;&amp;y2&gt;=y3) || (i&lt;=x6&amp;&amp;i&gt;=x5&amp;&amp;y2&lt;=y6&amp;&amp;y2&gt;=y5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> i=y2; i&gt;=y2; i-=<span class="number">0.5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=y4&amp;&amp;i&gt;=y3&amp;&amp;x2&lt;=x4&amp;&amp;x2&gt;=x3) || (i&lt;=y6&amp;&amp;i&gt;=y5&amp;&amp;x2&lt;=x6&amp;&amp;x2&gt;=x5))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"NO"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216D-Swords"><a href="#1216D-Swords" class="headerlink" title="1216D. Swords"></a>1216D. Swords</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>地下室有n种剑，每种剑有x个，有y个人来地下室偷剑，每个人只拿一种剑，每个人拿了z个剑。现在发现地下室的剑被偷了，每种剑剩下ai个，其中x, y, z未知，给出n和ai，让你求出最少y个人来偷剑和每个人偷了多少剑z。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>用最大的数依次减去其他所有ai，求他们所有的最大公因数，然后再用前面算出来的最大数和其他数的差除以最大公因数，则可算出有多少人来偷剑了，最大公因数即为每个人偷了多少剑。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s, ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    sort(a, a+n, cmp);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a[<span class="number">0</span>]-a[i];</span><br><span class="line">        <span class="keyword">if</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(x);</span><br><span class="line">            ss.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s.size()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        y = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">        s.push(__gcd(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!ss.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x = ss.top();</span><br><span class="line">        ss.pop();</span><br><span class="line">        ans+=(x/s.top());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %d\n"</span>, ans, s.top());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1216E1-Numerical-Sequence-easy-version"><a href="#1216E1-Numerical-Sequence-easy-version" class="headerlink" title="1216E1. Numerical Sequence (easy version)"></a>1216E1. Numerical Sequence (easy version)</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>11212312341234512345612345671234567812345678912345678910……，给你一个这样的无限循环数列，1、12、123、1234、12345……这样循环，询问q次，每次询问在这个数列中第k位是什么数字。注意：11算两位数字，而不是一个数字。k最大为1e9，q不大于100。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><img src="/2019/09/21/Codeforces-Round-587-Div-3-比赛-补题/TIM截图20190922180010.png" alt="TIM截图20190922180010" style="zoom:50%;"></p><p>由程序算出当k为1e9时总共也才21837个数，所以我们只用预处理出前1e5个数的排列，预处理时记录下每个数的最后一位排到哪里了，最后直接查表就行了。</p><p>计算程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ll k=<span class="number">0</span>, i=<span class="number">1</span>, x;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=<span class="number">1000000000</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">            x = j;</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;k++;x/=<span class="number">10</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> num[maxn*<span class="number">5</span>], pre[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cal(x/<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    num[++n] = x%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cal(i);</span><br><span class="line">        pre[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;k;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+pre[i]&lt;k)</span><br><span class="line">                sum+=pre[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;num[k-sum] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/last-diary/p/11567813.html" target="_blank" rel="noopener">准点的星辰Codeforces Round #587(Div.3)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Codeforces-Round-587-Div-3-比赛-amp-补题&quot;&gt;&lt;a href=&quot;#Codeforces-Round-587-Div-3-比赛-amp-补题&quot; class=&quot;headerlink&quot; title=&quot;Codeforces Round #58
      
    
    </summary>
    
      <category term="比赛&amp;补题" scheme="http://yoursite.com/categories/%E6%AF%94%E8%B5%9B-%E8%A1%A5%E9%A2%98/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Codeforces" scheme="http://yoursite.com/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>kuangbin专题一简单搜索</title>
    <link href="http://yoursite.com/2019/09/19/kuangbin%E4%B8%93%E9%A2%98%E4%B8%80%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2019/09/19/kuangbin专题一简单搜索/</id>
    <published>2019-09-19T14:28:56.000Z</published>
    <updated>2019-10-02T09:15:04.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kuangbin专题一简单搜索"><a href="#kuangbin专题一简单搜索" class="headerlink" title="kuangbin专题一简单搜索"></a>kuangbin专题一简单搜索</h1><p>tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁</p><p><a href="https://vjudge.net/article/187" target="_blank" rel="noopener">kuangbin专题合集</a></p><p>[ACM正确入门方式——数学lover</p><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><ol><li><a href="https://vjudge.net/problem/POJ-1321" target="_blank" rel="noopener"><strong>POJ 1321</strong></a> 棋盘问题<font color="green">AC: 2018-07-17 23:54:31</font></li><li><a href="https://vjudge.net/problem/POJ-2251" target="_blank" rel="noopener"><strong>POJ 2251</strong></a> Dungeon Master<font color="green">AC: 2019-09-19 18:32:04</font></li><li><a href="https://vjudge.net/problem/POJ-3278" target="_blank" rel="noopener"><strong>POJ 3278</strong></a> Catch That Cow<font color="green">AC: 2019-09-21 19:37:10</font></li><li><a href="https://vjudge.net/problem/POJ-3279" target="_blank" rel="noopener"><strong>POJ 3279</strong></a> Fliptile<font color="green">AC: 2019-09-22 16:09:25</font></li><li><a href="https://vjudge.net/problem/POJ-1426" target="_blank" rel="noopener"><strong>POJ 1426</strong></a> Find The Multiple<font color="green">AC: 2019-09-23 20:09:26</font></li><li><a href="https://vjudge.net/problem/POJ-3126" target="_blank" rel="noopener"><strong>POJ 3126</strong></a> Prime Path<font color="green">AC: 2019-09-24 22:48:09</font></li><li><a href="https://vjudge.net/problem/POJ-3087" target="_blank" rel="noopener"><strong>POJ 3087</strong></a> Shuffle’m Up</li><li><a href="https://vjudge.net/problem/POJ-3414" target="_blank" rel="noopener"><strong>POJ 3414</strong></a> Pots</li><li><a href="https://vjudge.net/problem/FZU-2150" target="_blank" rel="noopener"><strong>FZU 2150</strong></a> Fire Game</li><li><a href="https://vjudge.net/problem/UVA-11624" target="_blank" rel="noopener"><strong>UVA 11624</strong></a> Fire!</li><li><a href="https://vjudge.net/problem/POJ-3984" target="_blank" rel="noopener"><strong>POJ 3984</strong></a> 迷宫问题</li><li><a href="https://vjudge.net/problem/HDU-1241" target="_blank" rel="noopener"><strong>HDU 1241</strong></a> Oil Deposits</li><li><a href="https://vjudge.net/problem/HDU-1495" target="_blank" rel="noopener"><strong>HDU 1495</strong></a> 非常可乐</li><li><a href="https://vjudge.net/problem/HDU-2612" target="_blank" rel="noopener"><strong>HDU 2612</strong></a> Find a way</li></ol><h2 id="POJ1321-棋盘问题"><a href="#POJ1321-棋盘问题" class="headerlink" title="POJ1321  棋盘问题"></a><a href="https://vjudge.net/problem/POJ-1321" target="_blank" rel="noopener">POJ1321  棋盘问题</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>就是在棋盘上放棋子，放的时候不能同行同列，和八皇后问题类似，只不过空白的地方不能放。这是我去年暑假acm训练时写的，现在已经忘了当时咋写的了，看着自己WA了好多发，太菜了。。。dfs时记得复原。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>dfs吧，没什么可说的，八皇后模板题。好烦啊，POJ不能用万能头文件。。。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">char</span> pan[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(pan[l][i]==<span class="string">'#'</span> &amp;&amp; !vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                dfs(l+<span class="number">1</span>);</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(0), cin.tie(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span> &amp;&amp; m==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt;pan[i][j];</span><br><span class="line"></span><br><span class="line">        ans = cnt = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ2251-Dungeon-Master"><a href="#POJ2251-Dungeon-Master" class="headerlink" title="POJ2251  Dungeon Master"></a><a href="https://vjudge.net/problem/POJ-2251" target="_blank" rel="noopener">POJ2251  Dungeon Master</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个3D迷宫，总共六个方向，上下左右前后。有的地方不能走有的能走，给出起点终点，问你能不能走到终点，如果能的话应该是求用时最短的吧（题目中没说，一开始用dfsWA了，后来看别人都用bfs才发现是不是要求最短路）。没移动一次要花费一分钟。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>bfs，一开始用bfs一直内存超限，快给我郁闷死了。。。要把走过的点用#堵上，防止多余的结点入队列。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">make_node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node a;</span><br><span class="line">    a.x = x, a.y = y, a.z = z, a.step=step;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l, r, c;</span><br><span class="line">    <span class="keyword">char</span> mp[maxn][maxn][maxn];</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">6</span>]= &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">6</span>]= &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dz[<span class="number">6</span>]= &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt;l &gt;&gt;r &gt;&gt;c &amp;&amp; l+r+c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;r; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;c; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt;mp[i][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(mp[i][j][k]==<span class="string">'S'</span>)</span><br><span class="line">                        q.push(make_node(i, j, k, <span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">if</span>(mp[i][j][k]==<span class="string">'E'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        x = i;</span><br><span class="line">                        y = j;</span><br><span class="line">                        z = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node a = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a.x==x &amp;&amp; a.y==y &amp;&amp; a.z==z)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;<span class="string">"Escaped in "</span>&lt;&lt;a.step &lt;&lt;<span class="string">" minute(s)."</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]]!=<span class="string">'#'</span>)</span><br><span class="line">                    <span class="keyword">if</span>(a.x+dx[i]&gt;=<span class="number">0</span> &amp;&amp; a.x+dx[i]&lt;l &amp;&amp; a.y+dy[i]&gt;=<span class="number">0</span> &amp;&amp; a.y+dy[i]&lt;r &amp;&amp; a.z+dz[i]&gt;=<span class="number">0</span> &amp;&amp; a.z+dz[i]&lt;c)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.push(make_node(a.x+dx[i], a.y+dy[i], a.z+dz[i], a.step+<span class="number">1</span>));</span><br><span class="line">                        mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]] = <span class="string">'#'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"Trapped!"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3287-Catch-That-Cow"><a href="#POJ3287-Catch-That-Cow" class="headerlink" title="POJ3287 Catch That Cow"></a><a href="https://vjudge.net/problem/POJ-3278" target="_blank" rel="noopener">POJ3287 Catch That Cow</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>你的牛跑了，要把它抓回来。你的位置在n，牛的位置在k，牛不会跑，你要用最少的时间走到牛的位置。你们的位置都在同一个数轴上，只有左右两个方向，你有三种走法，左走一步、右走一步或者传送到你当前坐标的二倍的位置，这三种走法都只花费一分钟。n和k都小于等于100000</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>只有三种操作，求最短时间，可以用bfs。bfs要设置一个vis数组，注意不能数组越界。还要注意当n==k的时候。一开始一直超内存，后来发现要设一个vis数组剪枝。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">make_node</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node a;</span><br><span class="line">    a.p = p;</span><br><span class="line">    a.t = t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">        q.push(make_node(n, <span class="number">0</span>));</span><br><span class="line">        vis[n] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            node a = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a.p+<span class="number">1</span>==k || a.p<span class="number">-1</span>==k || a.p*<span class="number">2</span>==k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;a.t+<span class="number">1</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a.p&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a.p+<span class="number">1</span>&lt;=<span class="number">100000</span> &amp;&amp; !vis[a.p+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_node(a.p+<span class="number">1</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                    vis[a.p+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a.p*<span class="number">2</span>-k&lt;k-a.p &amp;&amp; a.p*<span class="number">2</span>&lt;=<span class="number">100000</span> &amp;&amp; !vis[a.p*<span class="number">2</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_node(a.p*<span class="number">2</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                    vis[a.p*<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a.p<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !vis[a.p<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_node(a.p<span class="number">-1</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                    vis[a.p<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.p&gt;k &amp;&amp; a.p<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !vis[a.p<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(make_node(a.p<span class="number">-1</span>, a.t+<span class="number">1</span>));</span><br><span class="line">                vis[a.p<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3279-Fliptile"><a href="#POJ3279-Fliptile" class="headerlink" title="POJ3279 Fliptile"></a>POJ3279 Fliptile</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有n*m个方格，每个方格都有一块瓷砖，瓷砖的两面分别是黑色和白色，当你翻转瓷砖时瓷砖会从白色翻转成黑色，或者从黑色翻转成白色。样例输入为每个方格瓷砖的初始颜色，0代表白色，1代表黑色。现在让你的奶牛来将所有格子翻成白色，由于奶牛的蹄子比较大，它每次反转的时会将相邻的瓷砖也翻转过来，即上下左右的瓷砖。最后输出每个瓷砖的翻转次数，要求总的翻转次数最少，如果答案有多种，则输出字典序最小的那个答案。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>这题有个最重要的思想，就是第i层如果有黑色瓷砖，要通过第i+1层的翻转将其翻转成白色。这样只用保证前一层没有黑色即可，不用管当前层翻转成什么样，也不用管下一层。这样的话只要第一层的状态确定，后面所有的状态都确定了。因为第二层需要将第一层的黑瓷砖翻成白色的，这个过程中第二层可能会出现黑瓷砖，再用第三层将第二层翻转成白色的，再用第四层将。。。我们可以枚举第一层所有的状态，即每一块瓷砖翻或不翻，总共有2^m个，然后用第二层将第一层翻成白色。。。用最后一层将倒数第二层翻成白色，因为后面没有瓷砖来翻转最后一层了，所有我们通过判断最后一层有没有黑色瓷砖，就可以判断这个方法是否可行。</p><p>输出次数最少的那一个可以每次翻转记录一下，最后对比所有可能性的翻转次数取最小即可。</p><p>字典序最小，即输出答案时每行的字典序最小，每行的字典序即把所有数字串成一个字符串，让他们字典序最小，即将0 0 0 1 1串成00011，而00011的字典序比10010小。保证字典序最小可以先保证第一行字典序最小，第一行有2^m种可能，我们把没个瓷砖看成二进制的一位数，那第一行的所有操作就是0~(1&lt;&lt;m-1)，我们枚举的时候直接从0开始枚举就行了。</p><p>一开始写的时候怎么想都没思路，最后看了别人的题解才写出来，还是做题太少了，太菜了。。。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, turnnum, turnans;</span><br><span class="line"><span class="keyword">int</span> mp[maxn][maxn], a[maxn][maxn], fn[maxn][maxn], ans[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fn[i][j] = <span class="number">1</span>;</span><br><span class="line">turnnum++;</span><br><span class="line">a[i][j] = !a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">a[i + dx[k]][j + dy[k]] = !a[i + dx[k]][j + dy[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lp = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">turnans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lp; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(fn, <span class="number">0</span>, <span class="keyword">sizeof</span> fn);</span><br><span class="line"><span class="built_in">memcpy</span>(a, mp, <span class="keyword">sizeof</span> mp);</span><br><span class="line">turnnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp; <span class="number">1</span>)</span><br><span class="line">turn(<span class="number">1</span>, j);</span><br><span class="line">p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j - <span class="number">1</span>][k])</span><br><span class="line">turn(j, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[n][j])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == m+<span class="number">1</span> &amp;&amp; turnnum &lt; turnans)</span><br><span class="line">&#123;</span><br><span class="line">turnans = turnnum;</span><br><span class="line"><span class="built_in">memcpy</span>(ans, fn, <span class="keyword">sizeof</span> fn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (turnans == INF)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/c___c18/article/details/82465664" target="_blank" rel="noopener">POJ3279 二进制的搜索</a></p><h2 id="POJ1426-Find-The-Multiple"><a href="#POJ1426-Find-The-Multiple" class="headerlink" title="POJ1426 Find The Multiple"></a>POJ1426 Find The Multiple</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>给你一个不超过200的数n，让你求一个数m，m不超过100位，m只包含0和1且（m%n）== 0。</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>不知道为什么，直接定义longlong + BFS就过了。。。一开始想模拟，还超时了，菜。。。</p><p>在网上看到有个大佬在用这题讲<a href="https://blog.csdn.net/lyy289065406/article/details/6647917" target="_blank" rel="noopener">同余模定理</a>，抽空看一下。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> ll n, m=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">        m = <span class="number">1</span>;</span><br><span class="line">        q.push(m);</span><br><span class="line">        <span class="keyword">if</span>(m%n==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;m &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            m = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            m *= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(m%n==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;m &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(m);</span><br><span class="line">            m += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(m%n==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;m &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3126-Prime-Path"><a href="#POJ3126-Prime-Path" class="headerlink" title="POJ3126 Prime Path"></a>POJ3126 Prime Path</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>测试数据不超过一百组，每组给出两个四位素数，要求你将第一个数字变换成第二个数字。没回只能变换一位数字，而且首位数字不能变成0，变换过的数字也必须为素数。每次变换需要花1磅，问你从第一个数字变换到第二个数字最小花费是多少。</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>最少花费，肯定BFS了，先用线性素数筛打个表，每次进队的数据查表时间复杂度为O(1)，然后每一层循环，要把四位数字全换一遍，换一个数字进一次队列，用vis数组剪枝。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], pNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> p[maxn] = &#123;<span class="literal">false</span>&#125;, vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">num</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, <span class="built_in">cos</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">num <span class="title">make_num</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> <span class="built_in">cos</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num x;</span><br><span class="line">    x.a = a;</span><br><span class="line">    x.<span class="built_in">cos</span> = <span class="built_in">cos</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulerSieve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == <span class="literal">false</span>)</span><br><span class="line">            prime[pNum++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eulerSieve(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;a &gt;&gt;b;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;num&gt; q;</span><br><span class="line">        q.push(make_num(a, <span class="number">0</span>));</span><br><span class="line">        vis[a] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            num x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(x.a==b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt;x.<span class="built_in">cos</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y/<span class="number">1000</span>==i)   <span class="keyword">continue</span>;</span><br><span class="line">                y = i*<span class="number">1000</span>+y%<span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y/<span class="number">100</span>%<span class="number">10</span>==i) <span class="keyword">continue</span>;</span><br><span class="line">                y = (y/<span class="number">1000</span>*<span class="number">10</span>+i)*<span class="number">100</span>+y%<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y%<span class="number">100</span>/<span class="number">10</span>==i) <span class="keyword">continue</span>;</span><br><span class="line">                y = (y/<span class="number">100</span>*<span class="number">10</span>+i)*<span class="number">10</span>+y%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = x.a;</span><br><span class="line">                <span class="keyword">if</span>(y%<span class="number">10</span>==i) <span class="keyword">continue</span>;</span><br><span class="line">                y = y/<span class="number">10</span>*<span class="number">10</span>+i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[y] &amp;&amp; !p[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_num(y, x.<span class="built_in">cos</span>+<span class="number">1</span>));</span><br><span class="line">                    vis[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kuangbin专题一简单搜索&quot;&gt;&lt;a href=&quot;#kuangbin专题一简单搜索&quot; class=&quot;headerlink&quot; title=&quot;kuangbin专题一简单搜索&quot;&gt;&lt;/a&gt;kuangbin专题一简单搜索&lt;/h1&gt;&lt;p&gt;tips：大家评论的时候写一下邮箱和
      
    
    </summary>
    
      <category term="刷题" scheme="http://yoursite.com/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="搜索" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>tarjan求有向图的强连通分量</title>
    <link href="http://yoursite.com/2019/09/02/tarjan%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>http://yoursite.com/2019/09/02/tarjan求有向图的强连通分量/</id>
    <published>2019-09-02T11:37:49.000Z</published>
    <updated>2019-09-18T16:44:39.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tarjan求有向图的强连通分量"><a href="#tarjan求有向图的强连通分量" class="headerlink" title="tarjan求有向图的强连通分量"></a>tarjan求有向图的强连通分量</h1><p>tarjan到底是念“塔进”还是“塔扬”。好像大多数人都念“塔进”，但是英语好像是念“塔扬”。胡扯结束。。。</p><p>这个tarjan算法求的是有向图中的强连通分量，并将他们合并。</p><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p><strong>（如果会可以直接看tarjan部分）</strong>那什么是强连通分量呢？强连通嘛，就是<strong>图中任意两点能相互到达</strong>。那强连通分量就是一个图中的强连通子图。</p><p>环是最简单的强连通分量：</p><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909204020.png" alt="TIM截图20190909204020" style="zoom:50%;"></p><p>那你如果从1出发，只要转一圈就能经过所有点。</p><p>强连通分量不等于环，还有一些复杂的强连通分量，例如完全图：</p><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909204729.png" alt="TIM截图20190909204729" style="zoom:50%;"></p><p>很明显能看出从图中一点出发，可到达其他任意一个点。</p><h2 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h2><p>先上时间复杂度：O(N+M)    （其中N和M分别为点数和边数）</p><p>tarjan算法是通过对图的dfs来找出其中的强连通分量，并分类。<strong>（需掌握dfs的思想并且能熟练运用）</strong></p><h3 id="dfn数组和low数组讲解"><a href="#dfn数组和low数组讲解" class="headerlink" title="dfn数组和low数组讲解"></a>dfn数组和low数组讲解</h3><p>这里给出tarjan算法中两个重要数组的定义：</p><p>​    dfn[u]：表示当前结点i在dfs算法中第几个被访问的的点。</p><p>​    low[u]：表示当前结点i能回溯到的最小dfs序结点，<strong>dfs序即dfn[u]的值</strong>。</p><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909205034.png" alt="TIM截图20190909205034" style="zoom:50%;"></p><p>（6-&gt;1的箭头画反了，应该时1-&gt;6）</p><p>当从结点1开始dfs时，假设优先向下访问：dfn[1] = 1;    dfn[6] = 2;因为第一个访问的时结点1，所以它的dfs序是1，第二个访问的是结点6，所以它的dfs序时2。访问完结点6发现没有路了，则开始访问结点1的下一条出边。</p><p>开始访问结点2，刚刚访问的结点6是第二个访问的结点，所以结点2是第三个访问的结点，即它的dfs序为3：dfn[2] = 3;    dfn[5] = 4;    dfn[4] = 5;    dfn[3] = 6;我们顺着结点2依次访问下去，发现只有一条路，畅通无阻。</p><p>当访问到结点三的时候我们发现<strong>结点3有一条通向结点2的路</strong>，则此时我们称<strong>结点3回溯到结点2</strong>。我们还发现dfn[2]&lt;dfn[3]，即结点2在dfs中比结点3先被访问。此时我们在dfs回溯的过程中令：low[3] = dfn[2];    low[4] = dfn[2];    low[5] = dfn[2];即令回溯路上的所有点的low数组都赋值为结点2的dfs序。</p><p>由此我们经历了一遍tarjan的简化步骤，我们能发现low数组的取值为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">low[u] = min(</span><br><span class="line">    dfn[u],<span class="comment">//1.</span></span><br><span class="line">    dfn[v],<span class="comment">//2.</span></span><br><span class="line">    low[v]<span class="comment">//3.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>low数组初始化时为当前结点的dfs序，即low[u] = dfn[u];</li><li>这里的v是边（u, v）中的v，和上图中边（3, 2）类似。当发现能回溯到的结点dfs序小于自身dfs序时更新low的值</li><li>这里的（u, v）和上图中的（4, 3）类似。dfs回溯过程中时发现前面结点的low值小于自身的low值时，更新自身low值</li></ol><p>从图中可看出2， 5， 4， 3四个结点为一个环，环是最简单的强连通分量，所以2， 5， 4， 3为一个强连通分量。而单独一个结点我们也将他看成一个强连通分量，因此图中有三个强连通分量：（1）（6）（2，4，5，3）</p><p>从中我们观察出1， 6， 2的dfn值和low值相同，所以当dfn[u]==low[u]时，它就是一个强连通分量在dfs树中的起始节点</p><h3 id="tarjan算法伪代码讲解"><a href="#tarjan算法伪代码讲解" class="headerlink" title="tarjan算法伪代码讲解"></a>tarjan算法伪代码讲解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tarjan(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index<span class="comment">//1.</span></span><br><span class="line">    Stack.push(u)<span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">for</span> each (u, v) in E<span class="comment">//3.</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)<span class="comment">//4.</span></span><br><span class="line">            tarjan(v)<span class="comment">//dfs</span></span><br><span class="line">            Low[u] = min(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)<span class="comment">//5.</span></span><br><span class="line">            Low[u] = min(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])<span class="comment">//6.</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop<span class="comment">//7.</span></span><br><span class="line">            print v</span><br><span class="line">        until (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为结点u初始化dfn和low的值为dfs时的访问顺序，index为全局变量</li><li>将结点u压入栈中</li><li>遍历结点u的每一条边</li><li>如果没访问过</li><li>如果v在栈中</li><li>上面讲过，当dfn[u]==low[u]时，该节点为强连通分量根结点</li><li>将栈顶元素出栈，直到栈顶元素为u时，u出栈，则此次出栈的一系列元素为一个强连通分量</li></ol><p><img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190909205034.png" alt="TIM截图20190909205034" style="zoom:50%;"></p><p>（6-&gt;1的箭头画反了，应该时1-&gt;6）</p><ol><li>从结点1开始：dfn[1] = low[1] = 1; 结点1进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918114703.png" alt="TIM截图20190918114703" style="zoom: 50%;"></li><li>1-&gt;6：dfn[6] = low[6] = 2; 结点6进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918114957.png" alt="TIM截图20190918114957" style="zoom:50%;">结点6没有出边，无法dfs，发现dfn[6]==low[6]，栈顶元素出栈，栈顶元素正好时结点6，无需继续出栈，则结点6自己为一个单独的强联通分量。</li><li>1-&gt;2：dfn[2] = low[2] = 3；结点2进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918115433.png" alt="TIM截图20190918115433" style="zoom: 50%;">结点2有出边且为访问，开始dfs。</li><li>2-&gt;5：dfn[5] = low[5] = 4；结点5进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918120132.png" alt="TIM截图20190918120132" style="zoom: 50%;">结点5有出边且未访问，继续dfs</li><li>5-&gt;4：dfn[4] = low[4] = 5；结点4进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918120345.png" alt="TIM截图20190918120345" style="zoom:50%;">结点4有未访问的出边，继续dfs</li><li>4-&gt;3：dfn[3] = low[3] = 6；结点3进栈<img src="/2019/09/02/tarjan求有向图的强连通分量/TIM截图20190918120518.png" alt="TIM截图20190918120518" style="zoom: 50%;">结点3有出边，但结点2已经访问过了，且结点2在栈里面，所以3可以回溯到结点2，可知dfn[2]=3, low[3]=6;  所以low[3] = dfn[2] = 3;</li><li>此时dfn[3]!=low[3]，所以不出栈。</li><li>当dfs回溯到5-&gt;4的时候，发现(low[4]=5) &gt; (low[3]=3)，所以low[4] = 3;    依此类推low[5]=3;且直到dfs回溯到结点2的时候才会进行出栈操作，因为2时强连通分量的根节点。</li><li>不难看出，依次出栈的时3、4、5、2，这四个结点为一个强连通分量</li><li>最后dfs回溯到最开始的入口，结点1出栈</li><li>由此的强连通分量有3个，分别是：（1）、（6）、（3，4，5，2）</li></ol><h2 id="tarjan算法模板"><a href="#tarjan算法模板" class="headerlink" title="tarjan算法模板"></a>tarjan算法模板</h2><h3 id="链式前向星模板"><a href="#链式前向星模板" class="headerlink" title="链式前向星模板"></a>链式前向星模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> net;</span><br><span class="line">     <span class="keyword">int</span> to;</span><br><span class="line">     <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_dege</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], belong[maxn];<span class="comment">//2.</span></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>, Bcnt;<span class="comment">//3.</span></span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    s.push(u);instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=edge[i].net)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;<span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bcnt = index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//4.</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])<span class="comment">//5.</span></span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>head[u]记得初始化，初始化为-1。</li><li>belong数组值相同的结点属于同一个强连通分量。</li><li>Bcnt用于划分强连通分量</li><li>要从每个结点都进行一次tarjan，否则有些不可达结点就无法划分强联通分量，n为结点数</li><li>dfn数组初始化为0，当dfn[u]的值不为0的时候则说明被访问过了</li></ol><h3 id="邻接矩阵模板"><a href="#邻接矩阵模板" class="headerlink" title="邻接矩阵模板"></a>邻接矩阵模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mp[maxn][maxn];<span class="comment">//1.</span></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>, Bcnt;</span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    s.push(u);instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;n; v++)<span class="comment">//2.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[u][v]==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bcnt = index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>邻接矩阵，当值为-1时表示不连通</li><li>n为结点数</li></ol><h3 id="邻接表模板"><a href="#邻接表模板" class="headerlink" title="邻接表模板"></a>邻接表模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>, Bcnt;</span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[u].push_back(make_pair(w, v));</span><br><span class="line">    <span class="comment">//G[v].push_back(make_pair(w, u));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    s.push(u);instack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[u].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i].second;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//2.</span></span><br><span class="line">        G[i].clear();</span><br><span class="line">    Bcnt = index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用vector和pair实现邻接表，pair的first为路径权重，pair的second为另一端结点</li><li>初始化邻接表</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HDU1269"><a href="#HDU1269" class="headerlink" title="HDU1269"></a><a href="https://vjudge.net/problem/HDU-1269" target="_blank" rel="noopener">HDU1269</a></h3><p>题意：给你一个图，让你判断这个图是不是一整个强连通分量</p><p>题解：没什么可说的，tarjan模板题。需要注意的是有的能给的图只有点没有边，所以结束条件需要时m和n同时为0时才行。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, net;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn];</span><br><span class="line"><span class="keyword">bool</span> instack[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = index = Bcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(instack, <span class="number">0</span>, <span class="keyword">sizeof</span> instack);</span><br><span class="line">    <span class="built_in">memset</span>(belong, <span class="number">0</span>, <span class="keyword">sizeof</span> belong);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    s.push(u);</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i!=<span class="number">-1</span>; i=edge[i].net)</span><br><span class="line">    &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&lt;low[u])   low[u] = low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt;n &gt;&gt;m &amp;&amp; n+m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt;u &gt;&gt;v;</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">                tarjan(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = belong[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(belong[i]!=flag)</span><br><span class="line">                f = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!f) <span class="built_in">cout</span> &lt;&lt;<span class="string">"No"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt;<span class="string">"Yes"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU1827"><a href="#HDU1827" class="headerlink" title="HDU1827"></a><a href="https://vjudge.net/problem/HDU-1827" target="_blank" rel="noopener">HDU1827</a></h3><p>题意：给你一些人的联系方式，但是这种联系方式时有向的，即x可以联系y不代表y可以联系到x，其实就是有向图。也给出你联系每个人的花费，如果可以让别人帮忙联系，就可以不需要花费话费。求最少需要联系多少人和花费多少话费。</p><p>题解：这道题没有那么直接，但是也能看出和强连通分量有关。这道题要求的是<strong>没有入边的强连通分量的个数</strong>，并且求出这些没有入边的强联通分量中花费最小的人。为什么是没有入边的强连通分量而不是强连通分量，因为有如入边的强联通分量可以被其他人通知到，就不需要你再亲自通知了。（一开始我理解成强连通分量的个数了(&gt;_&lt;) ）这题要用scnaf和printf，不能用cin和cout，数据量大，会超时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, net;</span><br><span class="line">&#125; edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn], fee[maxn], cost[maxn], ans;</span><br><span class="line"><span class="keyword">bool</span> instack[maxn], in[maxn];<span class="comment">//1.</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = index = ans = Bcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(instack, <span class="number">0</span>, <span class="keyword">sizeof</span> instack);</span><br><span class="line">    <span class="built_in">memset</span>(belong, <span class="number">0</span>, <span class="keyword">sizeof</span> belong);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</span><br><span class="line">        cost[i]=INF;</span><br><span class="line">    <span class="built_in">memset</span>(fee, <span class="number">0</span>, <span class="keyword">sizeof</span> fee);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++index;</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    s.push(u);</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i!=<span class="number">-1</span>; i=edge[i].net)</span><br><span class="line">    &#123;</span><br><span class="line">        v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&lt;low[u])</span><br><span class="line">                low[u] = low[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instack[v] &amp;&amp; dfn[v]&lt;low[u])</span><br><span class="line">            low[u] = dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        Bcnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            belong[v] = Bcnt;</span><br><span class="line">            instack[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fee[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            addedge(u, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">                tarjan(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=Bcnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//2.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i]; j!=<span class="number">-1</span>; j=edge[j].net)</span><br><span class="line">                <span class="keyword">if</span>(belong[i]!=belong[edge[j].to] &amp;&amp; !in[belong[edge[j].to]])</span><br><span class="line">                &#123;</span><br><span class="line">                    in[belong[edge[j].to]] = <span class="literal">true</span>;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">if</span>(!in[belong[i]])</span><br><span class="line">                cost[belong[i]] = min(cost[belong[i]], fee[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Bcnt; i++)</span><br><span class="line">            <span class="keyword">if</span>(!in[i])</span><br><span class="line">                ans+=cost[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, cnt, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>in数组表示该强连通分量是否有入边，为true则有，false则没有。</li><li>这个for循环求出有入边的强连通分量，即看看每个点的入边是否和自己在同一个强连通分量中即可。cnt为没有入边的个数。</li><li>求出没有入边的强连通分量中的最小花费，cost[i]代表第i个强连通分量的花费</li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://www.byvoid.com/zhs/blog/scc-tarjan" target="_blank" rel="noopener">BYVoid有向图强连通分量的tarjan算法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tarjan求有向图的强连通分量&quot;&gt;&lt;a href=&quot;#tarjan求有向图的强连通分量&quot; class=&quot;headerlink&quot; title=&quot;tarjan求有向图的强连通分量&quot;&gt;&lt;/a&gt;tarjan求有向图的强连通分量&lt;/h1&gt;&lt;p&gt;tarjan到底是念“塔进”
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>差分约束</title>
    <link href="http://yoursite.com/2019/08/01/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2019/08/01/差分约束/</id>
    <published>2019-08-01T06:53:59.000Z</published>
    <updated>2019-09-18T16:39:24.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h1><p><strong>差分约束系统</strong>是求解一组特殊的不等式组的方法。</p><h2 id="差分约束举例"><a href="#差分约束举例" class="headerlink" title="差分约束举例"></a>差分约束举例</h2><p>差分约束是有n个变量和m个不等式组成的。其中每个不等式都是形如：$x_i-x_j \leq b_k(i,j\in[1,n], k\in[1,m])$  或 $x_i-x_j \geq b_k(i,j\in[1,n], k\in[1,m])$ 。</p><p>其中x为n个变量，b为m个不等式右边的值，用b的值来约束x的差称为差分约束。求一组解：$x_1=a_1,\quad x_2=a_2,\cdots x_n=a_n$使得所有约束条件(即m个不等式)均成立，则称差分约束有解，否则无解。</p><p>例如：<br>$$<br>(1)x_1-x_3 \leq 5;\quad<br>(2)x_3-x_5 \leq 4;\quad<br>$$<br>$$<br>(3)x_3-x_2 \leq 1;\quad<br>(4)x_1-x_5 \leq 10;\quad<br>(5)x_2-x_5 \leq 2;\quad<br>$$</p><p>观察$ x_1-x_5 $的关系，有如下三种关系：</p><ol><li>(4)                $x_1-x_5 \leq 10$</li><li>(1)+(2)         $x_1-x_5 \leq 9$</li><li>(1)+(3)+(5)   $x_1-x_5 \leq 8 $</li></ol><p>因为要满足所有等式的关系，所以取其中最大的3.$x_1-x_5 \leq 8$  因为8一定小于9和10嘛，如果$x_1-x_5$小于等于8了，那他们一定小于等于9和10。</p><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p>观察可发现 $x_i-x_j \leq b_k$ 可转换为：$x_i \leq b_k+x_j$ 。与求最短路公式中的dis[j]&lt;dis[i]+w[i, j]非常相似，那差分约束问题是不是也可以转化成最短路问题来求解呢？肯定是可以的！先来看个例子：</p><p><img src="/2019/08/01/差分约束/TIM截图20190801164055-1564649436098.png" alt="TIM截图20190801164055" style="zoom:50%;"></p><p>仔细观察图中可发现总共有三条路径：</p><ol><li>5 -&gt; 1                      长度为10</li><li>5 -&gt; 3 -&gt; 1               长度为9</li><li>5 -&gt; 2 -&gt; 3 -&gt; 1        长度为8</li></ol><p>很容易发现从5到1的最短路径是8。那为什么求差分约束问题能和最短路问题联系到一起呢？此处要先了解最短路知识，不懂的可以看一看我前面写的博客：1.<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/" target="_blank" rel="noopener">dijkstra</a>    2.<a href="https://zhangzef.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/" target="_blank" rel="noopener">SPFA</a>    3.<a href="https://zhangzef.com/2019/07/30/%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd/" target="_blank" rel="noopener">Floyd</a></p><h2 id="差分约束和最短路问题"><a href="#差分约束和最短路问题" class="headerlink" title="差分约束和最短路问题"></a>差分约束和最短路问题</h2><p>对于每个不等式$x_i-x_j \leq b_k$，我们都从结点j向结点i连一条长度为$b_k$的有向边。此时再看上面给出的那些不等式所转化成的图，是否和给出的图一样呢，最后求解的答案也一样。那么我们将差分约束问题转化成最短路问题，由最短路知识可知，当图中存在可达到的负环时，最短路一定无解。所以可以用SPFA来判断该差分约束问题是否有解。</p><p>这时候就有一个问题了，在最短路中有些点是不可达的，当遇到不可达的负环用SPFA一定判断不出来，但此时差分约束却是无解的。怎么办呢？有两种方法，其实本质都是一样的：</p><ol><li>我们新定义一个结点，可以是$x_0$，让它向所有其它结点连一条边，让这些边的权值为0。因为SPFA是一个bfs的过程(有些题目需要把spfa改成dfs的形式，但是并不影响它访问的结点个数，只是访问顺序不一样)，所以从这个结点出发一定能到达所有结点，而且不会影响结果的正确性。</li><li>第二种方法就比较暴力了，现在问题是有的结点访问不到怎么办，spfa又是求单源最短路，那我们直接一个for循环，每个结点都当一次源点，求n次单源最短路，这样就能访问到所有结点了。</li></ol><p>两种方法的时间复杂度我不太会分析，但是感觉好像差不多一样的。</p><h2 id="变化技巧"><a href="#变化技巧" class="headerlink" title="变化技巧"></a>变化技巧</h2><h3 id="不等式转化"><a href="#不等式转化" class="headerlink" title="不等式转化"></a>不等式转化</h3><p>有时候题中会给出三种不等式，但是求最短路只能有一种不等式，这时候我们就可以把其他不等式变化成一样的不等式，进而转化成图。</p><table><thead><tr><th style="text-align:center">题意</th><th style="text-align:center">转化</th><th style="text-align:center">连边</th></tr></thead><tbody><tr><td style="text-align:center">$x_i-x_j \leq b_k$</td><td style="text-align:center">$x_i-x_j \leq b_k$</td><td style="text-align:center">add(j, i, $b_k$)</td></tr><tr><td style="text-align:center">$x_i-x_j \geq b_k $</td><td style="text-align:center">$x_j-x_i \leq -b_k$</td><td style="text-align:center">add(i, j, -$b_k$)</td></tr><tr><td style="text-align:center">$x_i=x_j$</td><td style="text-align:center">$x_i-x_j \leq 0$, $x_j-x_i \leq 0$</td><td style="text-align:center">add(i, j, 0), add(j, i, 0)</td></tr></tbody></table><h3 id="最短路与最长路和差分约束的关系"><a href="#最短路与最长路和差分约束的关系" class="headerlink" title="最短路与最长路和差分约束的关系"></a>最短路与最长路和差分约束的关系</h3><p>有最短路了一定也有最长路，那他们和差分约束有什么关系呢？</p><p>当我们要求差分约束的最小值时，一定希望所有不等式都是大于等于号，这样求出来的一定是最小值。但是当我们有m个约束条件（即不等式），我们想要满足所有大于等于的不等式，我们一定得找到所有$ b_k $中最大的那一个，这样如果满足了最大的那个$ b_k $不等式，其他的大于等于不等式也一定都满足了。所以求$x_i-x_j$的最小值，就是求图中的最长路。所以，<strong>求最长路就是求差分约束中的最小值</strong>。求最长路的时候有正环则无解。</p><p>同理<strong>求最短路就是求差分约束的最大值</strong>。求最短路的时候有负环则无解。</p><p>什么？你问我最长路怎么求？把最短路算法中的小于号改成大于号不就行了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.org/problem/P1993" target="_blank" rel="noopener">洛谷P1993</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://oi-wiki.org" target="_blank" rel="noopener">OI-WiKi（一个算法竞赛的百科）</a></li><li><a href="https://zh.wikipedia.org/wiki/差分约束系统" target="_blank" rel="noopener">维基百科：差分约束系统</a></li><li><a href="https://www.luogu.org/blog/user33173/solution-p1993" target="_blank" rel="noopener">P1993小K的农场 题解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;差分约束&quot;&gt;&lt;a href=&quot;#差分约束&quot; class=&quot;headerlink&quot; title=&quot;差分约束&quot;&gt;&lt;/a&gt;差分约束&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;差分约束系统&lt;/strong&gt;是求解一组特殊的不等式组的方法。&lt;/p&gt;
&lt;h2 id=&quot;差分约束举例&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图的边存储--链式前向星</title>
    <link href="http://yoursite.com/2019/07/31/%E5%9B%BE%E7%9A%84%E8%BE%B9%E5%AD%98%E5%82%A8-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
    <id>http://yoursite.com/2019/07/31/图的边存储-链式前向星/</id>
    <published>2019-07-31T11:01:36.000Z</published>
    <updated>2019-09-18T16:39:36.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的边存储–链式前向星"><a href="#图的边存储–链式前向星" class="headerlink" title="图的边存储–链式前向星"></a>图的边存储–链式前向星</h1><p>链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感觉好像没怎么听说过。还要定义结构体，而且需要辅助数组，感觉挺麻烦的。还不如直接用STL的vector+pair定义的邻接表好用。但是后来发现大家写SPFA的时候都用的链式前向星，感觉还是写个博客学习一下吧，以前都没听说过，太菜了。。。</p><p>边存储结构存的都是有向边！！！</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>适用范围广，基本上所有图论的题都能用链式前向星来存储。</li><li>存储效率高，像邻接表一样不会存储不存在的边</li><li>可以用来替代邻接表，用vector实现邻接表好像容易爆内存(看别人说的)好像也确实，vector在容量不够时会重新开辟一个两倍于原来大小的数组。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>邻接表的缺点它都有，<ul><li>无法判断重边(必须遍历查找)</li><li>无法操作某个特定的边(必须遍历查找)</li></ul></li><li>相对于邻接矩阵来说不容易实现和理解</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> net;<span class="comment">//1.</span></span><br><span class="line">     <span class="keyword">int</span> to;</span><br><span class="line">     <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt=<span class="number">0</span>;<span class="comment">//2.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_dege</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].net = head[u];<span class="comment">//3.</span></span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=edge[i].net)<span class="comment">//4.</span></span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>net是next，有时候定义next可能会和系统关键字重复，所以定义为net。net指向当前边的出发结点的下一条边在edge数组中的下标。SPFA是一个bfs的过程，进行广搜时会先遍历某个顶点的所有出边，net即指向当前结点的下一条出边。to即当前边的尾结点。w即权重。</li><li>head[u]即存储u结点的第一个出边在edge数组中的下标。cnt即记录当前存储到edge数组的第几位了，用来设置数组下标。</li><li>链式前向星是反着存储的，即先输入的边存在后面，有些类似于栈，后进先出。当a的第一条出边存入edge数组中，net等于head[u]，即-1。(所有head初始化为-1，-1表示没有边存入)之后head[u]被赋值为cnt，即刚输入的那条边在edge数组中的下标。当a的第二条边存入edge数组时，net等于head[u]，此时head[u]存的是上一次存储以u为出边的边在edge数组中的下标。每次head[u]存储的都是上一个u的边，所以遍历的时候是先遍历最后输入u的边。</li><li>链式前向星遍历结点u所有出边的方法，当等于-1时表示没有下一条边了，遍历结束。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="/2019/07/31/图的边存储-链式前向星/TIM截图20190731195256.png" alt="TIM截图20190731195256" style="zoom:50%;"></p><p>输入顺序为：</p><table><thead><tr><th style="text-align:left">u = 0</th><th style="text-align:left">v = 1</th></tr></thead><tbody><tr><td style="text-align:left">u = 1</td><td style="text-align:left">v = 3</td></tr><tr><td style="text-align:left">u = 0</td><td style="text-align:left">v = 2</td></tr><tr><td style="text-align:left">u = 2</td><td style="text-align:left">v = 3</td></tr><tr><td style="text-align:left">u = 1</td><td style="text-align:left">v = 2</td></tr><tr><td style="text-align:left">u = 3</td><td style="text-align:left">v = 4</td></tr><tr><td style="text-align:left">u = 4</td><td style="text-align:left">v = 2</td></tr></tbody></table><p>手动模拟一下</p><table><thead><tr><th>edge[0].to = 1</th><th>edge[0].net = -1</th><th>head[0] = 0</th><th>cnt = 0</th></tr></thead><tbody><tr><td>edge[1].to = 3</td><td>edge[1].net = -1</td><td>head[1] = 0</td><td>cnt = 1</td></tr><tr><td>edge[2].to = 2</td><td>edge[2].net = 0</td><td>head[0] = 2</td><td>cnt = 2</td></tr><tr><td>edge[3].to = 3</td><td>edge[3].net = -1</td><td>head[2] = 0</td><td>cnt = 3</td></tr><tr><td>edge[4].to = 2</td><td>edge[4].net = 0</td><td>head[1] = 4</td><td>cnt = 4</td></tr><tr><td>edge[5].to = 4</td><td>edge[5].net = -1</td><td>head[3] = 5</td><td>cnt = 5</td></tr><tr><td>edge[6].to = 2</td><td>edge[6].net = -1</td><td>head[4] = 6</td><td>cnt = 6</td></tr></tbody></table><p>上图中0的出边有两条，在edge数组中的存储位置分别为0、2，最后head[0] = 2；当遍历以0为起点的边时，先从edge[2]开始遍历，可发现edge[2].net = 0;即以0为起点的最后一条边。可看出，遍历和输入顺序是相反的，但是并不影响结果。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/acdreamers/article/details/16902023(" target="_blank" rel="noopener">不知道为什么404了</a></li><li><a href="https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F" target="_blank" rel="noopener">ACM图论之存图方式</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图的边存储–链式前向星&quot;&gt;&lt;a href=&quot;#图的边存储–链式前向星&quot; class=&quot;headerlink&quot; title=&quot;图的边存储–链式前向星&quot;&gt;&lt;/a&gt;图的边存储–链式前向星&lt;/h1&gt;&lt;p&gt;链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="图的存储" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>最短路--Floyd</title>
    <link href="http://yoursite.com/2019/07/30/%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd/"/>
    <id>http://yoursite.com/2019/07/30/最短路-Floyd/</id>
    <published>2019-07-30T07:42:20.000Z</published>
    <updated>2019-07-30T08:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–Floyd"><a href="#最短路–Floyd" class="headerlink" title="最短路–Floyd"></a>最短路–Floyd</h1><p>Floyd是用来求全局任意两点之间的最短路的。</p><p>Floyd很好理解，依次用每个点去松弛其它所有边，感觉没什么好讲的。理解了<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">dijkstra</a>和<a href="https://zhangzef.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/#more" target="_blank" rel="noopener">SPFA</a>之后，感觉Floyd就很简单易懂了，直接上代码吧。</p><p>时间复杂度：O(n^3)</p><p>空间复杂度：O(n^2)</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)<span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            d[i][j] = min(d[i][j], d[i][k]+d[k][j]);</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>其中n为图中顶点个数，k依次枚举所有顶点去松弛其它所有边。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–Floyd&quot;&gt;&lt;a href=&quot;#最短路–Floyd&quot; class=&quot;headerlink&quot; title=&quot;最短路–Floyd&quot;&gt;&lt;/a&gt;最短路–Floyd&lt;/h1&gt;&lt;p&gt;Floyd是用来求全局任意两点之间的最短路的。&lt;/p&gt;
&lt;p&gt;Floyd很好理解，依
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路--SPFA</title>
    <link href="http://yoursite.com/2019/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/"/>
    <id>http://yoursite.com/2019/07/26/最短路-SPFA/</id>
    <published>2019-07-26T09:20:52.000Z</published>
    <updated>2019-09-18T16:40:00.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–SPFA"><a href="#最短路–SPFA" class="headerlink" title="最短路–SPFA"></a>最短路–SPFA</h1><p>SPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijkstra，但是有一种特殊的数据专门来卡SPFA，只能让dijkstra过，SPFA过不去，那就是网格图，我稍后会讲为什么网格图可以卡掉SPFA。</p><p>但是为什么SPFA跑不过dijkstra，大家还要用SPFA？因为dijkstra只能计算不带负环的图，当图中出现负环，dijkstra就会一直卡在负环里出不来了。如果不太懂可以看一看我的上一篇博客：<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">Dijkstra</a> </p><p>当图中存在可到达的负环，则该图一定不存在最短路，因为负环可以一直当做最短路来松弛其他边，那么最短路就能无限小，所以不存在最短路。</p><p><img src="/2019/07/26/最短路-SPFA/TIM截图20190726174245.png" alt="TIM截图20190726174245" style="zoom:50%;"></p><p>SPFA也是用来求<strong>单源</strong>最短路，它当然也不能在存在可达负环的时候计算最短路，但是他有一个神奇的功能：<strong>判断图中是否存在可达负环</strong>。</p><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a><strong>Bellman-Ford</strong></h2><p>SPFA是Bellman-Ford的队列优化，在一般情况下比Bellman-Ford快很多。这里介绍Bellman-Ford是希望可以更好地理解SPFA，因为两者本质区别不大。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>算法总共跑n-1轮就能确定所有点的最短路。总共有n个点，x1, x2, x3, x4…xn，其中x1为源点，第一轮一定可以确定离源点最近的点的最短路，即x2的最短路。依次类推，如果图中不存在负环，则一定能在n-1轮推出所有点的最短路。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>下面把敦爷讲课的时候的代码放出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n<span class="number">-1</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]]+w[i])</span><br><span class="line">dis[v[i]] = dis[u[i]]+w[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>观察上面的Bellman-Ford可发现，当dis[u]没有被更新的时候，它依然会用dis[u]去松弛其它边，这样就做了很多冗余的操作，我们用一个队列来优化它，就是当有一个点被更新了，如果这个点没在队列里面，就把它放到队列里面去。这样一个点很久没有被更新过的话，就不会用它去更新其它边。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>此处建议先看懂我的上一篇博客：<a href="https://zhangzef.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/#more" target="_blank" rel="noopener">Dijkstra</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[maxn], viscnt[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[s].push_back(make_pair(w, t));<span class="comment">//2.</span></span><br><span class="line">    G[t].push_back(make_pair(w, s));<span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//4.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span><span class="comment">//5.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//6.</span></span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = (i==s)?<span class="number">0</span>:INF;</span><br><span class="line">        inq[i] = <span class="literal">false</span>;</span><br><span class="line">        viscnt[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(make_pair(dis[s], s));<span class="comment">//7.</span></span><br><span class="line">    inq[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.front();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;<span class="comment">//8.</span></span><br><span class="line">        q.pop();</span><br><span class="line">        inq[x] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(viscnt[x]++&gt;n)<span class="comment">//9.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[x].size(); i++)<span class="comment">//10.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=G[x][i].second, w=G[x][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dis[x]+w&lt;dis[y])<span class="comment">//11.</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x]+w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(make_pair(dis[y], y));</span><br><span class="line">                    inq[y] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>viscnt[i]用来计数第<strong>i</strong>个点被更新了几次，如果更新次数超过n，则说明图中存在负环。inq[i]表示第<strong>i</strong>个点是否在队列里面。存放pair的vector用来存放边和边权，G[i] [j]存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边。G[i] [j].second存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的另一个端点。G[i] [j].first存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的权重。maxn为自己定义的常量。</li><li>将边添加至vector中，s、w、t 说明同上。</li><li>无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。</li><li>初始化vector，清空所有先前加入的边。</li><li>SPFA当图中<strong>存在负环</strong>时返回<strong>true</strong>，<strong>不存在</strong>时返回<strong>false</strong>。</li><li>初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。viscnt和inq设为0和false。</li><li>将源点压入队列。inq[s]设为true。</li><li>依次取队首元素。取出后inq[i]设为false。</li><li>每次访问一个点，令这个点的viscnt++，当这个点的访问次数超过n次，则说明图中存在负环。</li><li>依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重。</li><li>进行松弛操作，如果某个点松弛操作成功，则把它压入队列。</li></ol><h2 id="如何卡SPFA"><a href="#如何卡SPFA" class="headerlink" title="如何卡SPFA"></a>如何卡SPFA</h2><p>因为SPFA没回更新的时候用的是一条边去更新，被更新过的点入队。</p><p>比如说我们有一条链</p><p><img src="/2019/07/26/最短路-SPFA/TIM截图20190727121644.png" alt="TIM截图20190727121644" style="zoom:50%;"></p><p>当我们用边0-1去更新后面所有边之后，如果边0-1又被更新，则后面的所有边都要被依次再更新一遍。</p><p>这样SPFA的时间复杂度就会变得非常高</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://www.cometoj.com/live/10810/replay?replayId=1&amp;page=1" target="_blank" rel="noopener">2019ccpc夏令营敦爷讲的图论</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–SPFA&quot;&gt;&lt;a href=&quot;#最短路–SPFA&quot; class=&quot;headerlink&quot; title=&quot;最短路–SPFA&quot;&gt;&lt;/a&gt;最短路–SPFA&lt;/h1&gt;&lt;p&gt;SPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijks
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>最短路--Dijkstra</title>
    <link href="http://yoursite.com/2019/07/25/%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra/"/>
    <id>http://yoursite.com/2019/07/25/最短路--Dijkstra/</id>
    <published>2019-07-25T06:47:11.000Z</published>
    <updated>2019-09-18T16:39:42.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路–Dijkstra"><a href="#最短路–Dijkstra" class="headerlink" title="最短路–Dijkstra"></a>最短路–Dijkstra</h1><p>Dijkstra是单源最短路算法，用于求<strong>正权</strong>图源点到每个顶点的最短路。Dijkstra用到了一些BFS的思想</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>初始化dis数组和vis数组。<ol><li>dis[i]表示源点到第<strong>i</strong>个点的距离，初始化为INF，表示无穷大。（INF为自己定义）</li><li>vis[i]数组表示第<strong>i</strong>个点的最短路是否用于处理过未求出最短路的点。（当用优先队列的时候则不用vis数组）</li></ol></li><li>找出当前最短dis[i]，并且vis[i]为false的点。如果找不到，则最短路求解完成，算法结束。</li><li>令vis[i]为true，表示已经使用过该最短路处理其dis[i]，防止重复使用。依次遍历其余所有点，令dis[j] = min(dis[j], dis[i]+w[i] [j])<ol><li>w[i] [j]表示点i到点j的距离。这一步表示源点到<strong>i</strong>加上<strong>i</strong>到<strong>j</strong>的距离和源点到<strong>j</strong>的距离哪个小。</li></ol></li></ol><p><img src="/2019/07/25/最短路--Dijkstra/TIM截图20190725160913.png" alt="TIM截图20190725160913" style="zoom:50%;"></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="邻接矩阵版"><a href="#邻接矩阵版" class="headerlink" title="邻接矩阵版"></a>邻接矩阵版</h3><p>时间复杂度为O(n*n)    n为顶点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span><span class="comment">//1.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//2.</span></span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = w[s][i];</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//3.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = INF, x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)<span class="comment">//4.</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j]&lt;mn)</span><br><span class="line">            &#123;</span><br><span class="line">                mn = dis[j];</span><br><span class="line">                x=j;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mn==INF)<span class="comment">//5.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        vis[x] = <span class="literal">true</span>;<span class="comment">//6.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            dis[j] = min(dis[j], dis[x]+w[x][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>n为结点个数，s为源点。</li><li>初始化dis数组和vis数组</li><li>依次遍历每个结点</li><li>找出当先未使用过的最短路，并把下标存入x</li><li>如果全部使用过则算法结束</li><li>vis[x]设为true，比较dis[j]和dis[x]+w[x] [j]的大小</li></ol><h3 id="优先队列版"><a href="#优先队列版" class="headerlink" title="优先队列版"></a>优先队列版</h3><p>用优先队列优化dijkstra大部分时间优于普通版，但是在完全图时普通版更好。</p><p>时间复杂度：O((m+n)logm)    其中n为顶点数，m为边数。所以当完全图时普通版更好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; G[maxn];<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_eage</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G[s].push_back(make_pair(w, t));<span class="comment">//2.</span></span><br><span class="line">    G[t].push_back(make_pair(w, s));<span class="comment">//3.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//4.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//5.</span></span><br><span class="line">        dis[i] = (i==s)?<span class="number">0</span>:INF;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;,</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;,</span><br><span class="line">    greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;<span class="comment">//6.</span></span><br><span class="line">    q.push(make_pair(dis[s], s));<span class="comment">//7.</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = q.top();</span><br><span class="line">        <span class="keyword">int</span> x = p.second;<span class="comment">//8.</span></span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[x].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y=G[x][i].second, w=G[x][i].first;<span class="comment">//9.</span></span><br><span class="line">            <span class="keyword">if</span>(dis[x]+w&lt;dis[y])<span class="comment">//10.</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x]+w;</span><br><span class="line">                q.push(make_pair(dis[y], y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>存放pair的vector用来存放边和边权，因为pair比较大小是first优先，所以pair的first放的是权重。G[i] [j]存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边。G[i] [j].second存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的另一个端点。G[i] [j].first存放的是和结点<strong>i</strong>相连的第<strong>j</strong>条边的权重。maxn为自己定义的常量。</li><li>将边添加至vector中，s、w、t 说明同上。</li><li>无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。</li><li>初始化vector，清空所有先前加入的边。</li><li>初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。</li><li>定义优先队列，第一个参数为数据类型，比较pair类型，pair的first优先。第二个参数为存储容器，和先前存边的vector定义相同。第三个参数表示小顶堆(greater为小顶堆，less为大顶堆)。</li><li>将源点压入队列。</li><li>x存放当前未访问过的权值最小边的一端结点编号。</li><li>依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重</li><li>该步骤通邻接矩阵dijkstra相似</li></ol><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p>hdoj1874</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/78922648" target="_blank" rel="noopener">夜深人静写算法（四）- 最短路和差分约束</a></li><li><a href="https://blog.csdn.net/sinat_30062549/article/details/47025277" target="_blank" rel="noopener">dijkstra几大模板（这里面的优先队列模板好像时错的，我只参考了他的stl用法）</a></li><li><a href="https://blog.csdn.net/u013569304/article/details/51147000" target="_blank" rel="noopener">C++ pair的比较大小</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路–Dijkstra&quot;&gt;&lt;a href=&quot;#最短路–Dijkstra&quot; class=&quot;headerlink&quot; title=&quot;最短路–Dijkstra&quot;&gt;&lt;/a&gt;最短路–Dijkstra&lt;/h1&gt;&lt;p&gt;Dijkstra是单源最短路算法，用于求&lt;strong&gt;正权
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/07/22/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/07/22/并查集/</id>
    <published>2019-07-22T02:33:37.000Z</published>
    <updated>2019-09-18T16:39:17.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种树型数据结构，用于<strong>查找</strong>不相交的<strong>子集</strong>，并将他们<strong>合并</strong>在一起，简称并查集。并查集分为<strong>拆分</strong>、<strong>查找</strong>和<strong>合并</strong>三个操作。</p><h2 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li>pre数组记录所有结点的前驱结点，根节点的前驱结点是它自己</li><li>find函数先找到x的根节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span>];<span class="comment">//1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//2.</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )<span class="comment">//3.</span></span><br><span class="line">          r=pre[r];</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>记录前驱结点</li><li>查找根节点</li><li>找到根节点 r</li></ol><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ol><li><p>join函数先找到两个变量的根节点</p><ul><li><p>​    如果他们相同则说明两个变量在同一个集合中</p></li><li><p>​    如果不同则将其中一个根节点设置为另外一个根节点的前驱</p></li></ul></li></ol><p><img src="/2019/07/22/并查集/TIM截图20190722191109.png" alt="TIM截图20190722191109" style="zoom:50%;"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//1.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        pre[fx ]=fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>判断x y是否连通，如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起。</li></ol><h2 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h2><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>路径压缩是在寻找根结点的过程中，将子集中所有的点的前驱设置为根结点。</p><p>为什么要进行路径压缩呢？因为在并查集合并过程中，他有可能变成一个<strong>单链表</strong>，这样每次寻找根结点要遍历子集中所有的结点。进行路径压缩之后，每次寻找根结点只需访问他的父结点就可找到根结点。</p><p><img src="/2019/07/22/并查集/TIM截图20190722182225.png" alt="TIM截图20190722182225"></p><p>优化后的<strong><u>find</u></strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                            </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                   </span><br><span class="line">          r=pre[r];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )<span class="comment">//1.</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ];<span class="comment">//2.</span></span><br><span class="line">         pre[ i ]= r ;<span class="comment">//3.</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>路径压缩</li><li>在改变上级之前用临时变量j记录下他的值</li><li>把上级改为根节点</li></ol><h3 id="按秩-Rank-合并"><a href="#按秩-Rank-合并" class="headerlink" title="按秩(Rank)合并"></a>按秩(Rank)合并</h3><p>按秩合并就是在合并过程中将元素所在深度小的集合合并到元素所在深度大的集合</p><p>为什么要按秩合并呢？因为如果将元素深度大的集合合并到小的集合，那么合并后的集合深度则等于较大的深度加一。如果将深度小的集合合并到深度大的集合，则合并后的集合深度不变。</p><p><img src="/2019/07/22/并查集/TIM截图20190722182240.png" alt="TIM截图20190722182240"></p><p>优化后的<strong><u>join</u></strong>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(rank[fx]&gt;rank[fy])<span class="comment">//1.</span></span><br><span class="line">        pre[fy] = pre[fx];<span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre[fx] = fy;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx]==rank[fy])<span class="comment">//3.</span></span><br><span class="line">            rank[fy]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>rank数组为当前结点秩的值</li><li>只需要比较根结点的rank值就够了</li><li>修改时也只用修改根结点的rank值</li></ol><h2 id="并查集的精简实现"><a href="#并查集的精简实现" class="headerlink" title="并查集的精简实现"></a>并查集的精简实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) pre[i]=i; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> pre[x]=x?x:pre[x]=get(pre[x]); &#125;<span class="comment">//1.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; pre[get(x)] = get[y]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//2.</span></span><br><span class="line">    pre[rank[find(x)&gt;rank[find(y)?find(y):find(x)] = pre[rank[find(x)&gt;rank[find(y)?find(x):find(y)];</span><br><span class="line"><span class="keyword">if</span>(rank[find(x)]==rank[find(y)]) rank[find(y)]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><ol><li>根结点的pre为0。</li><li>带秩合并，还没验证，不能确定对错。</li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="noopener">维基百科：并查集</a></li><li><a href="https://blog.csdn.net/liujian20150808/article/details/50848646" target="_blank" rel="noopener">并查集详解——图文解说，简单易懂（转）</a></li><li><a href="https://www.acwing.com/blog/content/97/" target="_blank" rel="noopener">并查集笔记&amp;模板</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;并查集是一种树型数据结构，用于&lt;strong&gt;查找&lt;/strong&gt;不相交的&lt;strong&gt;子集&lt;/strong&gt;，并将他们&lt;str
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>可以评论了！！！</title>
    <link href="http://yoursite.com/2018/11/02/%E5%8F%AF%E4%BB%A5%E8%AF%84%E8%AE%BA%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2018/11/02/可以评论了！！！/</id>
    <published>2018-11-01T16:35:39.000Z</published>
    <updated>2018-11-01T16:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来吐槽吧"><a href="#来吐槽吧" class="headerlink" title="来吐槽吧"></a>来吐槽吧</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;来吐槽吧&quot;&gt;&lt;a href=&quot;#来吐槽吧&quot; class=&quot;headerlink&quot; title=&quot;来吐槽吧&quot;&gt;&lt;/a&gt;来吐槽吧&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello Word!</title>
    <link href="http://yoursite.com/2018/11/01/Hello-Word/"/>
    <id>http://yoursite.com/2018/11/01/Hello-Word/</id>
    <published>2018-10-31T17:17:19.000Z</published>
    <updated>2018-10-31T17:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HELLO-WORD"><a href="#HELLO-WORD" class="headerlink" title="HELLO WORD!!!"></a>HELLO WORD!!!</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HELLO-WORD&quot;&gt;&lt;a href=&quot;#HELLO-WORD&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORD!!!&quot;&gt;&lt;/a&gt;HELLO WORD!!!&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
