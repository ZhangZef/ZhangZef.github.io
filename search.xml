<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kuangbin专题一--简单搜索]]></title>
    <url>%2F2019%2F09%2F19%2Fkuangbin%E4%B8%93%E9%A2%98%E4%B8%80-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[kuangbin专题一简单搜索tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁 kuangbin专题合集 ACM正确入门方式——数学lover 题目列表 POJ 1321 棋盘问题AC: 2018-07-17 23:54:31 POJ 2251 Dungeon MasterAC: 2019-09-19 18:32:04 POJ 3278 Catch That Cow POJ 3279 Fliptile POJ 1426 Find The Multiple POJ 3126 Prime Path POJ 3087 Shuffle’m Up POJ 3414 Pots FZU 2150 Fire Game UVA 11624 Fire! POJ 3984 迷宫问题 HDU 1241 Oil Deposits HDU 1495 非常可乐 HDU 2612 Find a way POJ1321 棋盘问题题意就是在棋盘上放棋子，放的时候不能同行同列，和八皇后问题类似，只不过空白的地方不能放。这是我去年暑假acm训练时写的，现在已经忘了当时咋写的了，看着自己WA了好多发，太菜了。。。dfs时记得复原。 题解dfs吧，没什么可说的，八皇后模板题。好烦啊，POJ不能用万能头文件。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;string.h&gt;typedef long long ll;const int INF = 1 &lt;&lt; 30;const int maxn = 1e5;using namespace std;int n, m, ans;char pan[10][10];bool vis[10];int cnt;void dfs(int l)&#123; if(cnt == m) &#123; ans++; return; &#125; else if(l&gt;=n) return; else &#123; for(int i=0; i&lt;n; i++) if(pan[l][i]=='#' &amp;&amp; !vis[i]) &#123; cnt++; vis[i]=1; dfs(l+1); vis[i]=0; cnt--; &#125; dfs(l+1); &#125; return;&#125;int main()&#123; //ios::sync_with_stdio(0), cin.tie(0); while(cin &gt;&gt;n &gt;&gt;m) &#123; if(n==-1 &amp;&amp; m==-1) break; memset(vis, 0, sizeof(vis)); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++) cin &gt;&gt;pan[i][j]; ans = cnt = 0; dfs(0); cout &lt;&lt;ans &lt;&lt;endl; &#125; return 0;&#125; POJ2251 Dungeon Master题意一个3D迷宫，总共六个方向，上下左右前后。有的地方不能走有的能走，给出起点终点，问你能不能走到终点，如果能的话应该是求用时最短的吧（题目中没说，一开始用dfsWA了，后来看别人都用bfs才发现是不是要求最短路）。没移动一次要花费一分钟。 题解bfs，一开始用bfs一直内存超限，快给我郁闷死了。。。要把走过的点用#堵上，防止多余的结点入队列。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 31;struct node&#123; int x, y, z, step;&#125;;node make_node(int x, int y, int z, int step)&#123; node a; a.x = x, a.y = y, a.z = z, a.step=step; return a;&#125;int main()&#123; int l, r, c; char mp[maxn][maxn][maxn]; int dx[6]= &#123;1, -1, 0, 0, 0, 0&#125;; int dy[6]= &#123;0, 0, 1, -1, 0, 0&#125;; int dz[6]= &#123;0, 0, 0, 0, 1, -1&#125;; while (cin &gt;&gt;l &gt;&gt;r &gt;&gt;c &amp;&amp; l+r+c) &#123; int x, y, z; queue&lt;node&gt; q; for(int i=0; i&lt;l; i++) &#123; for(int j=0; j&lt;r; j++) for(int k=0; k&lt;c; k++) &#123; cin &gt;&gt;mp[i][j][k]; if(mp[i][j][k]=='S') q.push(make_node(i, j, k, 0)); if(mp[i][j][k]=='E') &#123; x = i; y = j; z = k; &#125; &#125; getchar(); &#125; bool flag = false; while(!q.empty()) &#123; node a = q.front(); q.pop(); if(a.x==x &amp;&amp; a.y==y &amp;&amp; a.z==z) &#123; flag = true; cout &lt;&lt;"Escaped in "&lt;&lt;a.step &lt;&lt;" minute(s)." &lt;&lt;endl; break; &#125; for (int i = 0; i &lt; 6; ++i) &#123; if(mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]]!='#') if(a.x+dx[i]&gt;=0 &amp;&amp; a.x+dx[i]&lt;l &amp;&amp; a.y+dy[i]&gt;=0 &amp;&amp; a.y+dy[i]&lt;r &amp;&amp; a.z+dz[i]&gt;=0 &amp;&amp; a.z+dz[i]&lt;c) &#123; q.push(make_node(a.x+dx[i], a.y+dy[i], a.z+dz[i], a.step+1)); mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]] = '#'; &#125; &#125; &#125; if(flag) continue; else cout &lt;&lt;"Trapped!" &lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tarjan求有向图的强连通分量]]></title>
    <url>%2F2019%2F09%2F02%2Ftarjan%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%2F</url>
    <content type="text"><![CDATA[tarjan求有向图的强连通分量tarjan到底是念“塔进”还是“塔扬”。好像大多数人都念“塔进”，但是英语好像是念“塔扬”。胡扯结束。。。 这个tarjan算法求的是有向图中的强连通分量，并将他们合并。 强连通分量（如果会可以直接看tarjan部分）那什么是强连通分量呢？强连通嘛，就是图中任意两点能相互到达。那强连通分量就是一个图中的强连通子图。 环是最简单的强连通分量： 那你如果从1出发，只要转一圈就能经过所有点。 强连通分量不等于环，还有一些复杂的强连通分量，例如完全图： 很明显能看出从图中一点出发，可到达其他任意一个点。 tarjan算法先上时间复杂度：O(N+M) （其中N和M分别为点数和边数） tarjan算法是通过对图的dfs来找出其中的强连通分量，并分类。（需掌握dfs的思想并且能熟练运用） dfn数组和low数组讲解这里给出tarjan算法中两个重要数组的定义： ​ dfn[u]：表示当前结点i在dfs算法中第几个被访问的的点。 ​ low[u]：表示当前结点i能回溯到的最小dfs序结点，dfs序即dfn[u]的值。 （6-&gt;1的箭头画反了，应该时1-&gt;6） 当从结点1开始dfs时，假设优先向下访问：dfn[1] = 1; dfn[6] = 2;因为第一个访问的时结点1，所以它的dfs序是1，第二个访问的是结点6，所以它的dfs序时2。访问完结点6发现没有路了，则开始访问结点1的下一条出边。 开始访问结点2，刚刚访问的结点6是第二个访问的结点，所以结点2是第三个访问的结点，即它的dfs序为3：dfn[2] = 3; dfn[5] = 4; dfn[4] = 5; dfn[3] = 6;我们顺着结点2依次访问下去，发现只有一条路，畅通无阻。 当访问到结点三的时候我们发现结点3有一条通向结点2的路，则此时我们称结点3回溯到结点2。我们还发现dfn[2]&lt;dfn[3]，即结点2在dfs中比结点3先被访问。此时我们在dfs回溯的过程中令：low[3] = dfn[2]; low[4] = dfn[2]; low[5] = dfn[2];即令回溯路上的所有点的low数组都赋值为结点2的dfs序。 由此我们经历了一遍tarjan的简化步骤，我们能发现low数组的取值为： 12345low[u] = min( dfn[u],//1. dfn[v],//2. low[v]//3.) low数组初始化时为当前结点的dfs序，即low[u] = dfn[u]; 这里的v是边（u, v）中的v，和上图中边（3, 2）类似。当发现能回溯到的结点dfs序小于自身dfs序时更新low的值 这里的（u, v）和上图中的（4, 3）类似。dfs回溯过程中时发现前面结点的low值小于自身的low值时，更新自身low值 从图中可看出2， 5， 4， 3四个结点为一个环，环是最简单的强连通分量，所以2， 5， 4， 3为一个强连通分量。而单独一个结点我们也将他看成一个强连通分量，因此图中有三个强连通分量：（1）（6）（2，4，5，3） 从中我们观察出1， 6， 2的dfn值和low值相同，所以当dfn[u]==low[u]时，它就是一个强连通分量在dfs树中的起始节点 tarjan算法伪代码讲解12345678910111213141516tarjan(u)&#123; DFN[u]=Low[u]=++Index//1. Stack.push(u)//2. for each (u, v) in E//3. if (v is not visted)//4. tarjan(v)//dfs Low[u] = min(Low[u], Low[v]) else if (v in S)//5. Low[u] = min(Low[u], DFN[v]) if (DFN[u] == Low[u])//6. repeat v = S.pop//7. print v until (u== v)&#125; 为结点u初始化dfn和low的值为dfs时的访问顺序，index为全局变量 将结点u压入栈中 遍历结点u的每一条边 如果没访问过 如果v在栈中 上面讲过，当dfn[u]==low[u]时，该节点为强连通分量根结点 将栈顶元素出栈，直到栈顶元素为u时，u出栈，则此次出栈的一系列元素为一个强连通分量 （6-&gt;1的箭头画反了，应该时1-&gt;6） 从结点1开始：dfn[1] = low[1] = 1; 结点1进栈 1-&gt;6：dfn[6] = low[6] = 2; 结点6进栈结点6没有出边，无法dfs，发现dfn[6]==low[6]，栈顶元素出栈，栈顶元素正好时结点6，无需继续出栈，则结点6自己为一个单独的强联通分量。 1-&gt;2：dfn[2] = low[2] = 3；结点2进栈结点2有出边且为访问，开始dfs。 2-&gt;5：dfn[5] = low[5] = 4；结点5进栈结点5有出边且未访问，继续dfs 5-&gt;4：dfn[4] = low[4] = 5；结点4进栈结点4有未访问的出边，继续dfs 4-&gt;3：dfn[3] = low[3] = 6；结点3进栈结点3有出边，但结点2已经访问过了，且结点2在栈里面，所以3可以回溯到结点2，可知dfn[2]=3, low[3]=6; 所以low[3] = dfn[2] = 3; 此时dfn[3]!=low[3]，所以不出栈。 当dfs回溯到5-&gt;4的时候，发现(low[4]=5) &gt; (low[3]=3)，所以low[4] = 3; 依此类推low[5]=3;且直到dfs回溯到结点2的时候才会进行出栈操作，因为2时强连通分量的根节点。 不难看出，依次出栈的时3、4、5、2，这四个结点为一个强连通分量 最后dfs回溯到最开始的入口，结点1出栈 由此的强连通分量有3个，分别是：（1）、（6）、（3，4，5，2） tarjan算法模板链式前向星模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859struct Edge&#123; int net; int to; int w;&#125;edge[maxn];int head[maxn], cnt=0;//1.void add_dege(int u, int v, int w)&#123; edge[cnt].to = v; edge[cnt].net = head[u]; edge[cnt].w = w; head[u] = cnt++;&#125;int dfn[maxn], low[maxn], belong[maxn];//2.int index=0, Bcnt;//3.bool instack[maxn];stack&lt;int&gt; s;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; s.push(u);instack[u] = true; for(int i=head[u]; i!=-1; i=edge[i].net) &#123; int v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[v], low[u]); &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++;int v; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(v!=u); &#125;&#125;void solve()&#123; Bcnt = index = 0; memset(dfn, 0, sizeof dfn); while(!s.empty())s.pop(); for(int i=0; i&lt;n; i++)//4. if(!dfn[i])//5. tarjan(i);&#125; head[u]记得初始化，初始化为-1。 belong数组值相同的结点属于同一个强连通分量。 Bcnt用于划分强连通分量 要从每个结点都进行一次tarjan，否则有些不可达结点就无法划分强联通分量，n为结点数 dfn数组初始化为0，当dfn[u]的值不为0的时候则说明被访问过了 邻接矩阵模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546int mp[maxn][maxn];//1.int dfn[maxn], low[maxn], belong[maxn];int index=0, Bcnt;bool instack[maxn];stack&lt;int&gt; s;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; s.push(u);instack[u] = true; for(int v=0; v&lt;n; v++)//2. &#123; if(mp[u][v]==-1) continue; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[v], low[u]); &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; int v; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(v!=u); &#125;&#125;void solve()&#123; Bcnt = index = 0; memset(dfn, 0, sizeof dfn); while(!s.empty())s.pop(); for(int i=0; i&lt;n; i++) if(!dfn[i]) tarjan(i);&#125; 邻接矩阵，当值为-1时表示不连通 n为结点数 邻接表模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253vector&lt;pair&lt;int, int&gt; &gt; G[maxn];//1.int dfn[maxn], low[maxn], belong[maxn];int index=0, Bcnt;bool instack[maxn];stack&lt;int&gt; s;void add_eage(int u, int v, int w)&#123; G[u].push_back(make_pair(w, v)); //G[v].push_back(make_pair(w, u));&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; s.push(u);instack[u] = true; for(int i=0; i&lt;G[u].size(); i++) &#123; int v = G[u][i].second; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[v], low[u]); &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; int v; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(v!=u); &#125;&#125;void solve()&#123; for(int i=0; i&lt;n; i++)//2. G[i].clear(); Bcnt = index = 0; memset(dfn, 0, sizeof dfn); while(!s.empty())s.pop(); for(int i=0; i&lt;n; i++) if(!dfn[i]) tarjan(i);&#125; 用vector和pair实现邻接表，pair的first为路径权重，pair的second为另一端结点 初始化邻接表 例题HDU1269题意：给你一个图，让你判断这个图是不是一整个强连通分量 题解：没什么可说的，tarjan模板题。需要注意的是有的能给的图只有点没有边，所以结束条件需要时m和n同时为0时才行。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;struct Edge&#123; int to, net;&#125;edge[maxn];int head[maxn], cnt=0;int dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn];bool instack[maxn];stack&lt;int&gt; s;void addedge(int u, int v)&#123; edge[cnt].to = v; edge[cnt].net = head[u]; head[u] = cnt++;&#125;void init()&#123; cnt = index = Bcnt = 0; memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(head, -1, sizeof head); memset(instack, 0, sizeof instack); memset(belong, 0, sizeof belong); while(!s.empty())s.pop();&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; instack[u] = true; s.push(u); int v; for(int i = head[u]; i!=-1; i=edge[i].net) &#123; v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); if(low[v]&lt;low[u]) low[u] = low[v]; &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(u!=v); &#125;&#125;int main()&#123; while(cin &gt;&gt;n &gt;&gt;m &amp;&amp; n+m) &#123; init(); for(int i=0; i&lt;m; i++) &#123; int u, v; cin &gt;&gt;u &gt;&gt;v; addedge(u, v); &#125; for(int i=1; i&lt;=n; i++) if(!dfn[i]) tarjan(i); int flag = belong[1]; bool f = true; for(int i=1; i&lt;=n; i++) if(belong[i]!=flag) f = false; if(!f) cout &lt;&lt;"No" &lt;&lt;endl; else cout &lt;&lt;"Yes" &lt;&lt;endl; &#125; return 0;&#125; HDU1827题意：给你一些人的联系方式，但是这种联系方式时有向的，即x可以联系y不代表y可以联系到x，其实就是有向图。也给出你联系每个人的花费，如果可以让别人帮忙联系，就可以不需要花费话费。求最少需要联系多少人和花费多少话费。 题解：这道题没有那么直接，但是也能看出和强连通分量有关。这道题要求的是没有入边的强连通分量的个数，并且求出这些没有入边的强联通分量中花费最小的人。为什么是没有入边的强连通分量而不是强连通分量，因为有如入边的强联通分量可以被其他人通知到，就不需要你再亲自通知了。（一开始我理解成强连通分量的个数了(&gt;_&lt;) ）这题要用scnaf和printf，不能用cin和cout，数据量大，会超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;const int INF = 1&lt;&lt;30;struct Edge&#123; int to, net;&#125; edge[maxn];int head[maxn], cnt=0;int dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn], fee[maxn], cost[maxn], ans;bool instack[maxn], in[maxn];//1.stack&lt;int&gt; s;void addedge(int u, int v)&#123; edge[cnt].to = v; edge[cnt].net = head[u]; head[u] = cnt++;&#125;void init()&#123; cnt = index = ans = Bcnt = 0; memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(head, -1, sizeof head); memset(instack, 0, sizeof instack); memset(belong, 0, sizeof belong); memset(in, 0, sizeof in); for(int i=0; i&lt;maxn; i++) cost[i]=INF; memset(fee, 0, sizeof fee); while(!s.empty()) s.pop();&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; instack[u] = true; s.push(u); int v; for(int i = head[u]; i!=-1; i=edge[i].net) &#123; v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); if(low[v]&lt;low[u]) low[u] = low[v]; &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125; while(u!=v); &#125;&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(); for(int i=1; i&lt;=n; i++) scanf("%d", &amp;fee[i]); for(int i=0; i&lt;m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; for(int i=1; i&lt;=n; i++) if(!dfn[i]) tarjan(i); int cnt=Bcnt; for(int i=1; i&lt;=n; i++)//2. for(int j=head[i]; j!=-1; j=edge[j].net) if(belong[i]!=belong[edge[j].to] &amp;&amp; !in[belong[edge[j].to]]) &#123; in[belong[edge[j].to]] = true; cnt--; &#125; for(int i=1; i&lt;=n; i++)//3. if(!in[belong[i]]) cost[belong[i]] = min(cost[belong[i]], fee[i]); for(int i=1; i&lt;=Bcnt; i++) if(!in[i]) ans+=cost[i]; printf("%d %d\n", cnt, ans); &#125; return 0;&#125; in数组表示该强连通分量是否有入边，为true则有，false则没有。 这个for循环求出有入边的强连通分量，即看看每个点的入边是否和自己在同一个强连通分量中即可。cnt为没有入边的个数。 求出没有入边的强连通分量中的最小花费，cost[i]代表第i个强连通分量的花费 参考： BYVoid有向图强连通分量的tarjan算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[差分约束差分约束系统是求解一组特殊的不等式组的方法。 差分约束举例差分约束是有n个变量和m个不等式组成的。其中每个不等式都是形如：$x_i-x_j \leq b_k(i,j\in[1,n], k\in[1,m])$ 或 $x_i-x_j \geq b_k(i,j\in[1,n], k\in[1,m])$ 。 其中x为n个变量，b为m个不等式右边的值，用b的值来约束x的差称为差分约束。求一组解：$x_1=a_1,\quad x_2=a_2,\cdots x_n=a_n$使得所有约束条件(即m个不等式)均成立，则称差分约束有解，否则无解。 例如：$$(1)x_1-x_3 \leq 5;\quad(2)x_3-x_5 \leq 4;\quad$$$$(3)x_3-x_2 \leq 1;\quad(4)x_1-x_5 \leq 10;\quad(5)x_2-x_5 \leq 2;\quad$$ 观察$ x_1-x_5 $的关系，有如下三种关系： (4) $x_1-x_5 \leq 10$ (1)+(2) $x_1-x_5 \leq 9$ (1)+(3)+(5) $x_1-x_5 \leq 8 $ 因为要满足所有等式的关系，所以取其中最大的3.$x_1-x_5 \leq 8$ 因为8一定小于9和10嘛，如果$x_1-x_5$小于等于8了，那他们一定小于等于9和10。 最短路问题观察可发现 $x_i-x_j \leq b_k$ 可转换为：$x_i \leq b_k+x_j$ 。与求最短路公式中的dis[j]&lt;dis[i]+w[i, j]非常相似，那差分约束问题是不是也可以转化成最短路问题来求解呢？肯定是可以的！先来看个例子： 仔细观察图中可发现总共有三条路径： 5 -&gt; 1 长度为10 5 -&gt; 3 -&gt; 1 长度为9 5 -&gt; 2 -&gt; 3 -&gt; 1 长度为8 很容易发现从5到1的最短路径是8。那为什么求差分约束问题能和最短路问题联系到一起呢？此处要先了解最短路知识，不懂的可以看一看我前面写的博客：1.dijkstra 2.SPFA 3.Floyd 差分约束和最短路问题对于每个不等式$x_i-x_j \leq b_k$，我们都从结点j向结点i连一条长度为$b_k$的有向边。此时再看上面给出的那些不等式所转化成的图，是否和给出的图一样呢，最后求解的答案也一样。那么我们将差分约束问题转化成最短路问题，由最短路知识可知，当图中存在可达到的负环时，最短路一定无解。所以可以用SPFA来判断该差分约束问题是否有解。 这时候就有一个问题了，在最短路中有些点是不可达的，当遇到不可达的负环用SPFA一定判断不出来，但此时差分约束却是无解的。怎么办呢？有两种方法，其实本质都是一样的： 我们新定义一个结点，可以是$x_0$，让它向所有其它结点连一条边，让这些边的权值为0。因为SPFA是一个bfs的过程(有些题目需要把spfa改成dfs的形式，但是并不影响它访问的结点个数，只是访问顺序不一样)，所以从这个结点出发一定能到达所有结点，而且不会影响结果的正确性。 第二种方法就比较暴力了，现在问题是有的结点访问不到怎么办，spfa又是求单源最短路，那我们直接一个for循环，每个结点都当一次源点，求n次单源最短路，这样就能访问到所有结点了。 两种方法的时间复杂度我不太会分析，但是感觉好像差不多一样的。 变化技巧不等式转化有时候题中会给出三种不等式，但是求最短路只能有一种不等式，这时候我们就可以把其他不等式变化成一样的不等式，进而转化成图。 题意 转化 连边 $x_i-x_j \leq b_k$ $x_i-x_j \leq b_k$ add(j, i, $b_k$) $x_i-x_j \geq b_k $ $x_j-x_i \leq -b_k$ add(i, j, -$b_k$) $x_i=x_j$ $x_i-x_j \leq 0$, $x_j-x_i \leq 0$ add(i, j, 0), add(j, i, 0) 最短路与最长路和差分约束的关系有最短路了一定也有最长路，那他们和差分约束有什么关系呢？ 当我们要求差分约束的最小值时，一定希望所有不等式都是大于等于号，这样求出来的一定是最小值。但是当我们有m个约束条件（即不等式），我们想要满足所有大于等于的不等式，我们一定得找到所有$ b_k $中最大的那一个，这样如果满足了最大的那个$ b_k $不等式，其他的大于等于不等式也一定都满足了。所以求$x_i-x_j$的最小值，就是求图中的最长路。所以，求最长路就是求差分约束中的最小值。求最长路的时候有正环则无解。 同理求最短路就是求差分约束的最大值。求最短路的时候有负环则无解。 什么？你问我最长路怎么求？把最短路算法中的小于号改成大于号不就行了。 例题洛谷P1993 参考 夜深人静写算法（四）- 最短路和差分约束 OI-WiKi（一个算法竞赛的百科） 维基百科：差分约束系统 P1993小K的农场 题解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的边存储--链式前向星]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9B%BE%E7%9A%84%E8%BE%B9%E5%AD%98%E5%82%A8-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%2F</url>
    <content type="text"><![CDATA[图的边存储–链式前向星链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感觉好像没怎么听说过。还要定义结构体，而且需要辅助数组，感觉挺麻烦的。还不如直接用STL的vector+pair定义的邻接表好用。但是后来发现大家写SPFA的时候都用的链式前向星，感觉还是写个博客学习一下吧，以前都没听说过，太菜了。。。 边存储结构存的都是有向边！！！ 优缺点优点 适用范围广，基本上所有图论的题都能用链式前向星来存储。 存储效率高，像邻接表一样不会存储不存在的边 可以用来替代邻接表，用vector实现邻接表好像容易爆内存(看别人说的)好像也确实，vector在容量不够时会重新开辟一个两倍于原来大小的数组。 缺点 邻接表的缺点它都有， 无法判断重边(必须遍历查找) 无法操作某个特定的边(必须遍历查找) 相对于邻接矩阵来说不容易实现和理解 代码实现1234567891011121314151617struct Edge&#123; int net;//1. int to; int w;&#125;edge[maxn];int head[maxn], cnt=0;//2.void add_dege(int u, int v, int w)&#123; edge[cnt].to = v; edge[cnt].net = head[u];//3. edge[cnt].w = w; head[u] = cnt++;&#125;for(int i=head[u]; i!=-1; i=edge[i].net)//4. 注释： net是next，有时候定义next可能会和系统关键字重复，所以定义为net。net指向当前边的出发结点的下一条边在edge数组中的下标。SPFA是一个bfs的过程，进行广搜时会先遍历某个顶点的所有出边，net即指向当前结点的下一条出边。to即当前边的尾结点。w即权重。 head[u]即存储u结点的第一个出边在edge数组中的下标。cnt即记录当前存储到edge数组的第几位了，用来设置数组下标。 链式前向星是反着存储的，即先输入的边存在后面，有些类似于栈，后进先出。当a的第一条出边存入edge数组中，net等于head[u]，即-1。(所有head初始化为-1，-1表示没有边存入)之后head[u]被赋值为cnt，即刚输入的那条边在edge数组中的下标。当a的第二条边存入edge数组时，net等于head[u]，此时head[u]存的是上一次存储以u为出边的边在edge数组中的下标。每次head[u]存储的都是上一个u的边，所以遍历的时候是先遍历最后输入u的边。 链式前向星遍历结点u所有出边的方法，当等于-1时表示没有下一条边了，遍历结束。 举例 输入顺序为： u = 0 v = 1 u = 1 v = 3 u = 0 v = 2 u = 2 v = 3 u = 1 v = 2 u = 3 v = 4 u = 4 v = 2 手动模拟一下 edge[0].to = 1 edge[0].net = -1 head[0] = 0 cnt = 0 edge[1].to = 3 edge[1].net = -1 head[1] = 0 cnt = 1 edge[2].to = 2 edge[2].net = 0 head[0] = 2 cnt = 2 edge[3].to = 3 edge[3].net = -1 head[2] = 0 cnt = 3 edge[4].to = 2 edge[4].net = 0 head[1] = 4 cnt = 4 edge[5].to = 4 edge[5].net = -1 head[3] = 5 cnt = 5 edge[6].to = 2 edge[6].net = -1 head[4] = 6 cnt = 6 上图中0的出边有两条，在edge数组中的存储位置分别为0、2，最后head[0] = 2；当遍历以0为起点的边时，先从edge[2]开始遍历，可发现edge[2].net = 0;即以0为起点的最后一条边。可看出，遍历和输入顺序是相反的，但是并不影响结果。 参考 不知道为什么404了 ACM图论之存图方式]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图的存储</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路--Floyd]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd%2F</url>
    <content type="text"><![CDATA[最短路–FloydFloyd是用来求全局任意两点之间的最短路的。 Floyd很好理解，依次用每个点去松弛其它所有边，感觉没什么好讲的。理解了dijkstra和SPFA之后，感觉Floyd就很简单易懂了，直接上代码吧。 时间复杂度：O(n^3) 空间复杂度：O(n^2) 算法实现1234for(int k=0; k&lt;n; k++)//1. for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); 注释： 其中n为图中顶点个数，k依次枚举所有顶点去松弛其它所有边。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路--SPFA]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA%2F</url>
    <content type="text"><![CDATA[最短路–SPFASPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijkstra，但是有一种特殊的数据专门来卡SPFA，只能让dijkstra过，SPFA过不去，那就是网格图，我稍后会讲为什么网格图可以卡掉SPFA。 但是为什么SPFA跑不过dijkstra，大家还要用SPFA？因为dijkstra只能计算不带负环的图，当图中出现负环，dijkstra就会一直卡在负环里出不来了。如果不太懂可以看一看我的上一篇博客：Dijkstra 当图中存在可到达的负环，则该图一定不存在最短路，因为负环可以一直当做最短路来松弛其他边，那么最短路就能无限小，所以不存在最短路。 SPFA也是用来求单源最短路，它当然也不能在存在可达负环的时候计算最短路，但是他有一个神奇的功能：判断图中是否存在可达负环。 Bellman-FordSPFA是Bellman-Ford的队列优化，在一般情况下比Bellman-Ford快很多。这里介绍Bellman-Ford是希望可以更好地理解SPFA，因为两者本质区别不大。 算法步骤算法总共跑n-1轮就能确定所有点的最短路。总共有n个点，x1, x2, x3, x4…xn，其中x1为源点，第一轮一定可以确定离源点最近的点的最短路，即x2的最短路。依次类推，如果图中不存在负环，则一定能在n-1轮推出所有点的最短路。 算法实现下面把敦爷讲课的时候的代码放出来： 12345678for(int k=1; k&lt;=n-1; k++)&#123; for(int i=1; i&lt;m; i++) &#123; if(dis[v[i]] &gt; dis[u[i]]+w[i]) dis[v[i]] = dis[u[i]]+w[i] &#125;&#125; SPFA观察上面的Bellman-Ford可发现，当dis[u]没有被更新的时候，它依然会用dis[u]去松弛其它边，这样就做了很多冗余的操作，我们用一个队列来优化它，就是当有一个点被更新了，如果这个点没在队列里面，就把它放到队列里面去。这样一个点很久没有被更新过的话，就不会用它去更新其它边。 算法实现此处建议先看懂我的上一篇博客：Dijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int dis[maxn], viscnt[maxn];bool inq[maxn];vector&lt;pair&lt;int, int&gt; &gt; G[maxn];//1.void add_eage(int s, int t, int w)&#123; G[s].push_back(make_pair(w, t));//2. G[t].push_back(make_pair(w, s));//3.&#125;void init(int n)//4.&#123; for(int i=0; i&lt;n; i++) G[i].clear();&#125;bool SPFA(int n, int s)//5.&#123; for(int i=0; i&lt;n; i++)//6. &#123; dis[i] = (i==s)?0:INF; inq[i] = false; viscnt[i] = 0; &#125; queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(dis[s], s));//7. inq[s] = true; while(!q.empty()) &#123; pair&lt;int, int&gt; p = q.front(); int x = p.second;//8. q.pop(); inq[x] = false; if(viscnt[x]++&gt;n)//9. return true; for(int i=0; i&lt;G[x].size(); i++)//10. &#123; int y=G[x][i].second, w=G[x][i].first; if(dis[x]+w&lt;dis[y])//11. &#123; dis[y] = dis[x]+w; if(!inq[y]) &#123; q.push(make_pair(dis[y], y)); inq[y] = true; &#125; &#125; &#125; &#125; return false;&#125; 注释： viscnt[i]用来计数第i个点被更新了几次，如果更新次数超过n，则说明图中存在负环。inq[i]表示第i个点是否在队列里面。存放pair的vector用来存放边和边权，G[i] [j]存放的是和结点i相连的第j条边。G[i] [j].second存放的是和结点i相连的第j条边的另一个端点。G[i] [j].first存放的是和结点i相连的第j条边的权重。maxn为自己定义的常量。 将边添加至vector中，s、w、t 说明同上。 无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。 初始化vector，清空所有先前加入的边。 SPFA当图中存在负环时返回true，不存在时返回false。 初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。viscnt和inq设为0和false。 将源点压入队列。inq[s]设为true。 依次取队首元素。取出后inq[i]设为false。 每次访问一个点，令这个点的viscnt++，当这个点的访问次数超过n次，则说明图中存在负环。 依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重。 进行松弛操作，如果某个点松弛操作成功，则把它压入队列。 如何卡SPFA因为SPFA没回更新的时候用的是一条边去更新，被更新过的点入队。 比如说我们有一条链 当我们用边0-1去更新后面所有边之后，如果边0-1又被更新，则后面的所有边都要被依次再更新一遍。 这样SPFA的时间复杂度就会变得非常高 参考 夜深人静写算法（四）- 最短路和差分约束 2019ccpc夏令营敦爷讲的图论]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路--Dijkstra]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra%2F</url>
    <content type="text"><![CDATA[最短路–DijkstraDijkstra是单源最短路算法，用于求正权图源点到每个顶点的最短路。Dijkstra用到了一些BFS的思想 算法步骤 初始化dis数组和vis数组。 dis[i]表示源点到第i个点的距离，初始化为INF，表示无穷大。（INF为自己定义） vis[i]数组表示第i个点的最短路是否用于处理过未求出最短路的点。（当用优先队列的时候则不用vis数组） 找出当前最短dis[i]，并且vis[i]为false的点。如果找不到，则最短路求解完成，算法结束。 令vis[i]为true，表示已经使用过该最短路处理其dis[i]，防止重复使用。依次遍历其余所有点，令dis[j] = min(dis[j], dis[i]+w[i] [j]) w[i] [j]表示点i到点j的距离。这一步表示源点到i加上i到j的距离和源点到j的距离哪个小。 算法实现邻接矩阵版时间复杂度为O(n*n) n为顶点数 123456789101112131415161718192021222324252627void dijkstra(int n, int s)//1.&#123; for(int i=0; i&lt;n; i++)//2. &#123; dis[i] = w[s][i]; vis[i] = false; &#125; dis[s] = 0; for(int i=0; i&lt;n; i++)//3. &#123; int mn = INF, x; for(int j=0; j&lt;n; j++)//4. if(!vis[j] &amp;&amp; dis[j]&lt;mn) &#123; mn = dis[j]; x=j; &#125; if(mn==INF)//5. return; vis[x] = true;//6. for(int j=0; j&lt;n; j++) dis[j] = min(dis[j], dis[x]+w[x][j]); &#125;&#125; 注释： n为结点个数，s为源点。 初始化dis数组和vis数组 依次遍历每个结点 找出当先未使用过的最短路，并把下标存入x 如果全部使用过则算法结束 vis[x]设为true，比较dis[j]和dis[x]+w[x] [j]的大小 优先队列版用优先队列优化dijkstra大部分时间优于普通版，但是在完全图时普通版更好。 时间复杂度：O((m+n)logm) 其中n为顶点数，m为边数。所以当完全图时普通版更好。 1234567891011121314151617181920212223242526272829303132333435363738394041int dis[maxn];vector&lt;pair&lt;int, int&gt; &gt; G[maxn];//1.void add_eage(int s, int t, int w)&#123; G[s].push_back(make_pair(w, t));//2. G[t].push_back(make_pair(w, s));//3.&#125;void init(int n)//4.&#123; for(int i=0; i&lt;n; i++) G[i].clear();&#125;void dijkstra(int n, int s)&#123; for(int i=0; i&lt;n; i++)//5. dis[i] = (i==s)?0:INF; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q;//6. q.push(make_pair(dis[s], s));//7. while(!q.empty()) &#123; pair&lt;int, int&gt; p = q.top(); int x = p.second;//8. q.pop(); for(int i=0; i&lt;G[x].size(); i++) &#123; int y=G[x][i].second, w=G[x][i].first;//9. if(dis[x]+w&lt;dis[y])//10. &#123; dis[y] = dis[x]+w; q.push(make_pair(dis[y], y)); &#125; &#125; &#125;&#125; 注释： 存放pair的vector用来存放边和边权，因为pair比较大小是first优先，所以pair的first放的是权重。G[i] [j]存放的是和结点i相连的第j条边。G[i] [j].second存放的是和结点i相连的第j条边的另一个端点。G[i] [j].first存放的是和结点i相连的第j条边的权重。maxn为自己定义的常量。 将边添加至vector中，s、w、t 说明同上。 无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。 初始化vector，清空所有先前加入的边。 初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。 定义优先队列，第一个参数为数据类型，比较pair类型，pair的first优先。第二个参数为存储容器，和先前存边的vector定义相同。第三个参数表示小顶堆(greater为小顶堆，less为大顶堆)。 将源点压入队列。 x存放当前未访问过的权值最小边的一端结点编号。 依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重 该步骤通邻接矩阵dijkstra相似 模板例题hdoj1874 参考 夜深人静写算法（四）- 最短路和差分约束 dijkstra几大模板（这里面的优先队列模板好像时错的，我只参考了他的stl用法） C++ pair的比较大小]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集并查集是一种树型数据结构，用于查找不相交的子集，并将他们合并在一起，简称并查集。并查集分为拆分、查找和合并三个操作。 并查集查找 pre数组记录所有结点的前驱结点，根节点的前驱结点是它自己 find函数先找到x的根节点 12345678int pre[1000];//1.int find(int x)//2.&#123; int r=x; while ( pre[r] != r )//3. r=pre[r]; return r ;&#125; 注释： 记录前驱结点 查找根节点 找到根节点 r 合并 join函数先找到两个变量的根节点 ​ 如果他们相同则说明两个变量在同一个集合中 ​ 如果不同则将其中一个根节点设置为另外一个根节点的前驱 123456void join(int x,int y)//1.&#123; int fx=find(x),fy=find(y); if(fx!=fy) pre[fx ]=fy;&#125; 注释： 判断x y是否连通，如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起。 并查集的优化路径压缩路径压缩是在寻找根结点的过程中，将子集中所有的点的前驱设置为根结点。 为什么要进行路径压缩呢？因为在并查集合并过程中，他有可能变成一个单链表，这样每次寻找根结点要遍历子集中所有的结点。进行路径压缩之后，每次寻找根结点只需访问他的父结点就可找到根结点。 优化后的find函数： 12345678910111213141516int pre[1000 ];int find(int x) &#123; int r=x; while ( pre[r] != r ) r=pre[r]; int i=x , j ; while( i != r )//1. &#123; j = pre[ i ];//2. pre[ i ]= r ;//3. i=j; &#125; return r ;&#125; 注释： 路径压缩 在改变上级之前用临时变量j记录下他的值 把上级改为根节点 按秩(Rank)合并按秩合并就是在合并过程中将元素所在深度小的集合合并到元素所在深度大的集合 为什么要按秩合并呢？因为如果将元素深度大的集合合并到小的集合，那么合并后的集合深度则等于较大的深度加一。如果将深度小的集合合并到深度大的集合，则合并后的集合深度不变。 优化后的join函数： 12345678910111213void join(int x, int y)&#123; int fx=find(x),fy=find(y); if(rank[fx]&gt;rank[fy])//1. pre[fy] = pre[fx];//2. else &#123; pre[fx] = fy; if(rank[fx]==rank[fy])//3. rank[fy]++; &#125;&#125; 注释： rank数组为当前结点秩的值 只需要比较根结点的rank值就够了 修改时也只用修改根结点的rank值 并查集的精简实现12345678910void init(int n) &#123; for(int i=1; i&lt;=n; i++) pre[i]=i; &#125;int find(int x) &#123; return pre[x]=x?x:pre[x]=get(pre[x]); &#125;//1.void join(int x, int y) &#123; pre[get(x)] = get[y]; &#125;void join(int x, int y)&#123;//2. pre[rank[find(x)&gt;rank[find(y)?find(y):find(x)] = pre[rank[find(x)&gt;rank[find(y)?find(x):find(y)]; if(rank[find(x)]==rank[find(y)]) rank[find(y)]++;&#125; 注释： 根结点的pre为0。 带秩合并，还没验证，不能确定对错。 参考： 维基百科：并查集 并查集详解——图文解说，简单易懂（转） 并查集笔记&amp;模板]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可以评论了！！！]]></title>
    <url>%2F2018%2F11%2F02%2F%E5%8F%AF%E4%BB%A5%E8%AF%84%E8%AE%BA%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[来吐槽吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello Word!]]></title>
    <url>%2F2018%2F11%2F01%2FHello-Word%2F</url>
    <content type="text"><![CDATA[HELLO WORD!!!]]></content>
  </entry>
</search>
