<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客主页自定义排序]]></title>
    <url>%2F2020%2F02%2F15%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A1%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[参数讲解打开站点配置文件（也就是博客根目录下的_config.yml，不是主题配置文件，可以用notepad++来修改，比较轻便好用），用Ctrl+F搜索index_generator，下面那个参数order_by就是管理主页博客排序顺序的，默认为按date的降序排序。 自定义排序 将站点配置文件order_by的-date换成-top（top这个属性是自定义的，换成别的名字也可以，不过后续操作要一致）。 然后在每一篇博客博客的开头编写位置添加一个属性top，属性值用数字，主页的博客顺序就会从大到小降序排列，top值最大的博文就会被置顶。（注意：一定要在每一篇博客都添加一个top属性，老博客要一篇一篇修改，不然就会出现很奇怪的排序现象，亲测） 如果不想每次都重新创建top属性，可以直接修改博客模板：博客根目录下有一个scaffolds文件夹，里面的post.md就是创建新博客的模板，直接在这里添加一个top属性，以后hexo n时就自带top属性了。 按更新时间排序跟自定义排序类似 给每一篇博文都添加一个updated属性，每次更新博文的时候将这个属性更新一下，时间格式要和原来的date格式一样，可以直接用输入法输入（微软输入法不行，换了吧），然后将站点配置文件的order_by属性改成-updated就行了。（注意，如果你开启了在博客显示博文的更新时间，则网站里显示的更新于的时间则会和updated保持一致，因此每次更新博文后要手动更新一下updated的时间） 如果想修改博客模板，要修改scaffolds文件夹下的post.md文件成这样（就是每次创建时获取时间）：]]></content>
      <categories>
        <category>博客优化</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客自定义排序</tag>
        <tag>博客按更新时间排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[张泽锋and郭奕宏 一周年]]></title>
    <url>%2F2020%2F02%2F14%2F%E5%BC%A0%E6%B3%BD%E9%94%8Band%E9%83%AD%E5%A5%95%E5%AE%8F-%E4%B8%80%E5%91%A8%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[张泽锋and郭奕宏 正文今天是2月14号，2020年的情人节，对于所有情侣来说是一个特别的日子，对于我们来说这一天更是意义非凡。 经过一年时间的磕磕绊绊，我们有高兴，有悲伤，有时和睦，有时争吵，体验了情侣间最难相处的关系——异地恋。对于我们来说这一年有喜有忧，但是在你开心的时候所有的忧愁都好像一扫而空，只剩下晴空万里，可能在这里你就是那个晴天女孩吧。一篇博客记录不出我们期待见面时望眼欲穿的模样，也记录不下我们的喜怒哀乐，但是也许在将来追忆往事，会带来别样的感动。 2019年2月13日，我们俩相约见面，一起去看电影，像以往一样。当我们走出商场时，外面下起鹅毛大雪，但我们却不约而同地一起去吃饭。也许是天意降下了这场雪，寒冷的空气和雪花将我们的手握在了一起。晚上各自回家我们约好一起玩星露谷直到深夜。 2019年2月14日，当我从睡梦中醒来已是正午，下意识地拿起手机看时间，当看到你给我发来的消息时，我的心脏猛地一下砸向胸膛，大脑被震的一片空白。至今我还记得那句简单但是触动心灵的话，我想这可能就是砰然心动的感觉吧 Some of us get dipped in flat, some in satin, some in gloss. But every once in a while, you find someone who’s iridescent. And when you do,nothing will ever compare. 19年劳动节，我们终于有机会见面，我坐着火车不远万里从开封来到上海看你，我觉得那个劳动节可能是我有生以来过的最快乐的劳动节了吧。尽管几天的玩乐把我们累的筋疲力竭，但是时间总是会带走那些烦恼，留下美好的回忆。我们一起吃火锅小龙虾，一起喝奶茶看电影，一起坐过山车，一起观赏上海夜景。。。至今还记得你想在海底捞免费做美甲的小心愿，和看电影时我去上厕所你为我录下中间的部分，谷木游龙的惊险刺激和那三个小时的排队，还有嘉善那个令我永生难忘没放盐的小龙虾。五月这个即将立夏的季节里，留下了春天里最难忘的记忆。 大二下学期的期末考试，乘着我们俩考试的时间差，你从上海来到开封找我。前一天晚上我激动的难以入睡，直到夜里两三点才睡着。在开封没带你玩什么，不过带你吃了我们附近的名吃摇滚炒鸡，尝了开封不新鲜的小龙虾，喝了冰镇的深海炸弹，最遗憾的就是没能让你感受到化三驴肉汤的魅力。 大二暑假时，我在学校学习，你在家里。记得我们每天晚上都一起会玩星露谷。暑假的时间相对较松，我们断断续续见了许多次面。最让我愧疚的就是那个失败的生日，以后我一定会把那份遗憾补回来的，不过当你收到波妞时的那个反应像个乐坏了的孩子。原来我们经常一起玩胡闹厨房，知道你特别喜欢玩胡闹厨房，但是第一版只能单机玩，我们很难有时间一起玩。当时正好有胡闹厨房2，我就顺便给我们俩一人买了一个，这样以后就可以一起玩了。后来我怕你用键盘玩着太难受了，就趁着七夕送你了一个和我同款的手柄，虽说不上好用，但是用起来比键盘要舒服多了，等以后我们一定要一起换xbox的手柄。就这样我们用了不到一个暑假的时间就将胡闹厨房2给通关了，等以后有机会了一定要将一也通关。 2019年中秋节，我陪你一起去学校开学，帮你提行李收拾东西，但奈何第一天进不去你们寝室，没有帮到你太多。后来我们又一起吃了谭鸭血，那个火锅真是太好吃了！！！还有那忘不了的鱿鱼蘸小龙虾汤汁。。。但是时间很短，我就要会到开封上学了。。。 从那之后大三整整一个学期我们再也没有机会见面了。。。只剩下国庆时我们每天的视频 大三期末的时候我们都太累了，导致我们的感情出了裂缝，不过幸好在寒假时，我们又将裂缝补上，让他慢慢愈合。 现在疫情严重，我们离得那么近却难以见上一面。之后的一年更是我们人生中关键的一年，我们要相濡以沫，砥砺前行，多一份包容，多一份理解，少一份争吵，为我们心中的理想而努力。千言万语道不尽，只待花开再逢时。 最后我想用周总理的话来结尾： 我一生都是坚定不移的唯物主义者，唯有你，我希望有来生 这一年]]></content>
      <categories>
        <category>关于我们</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kuangbin专题四 最短路练习]]></title>
    <url>%2F2020%2F02%2F05%2Fkuangbin%E4%B8%93%E9%A2%98%E5%9B%9B-%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁 kuangbin专题合集 ACM正确入门方式——数学lover 题目列表 POJ 2387 Til the Cows Come Home AC: 2020-02-05 21:08:20 POJ 2253 Frogger AC: 2020-02-11 20:17:15 POJ 1797 Heavy Transportation AC: 2020-02-16 23:14:29 POJ 3268 Silver Cow Party AC: 2020-02-18 23:39:25 POJ 1860 Currency Exchange POJ 3259 Wormholes POJ 1502 MPI Maelstrom POJ 3660 Cow Contest POJ 2240 Arbitrage POJ 1511 Invitation Cards POJ 3159 Candies POJ 2502 Subway POJ 1062 昂贵的聘礼 POJ 1847 Tram AC: 2018-07-22 01:13:19 LightOJ 1074 Extended Traffic HDU 4725 The Shortest Path in Nya Graph HDU 3416 Marriage Match IV HDU 4370 0 or 1 POJ 3169 Layout POJ-2387 Til the Cows Come Home题意有N个点，T条边，每条边都是双向边。让你求出从点N走到点1的最短路。。。 题解（wrtm，sb题坑死我了，写的我怀疑智商，一个dijkstra模板题WA了六发。。。）dijkstra模板题，没什么好说的，注意是双向边，如果用邻接矩阵的话要注意可能有重边，邻接表就不用管有没有重边了。最主要的是他题目中说的每条边的范围是1-100，然后我最大值就用1000了，结果一直WA，我佛了。。。最后改成了1&lt;&lt;30才过的。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;class Edge implements Comparable&lt;Edge&gt; &#123; public int t, d; public Edge(int t, int d) &#123; this.t = t; this.d = d; &#125; public int compareTo(Edge o) &#123; if (this.d &gt; o.d) &#123; return 1; &#125; else if (this.d == o.d) &#123; return 0; &#125; else &#123; return -1; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int t = cin.nextInt(); int n = cin.nextInt(); int dis[] = new int[n + 10]; List[] lists = new List[n + 10]; for (int i = 0; i &lt; lists.length; i++) &#123; lists[i] = new ArrayList&lt;Edge&gt;(); &#125; for (int i = 0; i &lt; t; i++) &#123; int u = cin.nextInt(), v = cin.nextInt(), d = cin.nextInt(); lists[u - 1].add(new Edge(v - 1, d)); lists[v - 1].add(new Edge(u - 1, d)); &#125; for (int i = 0; i &lt; n; i++) &#123; dis[i] = (i == n - 1) ? 0 : (1 &lt;&lt; 30); &#125; PriorityQueue&lt;Edge&gt; pQueue = new PriorityQueue&lt;Edge&gt;(); Edge now = new Edge(n - 1, dis[n - 1]); pQueue.add(now); while (!pQueue.isEmpty()) &#123; now = pQueue.poll(); int x = now.t; for (int i = 0; i &lt; lists[x].size(); i++) &#123; Edge next = (Edge) lists[x].get(i); int y = next.t, w = next.d; if (dis[x] + w &lt; dis[y]) &#123; dis[y] = dis[x] + w; pQueue.add(new Edge(y, dis[y])); &#125; &#125; &#125; System.out.println(dis[0]); &#125;&#125; POJ-2253 Frogger题意有两只青蛙分别在两个石头上，他们中间有一些石头，青蛙Freddy想要跳到青蛙Fiona那里，求出两个青蛙之间的青蛙距离。（那么什么是青蛙距离呢，一开始看题的时候我也一脸懵逼，这个minimax distance是个神tm的玩意儿？？？） 青蛙距离：两个点之间有若干条路径可以互通，青蛙距离就是取每条路径中的最长边中的最小值假如从点a到点b有两条路径分别为：a-&gt;c-&gt;b，a-&gt;e-&gt;b；其中ac长度为6，cb长度为9；ae长度为3，eb长度为10。那么第一条路径中最长的一条边就是cb，第二条路径中最长的一条边就是eb，青蛙路径就是取cb和eb中较小的一个，即a到b的青蛙距离为9。 题解其实就是把最短路的定义改了一下，原来最短路的定义是两点之间的最短距离，现在是两点之间路径中最长边的最小值，就把dijkstra、SPFA或Floyd中的松弛操作的公式改一下就行了，其他照旧。因为这个题是完全图，所以用邻接矩阵比较容易一些。别给我说两点之间的距离公式不会。。。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.ArrayList;import java.util.List;import java.util.Scanner;class Point &#123; public Point(double x, double y) &#123; super(); this.x = x; this.y = y; &#125; double x, y;&#125;public class Main &#123; static double dis[] = new double[300]; static int n; static double[][] mp = new double[300][300]; public static void dijkstra() &#123; boolean vis[] = new boolean[n+10]; for (int i = 0; i &lt; vis.length; i++) &#123; vis[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; double mn = 100000.0; int x=0; for (int j = 0; j &lt; n; j++) &#123; if (!vis[j] &amp;&amp; dis[j]&lt;mn) &#123; mn = dis[j]; x = j; &#125; &#125; if (mn == 100000.0) &#123; return; &#125; vis[x] = true; for (int j = 0; j &lt; n; j++) &#123; dis[j] = Math.min(dis[j], Math.max(mp[x][j],mn)); &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int t=0; while (true) &#123; n = cin.nextInt(); t++; if (n == 0) &#123; break; &#125; List&lt;Point&gt; points = new ArrayList&lt;Point&gt;(); dis[0] = 0; mp[0][0] = 0; double x, y; for (int i = 0; i &lt; n; i++) &#123; x = cin.nextInt(); y = cin.nextInt(); if (i != 0) &#123; for (int j = 0; j &lt; points.size(); j++) &#123; double z = Math.sqrt((points.get(j).x - x) * (points.get(j).x - x) + (points.get(j).y - y) * (points.get(j).y - y));//两点之间的距离公式 if (j == 0) &#123; dis[i] = z; &#125; mp[i][j] = z; mp[j][i] = z; &#125; &#125; points.add(new Point(x, y)); &#125; dijkstra(); System.out.println("Scenario #" + t + "\nFrog Distance = " + String.format("%.3f", dis[1]) + "\n"); &#125; &#125;&#125; POJ-1797 Heavy Transportation题意这题和青蛙跳（上一题POJ2253）那一题正好相反，求每种路径中权重最小的一节之中的最大值 题解可以用堆优化，但是好麻烦，懒得想了，直接邻接矩阵+普通djikstra。。。把松弛操作改成Max(dis, Min(x, y))，注意组数据输出时要输出两个换行。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Scanner;public class Main &#123; public static void dijkstra(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; dis[i] = mp[0][i]; vis[i] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; int mx = -INF; int x = 0; for (int j = 0; j &lt; n; j++) &#123; if (mx &lt; dis[j] &amp;&amp; !vis[j]) &#123; x = j; mx = dis[j]; &#125; &#125; if (mx == -INF) &#123; return; &#125; vis[x] = true; for (int j = 0; j &lt; n; j++) &#123; dis[j] = Math.max(dis[j], Math.min(mx, mp[x][j])); &#125; &#125; &#125; public static int dis[] = new int[1010]; public static int mp[][] = new int[1010][1010]; public static int INF = 1&lt;&lt;30; public static boolean vis[] = new boolean[1010]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int t = cin.nextInt(); for (int i = 0; i &lt; t; i++) &#123; int n = cin.nextInt(); int m = cin.nextInt(); for (int j = 0; j &lt; 1010; j++) &#123; for (int j2 = 0; j2 &lt; 1010; j2++) &#123; mp[j][j2] = -INF; &#125; &#125; int x, y, z; for (int j = 0; j &lt; m; j++) &#123; x = cin.nextInt()-1; y = cin.nextInt()-1; z = cin.nextInt(); mp[x][y] = z; mp[y][x] = z; &#125; dijkstra(n); System.out.println("Scenario #" + (i+1) + ":\n" + dis[n-1] + "\n"); &#125; &#125;&#125; POJ-3268 Silver Cow Party题意有n个农场，每个农场有一头牛，n个农场之间有m条单向路，其他农场的牛都要去x农场开会，开完会再回自己的农场，每头牛保证都会走最短路径，求出走路最多的牛来回共走了多少路。 题解由于是单向路，所以来回可能走的路径不同。但是，我们直接建两个图不就好了，反向建一张图，正向建一张图，那这道题就成了分别求两个图x点的单源最短路，直接跑两遍dijkstra就行了。 我看评论区还有人用Floyd，肯定超时啊，N最大是1000，M最大是100000。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.util.ArrayList;import java.util.List;import java.util.PriorityQueue;import java.util.Scanner;class Edge implements Comparable&lt;Edge&gt; &#123; int t, d; public Edge(int t, int d) &#123; super(); this.t = t; this.d = d; &#125; @Override public int compareTo(Edge o) &#123; if (this.d &gt; o.d) &#123; return 1; &#125; else if (this.d == o.d) &#123; return 0; &#125; else &#123; return -1; &#125; &#125;&#125;public class Main &#123; public static int INF = 1 &lt;&lt; 30; public static int dis1[] = new int[1010]; public static int dis2[] = new int[1010]; public static List&lt;Edge&gt; list1[] = new List[1010]; public static List&lt;Edge&gt; list2[] = new List[1010]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int n = cin.nextInt(), m = cin.nextInt(), x = cin.nextInt(); for (int i = 0; i &lt; 1010; i++) &#123; list1[i] = new ArrayList&lt;Edge&gt;(); list2[i] = new ArrayList&lt;Edge&gt;(); dis1[i] = (i == x - 1) ? 0 : INF; dis2[i] = (i == x - 1) ? 0 : INF; &#125; int s = 0, t = 0, d = 0; for (int i = 0; i &lt; m; i++) &#123; s = cin.nextInt() - 1; t = cin.nextInt() - 1; d = cin.nextInt(); list1[s].add(new Edge(t, d)); list2[t].add(new Edge(s, d)); &#125; PriorityQueue&lt;Edge&gt; pQueue1 = new PriorityQueue&lt;Edge&gt;(); PriorityQueue&lt;Edge&gt; pQueue2 = new PriorityQueue&lt;Edge&gt;(); Edge now = new Edge(x - 1, 0); pQueue1.offer(now); pQueue2.offer(now); while (!pQueue1.isEmpty()) &#123; now = pQueue1.poll(); s = now.t; for (int i = 0; i &lt; list1[s].size(); i++) &#123; Edge next = (Edge) list1[s].get(i); t = next.t; d = next.d; if (dis1[t] &gt; dis1[s] + d) &#123; dis1[t] = dis1[s] + d; pQueue1.offer(new Edge(t, dis1[t])); &#125; &#125; &#125; while (!pQueue2.isEmpty()) &#123; now = pQueue2.poll(); s = now.t; for (int i = 0; i &lt; list2[s].size(); i++) &#123; Edge next = (Edge) list2[s].get(i); t = next.t; d = next.d; if (dis2[t] &gt; dis2[s] + d) &#123; dis2[t] = dis2[s] + d; pQueue2.offer(new Edge(t, dis2[t])); &#125; &#125; &#125; int mx = -INF; for (int i = 0; i &lt; n; i++) &#123; dis1[i] += dis2[i]; mx = Math.max(dis1[i], mx); &#125; System.out.println(mx); &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>最短路</tag>
        <tag>蓝桥杯</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吃瓜程序]]></title>
    <url>%2F2020%2F01%2F12%2F%E5%90%83%E7%93%9C%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本文纯属娱乐，寒假了没事找事干（话说我好像也不是没事，该准备考研了）,用C#控制台实现了一下好瓜坏瓜从假设空间求对应数据集的版本空间。 概念假设空间：属性所有可能取值组成的可能的样本。 版本空间：与已知数据集一致的所有假设的子集集合。 （绿色加号代表正类样本，红色小圈代表负类样本） GB 是最大泛化正假设边界(maximally General positive hypothesis Boundary),； SB 是最大精确正假设边界(maximally Specific positive hypothesis Boundary) GB与SB之间所围成的区域就是版本空间。 西瓜问题先写出假设空间，再根据训练数据集求其版本空间 假设空间，即所有可能的组合（加上空集） 再根据训练数据集，与正类（即好瓜）不匹配的删除，与负类（即坏瓜）匹配的删除。 上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130namespace ConsoleApp1&#123; struct Gua //瓜的结构体 &#123; public string Se; //色泽 public string Gen; //根蒂 public string Qiao; //敲声 public bool isEmpty; //是否为空集 public bool isHaoGua; //是否为好瓜，用于标记训练数据集 &#125; class Program &#123; static string print(Gua gua) //用于输出瓜的属性，即toString函数 &#123; if (gua.isEmpty) &#123; return &quot;∅&quot;; &#125; return &quot;色泽=&quot; + gua.Se + &quot;, 根蒂=&quot; + gua.Gen + &quot;, 敲声=&quot; + gua.Qiao; &#125; static void Main(string[] args) &#123; string[] seze = &#123; &quot;*&quot;, &quot;青绿&quot;, &quot;乌黑&quot; &#125;; //色泽 string[] gendi = &#123; &quot;*&quot;, &quot;蜷缩&quot;, &quot;硬挺&quot;, &quot;稍蜷&quot; &#125;; //根蒂 string[] qiaosheng = &#123; &quot;*&quot;, &quot;浊响&quot;, &quot;清脆&quot;, &quot;沉闷&quot; &#125;; //敲声 List&lt;Gua&gt; Space = new List&lt;Gua&gt;(); //初始为假设空间的列表 List&lt;Gua&gt; TrainData = new List&lt;Gua&gt;(); //训练数据集 Gua gua = new Gua(); //添加空集 gua.isEmpty = true; gua.isHaoGua = false; Space.Add(gua); foreach (var item in seze) //求假设空间 &#123; foreach (var item1 in gendi) &#123; foreach (var item2 in qiaosheng) &#123; Gua g = new Gua(); g.Se = item; g.Gen = item1; g.Qiao = item2; g.isEmpty = false; g.isHaoGua = false; Space.Add(g); &#125; &#125; &#125; //此处为输入训练数据集 Gua hao = new Gua(); //该数据为书中表1.1的数据1 hao.isHaoGua = true; hao.isEmpty = false; hao.Se = seze[1]; hao.Gen = gendi[1]; hao.Qiao = qiaosheng[1]; TrainData.Add(hao); Gua hao1 = new Gua(); //该数据为书中表1.1的数据2 hao1.isHaoGua = true; hao1.isEmpty = false; hao1.Se = seze[2]; hao1.Gen = gendi[1]; hao1.Qiao = qiaosheng[1]; TrainData.Add(hao1); Gua huai = new Gua(); //该数据为书中表1.1的数据3 huai.isHaoGua = false; huai.isEmpty = false; huai.Se = seze[1]; huai.Gen = gendi[2]; huai.Qiao = qiaosheng[2]; TrainData.Add(huai); Gua huai1 = new Gua(); //该数据为书中表1.1的数据4 huai1.isHaoGua = false; huai1.isEmpty = false; huai1.Se = seze[2]; huai1.Gen = gendi[3]; huai1.Qiao = qiaosheng[3]; TrainData.Add(huai1); //通过训练数据集对假设空间进行剔除，求其版本空间 foreach (var item in TrainData) &#123; for (int i = Space.Count-1; i &gt;= 0; i--) &#123; var item1 = Space[i]; if (item.isHaoGua)//如果有好瓜 &#123; if (item1.isEmpty)//如果有好瓜则不可能存在空集，删除空集 &#123; Space.Remove(item1); continue; &#125; if ((item1.Se.Equals(item.Se) || item1.Se.Equals(&quot;*&quot;)) &amp;&amp; (item1.Gen.Equals(item.Gen) || item1.Gen.Equals(&quot;*&quot;)) &amp;&amp; (item1.Qiao.Equals(item.Qiao) || item1.Qiao.Equals(&quot;*&quot;))) //和好瓜相匹配的数据不删除 &#123; continue; &#125; else &#123; Space.Remove(item1); &#125; &#125; else &#123; if ((item1.Se.Equals(item.Se) || item1.Se.Equals(&quot;*&quot;)) &amp;&amp; (item1.Gen.Equals(item.Gen) || item1.Gen.Equals(&quot;*&quot;)) &amp;&amp; (item1.Qiao.Equals(item.Qiao) || item1.Qiao.Equals(&quot;*&quot;))) //和坏瓜相匹配的数据删除 &#123; Space.Remove(item1); &#125; &#125; &#125; &#125; foreach (var item in Space) //输出 &#123; Console.WriteLine(print(item)); &#125; Console.ReadKey(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>西瓜书</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC--二、SpringMVC请求参数绑定和常用注解]]></title>
    <url>%2F2019%2F11%2F19%2FSpringMVC--%E4%BA%8C%E3%80%81SpringMVC%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E5%92%8C%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[请求参数绑定绑定机制我们都知道，表单中请求参数都是基于key=value的。 SpringMVC绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。 支持的数据类型基本类型参数： 包括基本类型和String类型我们在表单中的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) index.jsp文件 123456&lt;form method="post" action="param/test"&gt; 姓名：&lt;input type="text" name="name"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller类 123456789@Controller@RequestMapping("/param")public class ParamController &#123; @RequestMapping("/test") public String ParamTest(String name, User user)&#123; System.out.println(name + '\t' + user); return "success"; &#125;&#125; User类 1234567891011121314151617181920212223public class User implements Serializable &#123; String password; Integer age; @Override public String toString() &#123; return "User&#123;" + "password='" + password + '\'' + ", age=" + age + '&#125;'; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 这里直接使用实体类的时候，表单中的name命名可以当作基本类型，但是当实体类中使用其他实体类，要使用如下命名方式 POJO类型参数： 包括实体类，以及关联的实体类中文释义为简单的java对象，其实就是Java bean，好像是为了避免和EJB混淆所创造的简称要求表单中参数名称和POJO类的属性名称保持一致。并且控制器方法的参数类型是POJO类型。例如：name.firstname用于这里的实体类都要实现Serializable接口 index.jsp 1234567&lt;form method="post" action="param/test"&gt; 姓：&lt;input type="text" name="name.firstname"&gt;&lt;br&gt; 名：&lt;input type="text" name="name.secondname"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller类 123456789@Controller@RequestMapping("/param")public class ParamController &#123; @RequestMapping("/test") public String ParamTest(User user)&#123; System.out.println(user); return "success"; &#125;&#125; User类 1234567891011121314151617181920212223242526272829303132public class User implements Serializable &#123; String password; Name name;//自定义类型JavaBean Integer age; @Override public String toString() &#123; return "User&#123;" + "password='" + password + '\'' + ", name=" + name + ", age=" + age + '&#125;'; &#125; public Name getName() &#123; return name; &#125; public void setName(Name name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; Name类 123456789101112131415161718192021222324public class Name implements Serializable &#123; @Override public String toString() &#123; return "Name&#123;" + "firstname='" + firstname + '\'' + ", secondname='" + secondname + '\'' + '&#125;'; &#125; private String firstname, secondname; public String getFirstname() &#123; return firstname; &#125; public void setFirstname(String firstname) &#123; this.firstname = firstname; &#125; public String getSecondname() &#123; return secondname; &#125; public void setSecondname(String secondname) &#123; this.secondname = secondname; &#125;&#125; 数组和集合类型参数： 包括List结构和Map结构的集合（包括数组） 要求集合类型的请求参数必须在POJO中。在表单中请求参数名称要和POJO中集合属性名称相同。给List集合中的元素赋值，使用下标。 例如：list[0].user给Map集合中的元素赋值，使用键值对。例如：map[‘one’].user 接收的请求参数是json格式数据。需要借助一个注解实现。 index.jsp 1234567891011&lt;form method="post" action="param/test"&gt; 姓一：&lt;input type="text" name="nameList[0].firstname"&gt;&lt;br&gt; 名一：&lt;input type="text" name="nameList[0].secondname"&gt;&lt;br&gt; 姓二：&lt;input type="text" name="nameList[1].firstname"&gt;&lt;br&gt; 名二：&lt;input type="text" name="nameList[1].secondname"&gt;&lt;br&gt; 姓三：&lt;input type="text" name="nameMap['one'].firstname"&gt;&lt;br&gt; 名三：&lt;input type="text" name="nameMap['one'].secondname"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller类同上 User类 12345678910111213141516171819202122232425262728293031323334353637383940public class User implements Serializable &#123; String password; Integer age; List&lt;Name&gt; nameList; Map&lt;String, Name&gt; nameMap; @Override public String toString() &#123; return "User&#123;" + "password='" + password + '\'' + ", age=" + age + ", nameList=" + nameList + ", nameMap=" + nameMap + '&#125;'; &#125; public List&lt;Name&gt; getNameList() &#123; return nameList; &#125; public void setNameList(List&lt;Name&gt; nameList) &#123; this.nameList = nameList; &#125; public Map&lt;String, Name&gt; getNameMap() &#123; return nameMap; &#125; public void setNameMap(Map&lt;String, Name&gt; nameMap) &#123; this.nameMap = nameMap; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; Name类同上 请求参数乱码问题在web.xml中配置Spring提供的过滤器类： 123456789101112131415&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filterclass&gt; &lt;!-- 指定字符集 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!--/*代表拦截所有--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 自定义类型转换器任何变量从jsp传到控制器用的都是字符串，当其到控制器时，Spring有自定义的类型转换器将其转换为特定的类型的变量，当有些变量无法通过Spring自定义类型转换器转换类型时，我们可以自己定义一个类型转换器来帮助转换。 例如Data类，默认日期格式为1999/10/1，当我们输入1999-10-1时则会发生错误，Spring自定义类型转换器无法转换，此时我们自己定义一个类型转换器，来讲1999-10-1格式的日期字符串转换成Data类。 定义一个类型转换器类自定义的类型转换器类需要继承一个Converter接口，要看清楚是Spring核心包中的Converter接口： 类中的两个泛型S和T分别写要从类型S转换到类型T 123456789101112131415public class StringToData implements Converter&lt;String, Date&gt;&#123; @Override public Date convert(String source) &#123; if (source==null)&#123; throw new RuntimeException("值空"); &#125; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); try &#123; return dateFormat.parse(source); &#125;catch (Exception e)&#123; throw new RuntimeException("错误"); &#125; &#125;&#125; 配置自定义类型转换器在resources中的xml配置文件中配置自定义类型转换器，就是你配置视图解析器的那个配置文件。 1234567891011&lt;bean id="conversionServiceFactoryBean" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="com.utils.StringToData"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--配置spring开启注解mvc的支持--&gt;&lt;mvc:annotation-driven conversion-service="conversionServiceFactoryBean"&gt;&lt;/mvc:annotation-driven&gt; 这里还要修改开启注解mvc的支持，因为在开启注解mvc的支持时是默认开启了处理器映射器、处理器适配器、视图解析器三大组件，而现在想用类型转换器，则必须在这里配置开启。 常用注解RequestParam使用说明作用：把请求中的指定名称的参数传递给控制器中的形参赋值 属性： value：请求参数中的名称（当你使用了RequestParam注解之后就必须按照value中的命名来传递参数，不能再像请求参数绑定中，把参数命名成相同的名字了。） required：请求参数中是否必须提供此参数，默认值是true（即必须提供，如果不提供将报错） 示例index.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="anno/testRp?name=haha"&gt;testRequestParam&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; Controller12345678910111213@Controller@RequestMapping("anno")public class AnnoController &#123; @RequestMapping("/testRp") public String testRp(@RequestParam(value = "name", required = false) String username)&#123; if (username==null) System.out.println("无用户名"); else System.out.println(username); return "success"; &#125;&#125; 在这个例子中我们把required改为false，则当没有参数传递给username时它为null。当使用RequestParam时则必须按照它的value在jsp页面命名，不能像请求参数绑定中命名成相同的名字。例如在这个例子中，jsp页面想要传递参数给控制器中的username，就必须给控制器传递一个名为name的参数，而不能传递一个名为username的参数。 RequestBody使用说明作用：用于获取请求体的内容，直接使用得到是key=value&amp;key=value…结构的数据。（注意：get方法不可以，因为get没有请求体，它把参数都封装到地址栏了） 属性： required：是否必须有请求体，默认值是true。当取值为true时,get请求方式会报错。如果取值为false，get请求得到是null。 示例index.jsp1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method="post" action="anno/testRequestBody"&gt; 用户名：&lt;input type="text" name="username"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Controller123456789@Controller@RequestMapping("anno")public class AnnoController &#123; @RequestMapping("/testRequestBody") public String testRequestBody(@RequestBody String body)&#123; System.out.println(body); return "success"; &#125;&#125; 在本例中的请求体输出示例：username=int64Saturday&amp;password=111&amp;age=111 PathVaribale使用说明作用：用于绑定url中的占位符。例如：请求url中 /delete/{id}，这个{id}就是url占位符。url支持占位符是spring3.0之后加入的。是springmvc支持rest风格URL的一个重要标志。 那么什么时rest风格的URL呢，一般rest风格都称为restful风格，它其实就是一种规范，区别于我们平时普通的url，见下图 （图中的FindById()方法少写了个参数id）从图中可看出普通的url每个方法都会对应一个地址，但是restful风格的url相同类下的每个方法地址都是相同的。restful风格的url是通过http协议的四种方法来寻找要执行的方法，即： GET 用来获取资源 POST 用来新建资源 PUT 用来更新资源 DELETE 用来删除资源。 但是当遇到相同的方法时，如上图的FindAll()方法和FindById(id)方法，它会通过不同的参数来寻找特定的方法，有些类似函数的重载。上图中的{id}是占位符，当我们想调用FindById(id)方法时，参数id=10，此时的url应该为：/user/10 但是form表单只支持GET和POST方法，而DELETE、PUT等方法并不支持，Spring3.0添加了一个过滤器能帮我们模拟这些方法，但是配置比较麻烦，不如其他的一些类实现容易，这里就不赘述了，想了解的可以自行百度。 属性： value：用于指定url中占位符名称。 required：是否必须提供占位符。 示例index.jsp12345678&lt;body&gt;&lt;form method="post" action="anno/10"&gt; 用户名：&lt;input type="text" name="username"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt; Controller123456789@Controller@RequestMapping("anno")public class AnnoController &#123; @RequestMapping("/&#123;sid&#125;") public String testPathVaribale(@PathVariable(value = "sid") String id)&#123; System.out.println(id); return "success"; &#125;&#125; 最后控制台输出结果为10。 RequestHeader使用说明作用：用于获取请求消息头。http请求头有很多种，详情见百度百科：http请求头 属性： value：提供消息头名称 required：是否必须有此消息头 注： 在实际开发中一般不怎么用。 示例index.jsp1&lt;a href="anno/testRequestHeader"&gt;testRequestHeader&lt;/a&gt; Controller12345@RequestMapping("/testRequestHeader")public String testRequestHeader(@RequestHeader(value = "Accept") String header)&#123; System.out.println(header); return "success";&#125; CookieValue使用说明作用：用于把指定 cookie 名称的值传入控制器方法参数。 属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 注： 在实际开发中一般不怎么用。 示例index.jsp1&lt;a href="anno/testCookieValue"&gt;testRequestHeader&lt;/a&gt; Controller12345@RequestMapping("/testCookieValue")public String testCookieValue(@CookieValue(value = "JSESSIONID") String cookieValue)&#123; System.out.println(cookieValue); return "success";&#125; ModelAttribute使用说明作用：该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 属性： value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。 应用场景： 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 示例1index.jsp123456&lt;form method="post" action="anno/testModelAttribute"&gt; 用户名：&lt;input type="text" name="username"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller12345678910@RequestMapping("/testModelAttribute")public String testModelAttribute (User user)&#123; System.out.println("testModelAttribute执行了..." + user.getUsername()); return "success";&#125;@ModelAttributepublic void showUser()&#123; System.out.println("showUser执行了...");&#125; 最后控制台输出结果为：showUser执行了…testModelAttribute执行了…int64Saturday 示例2有返回值，表单中没有输入age的文本框，如果不进行配置，则age为null index.jsp12345&lt;form method="post" action="anno/testModelAttribute"&gt; 用户名：&lt;input type="text" name="username"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; Controller1234567891011121314151617@RequestMapping("/testModelAttribute")public String testModelAttribute (User user)&#123; System.out.println("testModelAttribute执行了..."); System.out.println(user); return "success";&#125;@ModelAttributepublic User showUser(String username)&#123; User user = new User(); //模拟数据库查询 user.setAge(10); user.setPassword("111"); user.setUsername(username); System.out.println("showUser执行了..."); return user;&#125; 示例3无返回值，没有返回值时，需要方法提供一个map结构，将User对象存入map中，然后在控制器方法中用ModelAttribute修饰形参从map中取出该对象。 index.jsp同上 Controller12345678910@ModelAttributepublic void showUser(String username, Map&lt;String, User&gt; map)&#123; User user = new User(); //模拟数据库查询 user.setAge(10); user.setPassword("111"); user.setUsername(username); map.put("user", user); System.out.println("showUser执行了...");&#125; SessionAttribute使用说明作用：用于多次执行控制器方法间的参数共享，作用于类上。 属性： value：用于指定存入的属性名称 type：用于指定存入的数据类型 示例index.jsp123&lt;a href="anno/testSaveSessionAttribute"&gt;SaveSessionAttribute&lt;/a&gt;&lt;br&gt;&lt;a href="anno/testGetSessionAttribute"&gt;GetSessionAttribute&lt;/a&gt;&lt;br&gt;&lt;a href="anno/testDeleteSessionAttribute"&gt;DeleteSessionAttribute&lt;/a&gt; Controller123456789101112131415161718192021222324252627@Controller@RequestMapping("anno")@SessionAttributes(value = &#123;"username", "password"&#125;)public class AnnoController &#123; @RequestMapping("/testSaveSessionAttribute") public String testSaveSessionAttribute (Model model)&#123; System.out.println("向session中保存了数据"); model.addAttribute("username", "root"); model.addAttribute("password", "1234"); return "success"; &#125; @RequestMapping("/testGetSessionAttribute") public String testGetSessionAttribute (ModelMap modelMap)&#123; System.out.println("从session中获取了数据"); String username = (String)modelMap.get("username"); String password = (String)modelMap.get("password"); System.out.println("username:" + username + "\tpassword:" + password); return "success"; &#125; @RequestMapping("/testDeleteSessionAttribute") public String testDeleteSessionAttribute (SessionStatus sessionStatus)&#123; System.out.println("从session中删除了数据"); //设置完成，就是这些操作做完了，它会帮你把session中的数据清除 sessionStatus.setComplete(); return "success"; &#125;&#125; 超链接点击步骤：存值-&gt;取值-&gt;删除-&gt;取值控制台输出： 向session中保存了数据 从session中获取了数据 username:root password:1234 从session中删除了数据 从session中获取了数据 username:null password:null]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC--一、SpringMVC入门]]></title>
    <url>%2F2019%2F11%2F14%2FSpringMVC--%E4%B8%80%E3%80%81SpringMVC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[三层架构和MVC三层架构 咱们开发服务器端程序，一般都基于两种形式，一种C/S架构程序，一种B/S架构程序 使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构 三层架构 表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型 业务层：处理公司具体的业务逻辑的 持久层：用来操作数据库的 MVC模型 MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 Model：数据模型，JavaBean的类，用来进行数据封装。 View：指JSP、HTML用来展示数据给用户 Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 SpringMVC而SpringMVC就是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于 Spring FrameWork 的后续产品，已经融合在Spring Web Flow里面。 SpringMVC入门案例导入的包创建maven项目，在pom.xml文件中导入如下包： spring-context spring-web spring-webmvc servlet-api jsp-api 配置核心控制器（DispatcherServlet）web.xml文件 1234567891011121314151617&lt;!--SpringMVC核心控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--配置Servlet的初始化参数，读取springmvc的配置文件(我这里是springmvc.xml)，创建spring容器--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--配置servlet启动时加载对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!--设置mapping为/，任何请求都会经过servlet--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置源文件在src/main/resources文件下创建一个xml用于配置springmvc各种组件，这里创建springmvc.xml， 导入命名空间12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;/beans&gt; 配置组件1234567891011121314&lt;!--配置spring创建容器时要扫描的包--&gt;&lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt;&lt;!--配置视图解析器--&gt;&lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--要跳转的包--&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;!--后缀名--&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置spring开启注解mvc的支持--&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 编写view层index.jsp： 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello&lt;br&gt;&lt;a href="hello"&gt;翻译&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在WEB-INF目录下创建pages文件夹，编写success.jsp： 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;你好&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 编写控制器HelloController： 12345678@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String translate()&#123; System.out.println("translate..."); return "success"; &#125;&#125; 案例过程分析 服务器启动，应用被加载。读取到web.xml中的配置创建spring容器并且初始化容器中的对象。因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，就会加载springmvc.xml配置文件。开启了注解扫描，那么HelloController对象就会被创建。 浏览器发送请求（即index.jsp），被DispatherServlet捕获，该Servlet并不处理请求，而是把请求转发出去。转发的路径是根据请求URL，匹配@RequestMapping中的内容（即HelloController的translate）。 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件。 渲染结果视图，响应浏览器。 响应流程： 入门案例涉及的组件DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler：处理器它就是我们开发中要编写的具体业务控制器。由DispatcherServlet把用户请求转发到Handler。由Handler对具体的用户请求进行处理。 HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver：视图解析器View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View：视图SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 mvc:annotation-driven说明在SpringMVC的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件。 使用mvc:annotation-driven自动加载RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（处理适配器），可用在SpringMVC.xml配置文件中使用mvc:annotation-driven替代注解处理器和适配器的配置。 它就相当于在xml中配置了： 123456789101112131415&lt;!-- Begin --&gt; &lt;!-- HandlerMapping --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- HandlerAdapter --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- HadnlerExceptionResolvers --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver"&gt;&lt;/bean&gt;&lt;bean class="org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"&gt;&lt;/bean&gt; &lt;!-- End --&gt; RequestMapping注解RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系 RequestMapping注解可以作用在方法和类上： 作用在类上：请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的URL可以按照模块化管理，例如： 账户模块： /account/add /account/update /account/delete … 订单模块： /order/add /order/update /order/delete 前面相同的部分就是把RequsetMapping写在类上，使我们的URL更加精细。 作用在方法上：URL的二级访问目录 细节：路径可以不编写 / 表示应用的根目录开始 细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 / RequestMapping的属性 path 指定请求路径的url value value属性和path属性是一样的 mthod 指定该方法的请求方式（get方法和post方法） params 用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样。例如： params = {“accountName”}，表示请求参数必须有accountName params = {“moeny!100”}，表示请求参数中money不能是100。 headers 发送的请求中必须包含的请求头（不常用）]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3杂记]]></title>
    <url>%2F2019%2F11%2F11%2FPython3%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&amp;#开头的编码显示成中文1234import htmlprint(html.unescape('&amp;#20013;&amp;#22269;'))#中国]]></content>
      <categories>
        <category>Python3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring--四、Spring中的JdbcTemplate和事务控制]]></title>
    <url>%2F2019%2F11%2F08%2FSpring--%E5%9B%9B%E3%80%81Spring%E4%B8%AD%E7%9A%84JdbcTemplate%E5%92%8C%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring中的JdbcTemplateJdbcTemplate概述它是spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。 操作关系型数据的： JdbcTemplate HibernateTemplate 操作nosql数据库的： RedisTemplate 操作消息队列的： JmsTemplate 环境搭建需要导入的jar包（版本可自行选择）： spring-jdbc-5.1.9.RELEASE.jar（JDBC） spring-tx-5.1.9.RELEASE.jar（关于事务的） spring-context-5.1.9.RELEASE.jar（IOC） 编写配置文件123456&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt; 配置数据源（Spring内置数据源）123456&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?serverTimezone=UTC"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="password"&gt;&lt;/property&gt;&lt;/bean&gt; 配置JdbcTemplate123&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 操作示例1234567891011121314151617181920212223242526272829303132333435363738//实体类public class UserManager &#123; String username, password; double money; @Override public String toString() &#123; return "UserManager&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + ", money=" + money + '&#125;'; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125;&#125; 123456789101112131415//获取Spring容器ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");//根据id获取bean对象JdbcTemplate jt = (JdbcTemplate)ac.getBean("jdbcTemplate");//查询//BeanPropertyRowMapper是将查询的每一行封装成一个对象，放到集合中//这里就是将查询到的username、password、money三个属性封装成一个UserManager类List&lt;UserManager&gt; userManagers = jt.query("select * from user", new BeanPropertyRowMapper&lt;UserManager(UserManager.class));//删除jt.update("delete from user where username = ?","aaa");//插入jt.update("insert into user(username,password,money)values(?,?)","aaa","fff",5000);//更新jt.update("update user set money = money-? where username = ?",300,"aaa"); 在DAO中使用JdbcTemplate实体类如上所示 第一种方式在DAO类中定义JdbcTemplate UserManager的DAO类 123456789101112131415161718192021222324252627public class UserManagerDao implements IUserManagerDao &#123; JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public UserManager FindUserByName(String username) &#123; List&lt;UserManager&gt; userManagers = jdbcTemplate.query("select * from user where username=?", new BeanPropertyRowMapper&lt;UserManager&gt;(UserManager.class), username); return userManagers.isEmpty()?null:userManagers.get(0); &#125; @Override public List&lt;UserManager&gt; FindAll() &#123; return jdbcTemplate.query("select * from user", new BeanPropertyRowMapper&lt;UserManager&gt;(UserManager.class)); &#125; @Override public void UpdateUserByName(UserManager userManager) &#123; jdbcTemplate.update("update user set password=?, money=? where username=?", userManager.getPassword(), userManager.getMoney(), userManager.getUsername()); &#125;&#125; 通过xml文件配置该DAO类： 1234567891011121314&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?serverTimezone=UTC"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="password"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="userManagerDao" class="com.dao.Impl.UserManagerDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 有一个小问题，当DAO类过多时以下代码会有很多重复代码： 1234JdbcTemplate jdbcTemplate;public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate;&#125; 第二种方式让DAO类继承JdbcDaoSupport JdbcDaoSupport是spring框架为我们提供的一个类，该类中定义了一个JdbcTemplate对象，我们可以直接获取使用，只需要继承该类就可以了。而且此时我们不需要再用xml文件注入jdbcTemplate了，而可以直接给UserManagerDao类注入一个dataSource对象（因为JdbcDaoSupport类有dataSource的set方法，他会自动用dataSource创建JdbcTemplate），可见xml文件配置方法 12345678910111213141516171819public class UserManagerDao extends JdbcDaoSupport implements IUserManagerDao &#123; @Override public UserManager FindUserByName(String username) &#123; List&lt;UserManager&gt; userManagers = super.getJdbcTemplate().query("select * from user where username=?", new BeanPropertyRowMapper&lt;UserManager&gt;(UserManager.class), username); return userManagers.isEmpty()?null:userManagers.get(0); &#125; @Override public List&lt;UserManager&gt; FindAll() &#123; return super.getJdbcTemplate().query("select * from user", new BeanPropertyRowMapper&lt;UserManager&gt;(UserManager.class)); &#125; @Override public void UpdateUserByName(UserManager userManager) &#123; super.getJdbcTemplate().update("update user set password=?, money=? where username=?", userManager.getPassword(), userManager.getMoney(), userManager.getUsername()); &#125;&#125; 123456789&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?serverTimezone=UTC"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="password"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="userManagerDao" class="com.dao.Impl.UserManagerDao"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 对比当使用第二种方法时确实减少了代码的冗余，但是当使用注解配置时，由于JdbcDaoSupport类是Spring的类，我们无法修改，则第二种方法只有当使用xml文件配置时才可以使用，第一种方法可以在使用注解时使用。 Spring中的事务控制Spring中的事务控制概述事务控制即让由一系列动作组成的事务保持原子性、一致性、隔离性、持久性。 原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。 一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。 隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。 持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 举一个经典的例子就是银行转账，银行转账分为几步：转账开始，账户一扣钱，账户二加钱，转账结束。但是当账户一扣过钱之后系统出现了某种异常转账行为不能继续进行。如果没有事务控制这次转账将会被强行结束，而事务控制则会保持其一致性，开启回滚事务，让所有信息恢复到转账开始前的状态。 Spring的事务控制都是基于AOP的，分为两种，一种是声明式事务控制（即用配置的方式来实现），一种是编程式事务控制（即用编程的方式来实现）。 Spring事务控制API介绍 PlatformTransactionManager事务管理器 123TransactionStatus getTransaction();//获取事务的状态信息void commit();//提交事务void rollback();//回滚事务 TransactionDefinition事务的定义信息对象 12345String getName();//获取事务对象名int getIsolationLevel();//获取事务隔离级int getPropagationBehavior();//获取事务传播行为int getTimeout();//获取事务超时时间boolean isReadOnly();//获取事务是否只读 读写型事务：增、删、改 只读型事务：查询 事务的隔离级别 事务的传播行为 REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER:以非事务方式运行，如果当前存在事务，抛出异常 NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类似的操作。 超时时间默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 是否是只读事务建议查询时设置为只读。 TransactionStatus描述了某个时间点上十五对象的状态信息 123456void flush();//刷新事务boolean hasSavepoint();//获取是否存在存储点boolean isCompleted();//获取事务是否完成boolean isNewTransaction();//获取事务是否为新事务boolean isRollbackOnly();//获取事务是否回滚void setRollbackOnly();//设置事务回滚 基于XML的声明式事务控制环境搭建设置打包方式和导包先设置打包方式为jar包，导入jar包： spring-jdbc spring-tx spring-context aspectjweaver 数据库驱动 创建Spring配置文件并导入约束（此处需要导入tx和aop的命名空间）123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;/beans&gt; 准备数据库和实体类12345create table account( id int primary key auto_increment, name varchar(40), money float )character set utf8 collate utf8_general_ci; 12345678910111213141516171819202122232425262728293031public class Account implements Serializable &#123; private Integer id; private String name; private Float money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 准备Dao层接口和实现类接口： 12345public interface IAccountDao &#123; Account findAccountById(Integer id); Account findAccountByName(String name); void updateAccount(Account account);&#125; 实现类： 123456789101112131415161718192021222324public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = getJdbcTemplate().query("select * from account where id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id); return list.isEmpty()?null:list.get(0); &#125; public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = getJdbcTemplate().query("select * from account where name = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty())&#123; return null; &#125; if (list.size()&gt;1)&#123; throw new RuntimeException("结果不唯一"); &#125; return list.get(0); &#125; public void updateAccount(Account account) &#123; getJdbcTemplate().update("update account set money = ? where id = ?", account.getMoney(), account.getId()); &#125;&#125; 准备业务层接口及实现类接口： 1234public interface IAccountService &#123; Account findAccountById(Integer id); void transfer(String sourceName, String targetName, Float money);&#125; 实现类： 1234567891011121314151617181920212223public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; public void transfer(String sourceName, String targetName, Float money) &#123; Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); accountDao.updateAccount(source); accountDao.updateAccount(target); &#125;&#125; 在配置文件中配置数据源，业务层及持久层1234567891011121314151617&lt;!--配置数据源--&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?serverTimezone=UTC"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="password"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置Dao--&gt;&lt;bean id="accountDao" class="com.dao.Impl.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置service--&gt;&lt;bean id="accountService" class="com.service.Impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt; 基于XML的配置步骤配置事务管理器1234&lt;!--配置事务管理器--&gt;&lt;bean id="transactionManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 配置事务的通知及属性1234567891011&lt;!--配置事务的通知--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!--配置事务的属性 name为业务的核心方法名称，可以用通配符*代替 find*即表示以find开头的方法，他比单用通配符优先级更高 --&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" read-only="false" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" read-only="true" propagation="SUPPORTS"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; read-only：是否是只读事务。默认false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。 配置AOP切入点表达式及切入点表达式和事务通知的对应关系12345&lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* com.service.Impl.*.*(..))"/&gt; &lt;!--建立切入点表达式和事务通知的对应关系--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 测试代码12345public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService accountService = (IAccountService) ac.getBean("accountService"); accountService.transfer("a", "b", 100f);&#125; 基于注解的声明式事务控制环境搭建设置打包方式和导包和基于XML配置相同 创建spring的配置文件导入约束并配置扫描的包123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--配置要扫描的包--&gt; &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt; 创建数据库表和实体类和基于XML配置相同 创建Dao接口和实现类并使用注解让spring管理注意：当使用注解时不能再继承JdbcDaoSupport了，必须手动创建JdbcTemplate类并用@Autowried注入，还要在bean.xml文件中配置JdbcTemplate。 12345678910111213141516171819202122232425262728293031@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = jdbcTemplate.query("select * from account where id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id); return list.isEmpty()?null:list.get(0); &#125; public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query("select * from account where name = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (list.isEmpty())&#123; return null; &#125; if (list.size()&gt;1)&#123; throw new RuntimeException("结果不唯一"); &#125; return list.get(0); &#125; public void updateAccount(Account account) &#123; jdbcTemplate.update("update account set money = ? where id = ?", account.getMoney(), account.getId()); &#125;&#125; 创建业务层接口和实现类并使用注解让spring管理去掉set方法，使用Autowried自动注入 123456789101112131415161718192021@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; public void transfer(String sourceName, String targetName, Float money) &#123; Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); accountDao.updateAccount(source); accountDao.updateAccount(target); &#125;&#125; 其他xml配置1234567891011&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置数据源--&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?serverTimezone=UTC"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="password"&gt;&lt;/property&gt;&lt;/bean&gt; 基于注解的配置步骤配置事务管理器1234&lt;!--配置事务管理器--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 在业务层使用@Transactional注解1234567891011121314151617181920212223@Service("accountService")@Transactional(readOnly = true, propagation = Propagation.SUPPORTS)public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Transactional(readOnly = false, propagation = Propagation.REQUIRED) public void transfer(String sourceName, String targetName, Float money) &#123; Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); accountDao.updateAccount(source); accountDao.updateAccount(target); &#125;&#125; 该注解的属性和xml中的属性含义一致。该注解可以出现在接口上，类上和方法上。 出现接口上，表示该接口的所有实现类都有事务支持。 出现在类上，表示类中所有方法有事务支持 出现在方法上，表示方法有事务支持。 以上三个位置的优先级：方法&gt;类&gt;接口 在配置文件中开启spring对注解事务的支持12&lt;!--开启spring对注解事务的支持--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 测试代码同上 Spring5的部分新特性JDK升级spring5.0在2017年9月发布了它的GA（通用）版本。该版本是基于jdk8编写的，所以jdk8以下版本将无法使用。同时，可以兼容jdk9版本。 tomcat版本要求8.5及以上。 jdk1.8版本（就是JDK8）运行时间如下： 当切换到jdk1.7版本之后，运行时间如下： 在框架中创建对象通常都是用反射来创建对象的。 核心容器的更新Spring Framework 5.0 现在支持候选组件索引作为类路径扫描的替代方案。该功能已经在类路径扫描器中添加，以简化添加候选组件标识的步骤。 应用程序构建任务可以定义当前项目自己的 META-INF/spring.components 文件。在编译时，源模型是自包含的，JPA 实体和 Spring 组件是已被标记的。 从索引读取实体而不是扫描类路径对于小于 200 个类的小型项目是没有明显差异。但对大型项目影响较大。加载组件索引开销更低。因此，随着类数的增加，索引读取的启动时间将保持不变。 加载组件索引的耗费是廉价的。因此当类的数量不断增长，加上构建索引的启动时间仍然可以维持一个常数, 不过对于组件扫描而言，启动时间则会有明显的增长。 这个对于我们处于大型 Spring 项目的开发者所意味着的，是应用程序的启动时间将被大大缩减。虽然 20 或者 30 秒钟看似没什么，但如果每天要这样登上好几百次，加起来就够你受的了。使用了组件索引的话，就能帮助你每天过的更加高效。 你可以在 Spring 的 Jira上了解更多关于组件索引的相关信息。 结束关于Spring框架的东西大概就这么多了。。。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring--三、Spring的AOP（面向切面编程）]]></title>
    <url>%2F2019%2F10%2F28%2FSpring--%E4%B8%89%E3%80%81Spring%E7%9A%84AOP%EF%BC%88%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[AOP概述什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 AOP的作用及优势 作用： 在程序运行期间，不修改源码对已有方法进行增强。 优势： 减少重复代码 提高开发效率 维护方便 举例说明先举个小栗子，即自产自销，在很久以前我们购买电脑都是直接从厂家手里购买，但是当生产厂家逐渐扩大，销售网络也逐渐扩大，生产厂家则无法顾及越来越大的销售业务，这时候代理商就出现了。他们通过赚取差价来帮助生产厂家销售产品，生产厂家就能专心生产，而中间赚取差价和销售这个操作就是对原有生产商功能的加强。 所以我们现在知道，要想实现AOP，就需要来看一看代理是个什么东西。 代理Proxy为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，代理也可以对被代理类进行增强。 按照代理的创建时期，代理类可以分为两种： 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。 动态：在程序运行时运用反射机制动态创建而成。 注意：被代理类必须继承一个接口，或继承一个类（但是需要第三方类库（CGLib，被代理类不能用final修饰）支持来代理） 静态代理静态代理就是程序员自己手动编写的源代码来对被代理对象进行增强。下面讲一个例子： IUserManager接口是用于规范UserManager类的一个接口。 UserManager类是被代理类，他有创建用户和删除用户两个方法。 UserManagerProxy类是代理类，他将UserManager类的两个方法进行增强（即在不修改源码的基础上添加了一些功能）。 IUserManager： 12345public interface IUserManager &#123; public abstract void addUser(String name); public abstract void deleteUser(String name);&#125; UserManager： 123456789public class UserManager implements IUserManager &#123; public void addUser(String name) &#123; System.out.println("添加了用户：" + name); &#125; public void deleteUser(String name) &#123; System.out.println("删除了用户：" + name); &#125;&#125; UserManagerProxy： 12345678910111213141516171819202122232425262728public class UserManagerProxy implements IUserManager &#123; private UserManager usr; public UserManagerProxy(UserManager usr) &#123; this.usr = usr; &#125; public void addUser(String name) &#123; try &#123; System.out.println("start...addUser"); this.usr.addUser(name); System.out.println("end...addUser"); &#125;catch (Exception e)&#123; System.out.println("error...addUser"); &#125; &#125; public void deleteUser(String name) &#123; try &#123; System.out.println("start...deleteUser"); this.usr.deleteUser(name); System.out.println("end...deleteUser"); &#125;catch (Exception e)&#123; System.out.println("error..deleteUser"); &#125; &#125;&#125; main函数调用： 12345public static void main(String[] args) &#123; IUserManager userManager = new UserManagerProxy(new UserManager()); userManager.addUser("zzz"); userManager.deleteUser("zzz"); &#125; 输出： 添加了用户：zzz end…addUser start…deleteUser 删除了用户：zzz end…deleteUser 看完源码不难发现，其实也就是继承相同的接口，来实现相同的方法，在新类里面来对原有的方法进行增添并调用原有的方法。 缺点： 代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。 静态代理类只能为特定的接口(Service)服务。如想要为多个接口服务则需要建立很多个代理类。 动态代理静态代理一个类只能为一个接口服务，那么必定会产生很多代理类，所以能不能让一个代理类完成全部代理功能呢，这时候就需要动态代理来实现了。 动态代理是利用Java的反射机制在运行时动态代理对象，对于要执行相同扩展操作的类或方法由一个统一的类的invoke方法来实现。动态代理需要用到java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类的newProxyInstance()方法。 InvocationHandler接口的实现类是用于对被代理对象（例如UserManager类）功能进行扩展的类，当被代理对象使用某个方法（例如addUser方法）时，会被InvocationHandler接口的实现类拦截，在InvocationHandler实现类的invoke方法中调用被代理对象的方法，并进行一些代码的扩充。那么Proxy的newProxyInstance方法就是将被代理对象和代理对象绑定起来的方法，将被代理对象的类加载器和被代理类实现的接口对象还有InvocationHandler实现类传入该方法中就能进行绑定。 java.lang.reflect.InvocationHandler接口： 1234567891011public interface InvocationHandler &#123; /** * 该接口的实现类用于拦截被代理对象 * @param proxy 被代理的对象 * @param method 需要调用的方法， * Method类是一个方法类，可以接收方法对象 * @param args 方法调用时所需要的参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; java.lang.reflect.Proxy类的newProxyInstance方法： 12345678910111213141516171819/*** 该方法用于指定被代理对象关联到哪个InvocationHandler上** @param loader 一个ClassLoader（类加载器）对象，* 定义了由哪个ClassLoader对象来对生成的代理对象进行加载** @param interfaces 一个Interface对象的数组，* 表示的是我将要给我需要代理的对象提供一组什么接口，* 如果我提供了一组接口给它，* 那么这个代理对象就宣称实现了该接口(多态)，* 这样我就能调用这组接口中的方法了** @param h 一个InvocationHandler对象，* 表示的是当我这个动态代理对象在调用方法的时候，* 会关联到哪一个InvocationHandler对象上*/public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 这里用到的UserManager类和IUserManager接口和静态代理部分相同： 123456789101112131415public interface IUserManager &#123; public abstract void addUser(String name); public abstract void deleteUser(String name);&#125;public class UserManager implements IUserManager &#123; public void addUser(String name) &#123; System.out.println("添加了用户：" + name); &#125; public void deleteUser(String name) &#123; System.out.println("删除了用户：" + name); &#125;&#125; 接下来要实现java.lang.reflect.InvocationHandler接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 动态代理类只能代理接口（不支持抽象类），代理类都需要实现InvocationHandler类， * 实现invoke方法。该invoke方法就是调用被代理接口的所有方法时需要调用的， * 该invoke方法返回的值是被调用方法的返回值 */public class LogHandler implements InvocationHandler &#123; //被代理的目标对象 private Object targetObject; /** * 绑定关系，也就是关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时， * 执行invoke方法。 */ public Object newProxyInstance(Object targetObject)&#123; this.targetObject = targetObject; /** * 该方法用于指定类加载器，被代理接口， * 及关联的InvocationHandler对象， * 返回一个代理对象 */ return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(),this); &#125; //就是前面的InvocationHandler接口的invoke方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object ret = null; try &#123; System.out.println("start..." + method.getName()); /** * 这里的invoke方法不是InvocationHandler接口中的方法了 * 他是Method类中的invoke方法 * @参数一 调用该方法的对象（例如当调用addUser时就是UserManager对象） * @参数二 调用方法时的参数列表 * @return 返回被调用方法的返回值 */ ret = method.invoke(targetObject, args); System.out.println("end..." + method.getName()); &#125;catch (Exception e)&#123; e.printStackTrace(); System.out.println("error..." + method.getName()); throw e; &#125; return ret; &#125;&#125; main函数调用： 12345678910111213141516public static void main(String[] args) &#123; LogHandler logHandler = new LogHandler(); /** * 此处是创建一个IUserManager接口， * 用newProxyInstance方法创建一个代理对象， * 用强制类型转换将其转换为IUserManager类型。 * * 注意：这里要定义接口（IUserManager）， * 不能定义被代理类（UserManager）， * 因为这里创建的代理对象是继承自接口（IUserManager）的Object对象 */ IUserManager iUserManager = (IUserManager)logHandler.newProxyInstance(new UserManager()); iUserManager.addUser("zzz"); iUserManager.deleteUser("zzz"); &#125; 输出： start…addUser 添加了用户：zzz end…addUser start…deleteUser 删除了用户：zzz end…deleteUser 动态代理的优点： 动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强。 缺点： 性能低下，应尽量避免在性能敏感系统中使用 AOP（AspectOrientedProgramming）：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码—解耦。 正是因为在所有的类里，核心代码之前的操作和核心代码之后的操作都做的是同样的逻辑，因此我们需要将它们提取出来，单独分析，设计和编码，这就是我们的AOP思想。一句话说，AOP只是在对OOP的基础上进行进一步抽象，使我们的类的职责更加单一。 Spring中的AOPSpring中AOP的细节说明我们学习spring的aop，就是通过配置的方式，实现动态代理。 AOP相关术语 Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。 Pointcut(切入点): 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。 Advice(通知/增强): 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。 通知的类型：前置通知(事务开始前),后置通知（事务开始后）,异常通知（发生异常时）,最终通知（在finally里面的）,环绕通知（整个invoke方法）。 Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。 Target(目标对象): 代理的目标对象。 Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 Proxy（代理）: 一个类被AOP织入增强后，就产生一个结果代理类。 Aspect(切面): 是切入点和通知（引介）的结合。 学习spring中的AOP要明确的事 开发阶段（我们做的） 编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。 把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP编程人员来做。 在配置文件中，声明切入点与通知间的关系，即切面。：AOP编程人员来做。 运行阶段（Spring框架完成的）： Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 基于XML的AOP配置在学习基于XML的AOP配置之前先来看看我们的接口及其实现类和公共代码部分： 接口12345public interface IUserManager &#123; void addUser(); void deleteUser(int i); int updateUser();&#125; 实现类123456789101112public class UserManager implements IUserManager &#123; public void addUser() &#123; System.out.println("添加了账户"); &#125; public void deleteUser(int i) &#123; System.out.println("删除了账户" + i); &#125; public int updateUser() &#123; System.out.println("更新了账户"); return 0; &#125;&#125; 公共代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Logger &#123; void beforePringLog()&#123; System.out.println("前置通知开始记录事务"); &#125; void afterReturningPrintLog()&#123; System.out.println("后置通知开始记录事务"); &#125; void afterThrowingPringLog()&#123; System.out.println("异常通知开始记录事务"); &#125; void afterPringLog()&#123; System.out.println("最终通知开始记录事务"); &#125; /** * 环绕通知 * 问题： * 当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： * 通过对比动态代理中的环绕通知代码， * 发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： * Spring框架为我们提供了一个接口：ProceedingJoinPoint。 * 该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 * 该接口可以作为环绕通知的方法参数，在程序执行时， * spring框架会为我们提供该接口的实现类供我们使用。 * spring中的环绕通知： * 它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */ Object aroundPrintLog(ProceedingJoinPoint proceedingJoinPoint)&#123; Object rtValue = null; try &#123; this.beforePringLog(); Object args[] = proceedingJoinPoint.getArgs();//得到方法执行所需的参数 rtValue = proceedingJoinPoint.proceed(args);//明确调用业务层方法（切入点方法） this.afterReturningPrintLog(); return rtValue; &#125;catch (Throwable a)&#123; this.afterThrowingPringLog(); throw new RuntimeException(a); &#125;finally &#123; this.afterPringLog(); &#125; &#125;&#125; XML文件配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--上面这部分在spring的某个页面中复制的--&gt; &lt;!--配置UserManager类--&gt; &lt;bean id="UserManager" class="UserManager"&gt;&lt;/bean&gt; &lt;!--spring中基于XML的AOP配置步骤（此处直接引用黑马教程中的注释，自己写的例子没写什么包） 1、把通知Bean也交给spring来管理 2、使用aop:config标签表明开始AOP的配置 3、使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定通知类bean的Id。 4、在aop:aspect标签的内部使用对应标签来配置通知的类型 我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知 aop:before：表示配置前置通知 method属性：用于指定Logger类中哪个方法是前置通知 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式的写法： 关键字：execution(表达式) 表达式： 访问修饰符 返回值 包名.包名.包名...类名.方法名(参数列表) 标准的表达式写法： public void com.itheima.service.impl.AccountServiceImpl.saveAccount() 访问修饰符可以省略 void com.itheima.service.impl.AccountServiceImpl.saveAccount() 返回值可以使用通配符，表示任意返回值 * com.itheima.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。但是有几级包，就需要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount()) 包名可以使用..表示当前包及其子包 * *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用*来实现通配 * *..*.*() 参数列表： 可以直接写数据类型： 基本类型直接写名称 int 引用类型写包名.类名的方式 java.lang.String 可以使用通配符表示任意类型，但是必须有参数 可以使用..表示有无参数均可，有参数可以是任意类型 全通配写法： * *..*.*(..) 实际开发中切入点表达式的通常写法： 切到业务层实现类下的所有方法 * com.itheima.service.impl.*.*(..) --&gt; &lt;!--配置Logger类--&gt; &lt;bean id="Logger" class="Logger"&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id="logAdvice" ref="Logger"&gt; &lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt; &lt;!-- 配置前置通知：在切入点方法执行之前执行--&gt; &lt;aop:before method="pringLog" pointcut="execution(* *..*.*(..))"&gt;&lt;/aop:before&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个--&gt; &lt;aop:after-returning method="afterReturningPrintLog" pointcut="execution(* *..*.*(..))"&gt;&lt;/aop:after-returning&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个--&gt; &lt;aop:after-throwing method="afterThrowingPringLog" pointcut="execution(* *..*.*(..))"&gt;&lt;/aop:after-throwing&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt; &lt;aop:after method="afterPringLog" pointcut="execution(* *..*.*(..))"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 通用化切入点表达式1234567891011121314151617181920&lt;aop:config&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id="logAdvice" ref="Logger"&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id="pt" expression="execution(* *..*.*(..))"/&gt; &lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt; &lt;aop:before method="beforePringLog" pointcut-ref="pt"&gt;&lt;/aop:before&gt; &lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个--&gt; &lt;aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt"&gt;&lt;/aop:after-returning&gt; &lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个--&gt; &lt;aop:after-throwing method="afterThrowingPringLog" pointcut-ref="pt"&gt;&lt;/aop:after-throwing&gt; &lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt; &lt;aop:after method="afterPringLog" pointcut-ref="pt"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 环绕通知配置123456789101112&lt;aop:config&gt; &lt;!--配置切面 --&gt; &lt;aop:aspect id="logAdvice" ref="Logger"&gt; &lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用。 它还可以写在aop:aspect外面，此时就变成了所有切面可用 --&gt; &lt;aop:pointcut id="pt" expression="execution(* *..*.*(..))"/&gt; &lt;!-- 配置环绕通知 详细的注释请看Logger类中 配置环绕通知后无需再配置其他通知--&gt; &lt;aop:around method="aroundPrintLog" pointcut-ref="pt"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试代码123456789public class test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IUserManager userManager = (IUserManager) ac.getBean("UserManager");//注意这里要定义接口类型 userManager.addUser(); userManager.deleteUser(1); System.out.println(userManager.updateUser()); &#125;&#125; 基于注解的AOP配置 配置spring容器中要扫描的包 在业务层类添加注解@Service 在通知类添加注解@Component并添加@Aspect注解（表示当前是一个切面类） 开启Spring对注解AOP的支持（见xml文件） 配置切入点表达式（见通知类代码） 在各个通知方法上分别添加注解（见通知类代码）（建议只对环绕通知添加注解，其他通知不添加注解，但是给出的代码中所有通知都加上了注解） 实现类123456789101112131415@Service("UserManager")public class UserManager implements IUserManager &#123; public void addUser() &#123; System.out.println("添加了账户"); &#125; public void deleteUser(int i) &#123; System.out.println("删除了账户" + i); &#125; public int updateUser() &#123; System.out.println("更新了账户"); return 0; &#125;&#125; 通知类1234567891011121314151617181920212223242526272829303132333435363738@Component("Logger")@Aspectpublic class Logger &#123; @Pointcut("execution(* *..*.*(..))") private void pt()&#123;&#125; //@Before("pt()") void beforePringLog()&#123; System.out.println("前置通知开始记录事务"); &#125; //@AfterReturning("pt()") void afterReturningPrintLog()&#123; System.out.println("后置通知开始记录事务"); &#125; //@AfterThrowing("pt()") void afterThrowingPringLog()&#123; System.out.println("异常通知开始记录事务"); &#125; //@After("pt()") void afterPringLog()&#123; System.out.println("最终通知开始记录事务"); &#125; @Around("pt()") Object aroundPrintLog(ProceedingJoinPoint proceedingJoinPoint)&#123; Object rtValue = null; try &#123; this.beforePringLog(); Object args[] = proceedingJoinPoint.getArgs(); rtValue = proceedingJoinPoint.proceed(args); this.afterReturningPrintLog(); return rtValue; &#125;catch (Throwable a)&#123; this.afterThrowingPringLog(); throw new RuntimeException(a); &#125;finally &#123; this.afterPringLog(); &#125; &#125;&#125; XML文件配置 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置spring创建容器时要扫描的包--&gt; &lt;context:component-scan base-package="com.cla"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置spring开启注解AOP的支持 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 不使用XML文件配置1234@Configuration @ComponentScan(basePackages="com.cla") @EnableAspectJAutoProxy public class SpringConfiguration &#123; &#125; 接下来请看下一篇。。。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#杂记]]></title>
    <url>%2F2019%2F10%2F16%2FC%20Sharp%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写一些在学C#时不会的一些用法，在百度上搜出来的答案要不没正确的，要不是就是瞎xx说，要不就是说的不清不楚的。 Wpflabellabel标签的内容居中显示注意，是内容、内容、内容。。。如图： 1&lt;Label Name=&quot;alb&quot; Content=&quot;20&quot; FontSize=&quot;60&quot; Margin=&quot;10,10,-2.333,-12.333&quot; Height=&quot;163&quot; HorizontalContentAlignment=&quot;Center&quot; VerticalContentAlignment=&quot;Center&quot;/&gt; 是HorizontalContentAlignment和VerticalContentAlignment两个属性，一个是水平居中，一个是垂直居中，也可以设置其他对齐方式。 MessageBoxMessageBox.Show(&lt;字符串&gt; Text, &lt;字符串&gt; Title, &lt;整型&gt; nType，MessageBoxIcon); 第一个参数是 String 类型，表示提示框里面的 内容； 第二个参数是String 类型，表示提示框的 标题； 第三个参数是整数类型，表示消息框的 类型 ，一般的都使用系统提供的几种类型； 第四个参数是提示框的 图标，比如说警告、提示、问题等等。 File判断文件/文件夹是否存在（参数为字符串）： 12File.Exists(path);//文件Directory.Exists(path);//文件夹 浏览文件的窗体： 12OpenFileDialog dialog = new OpenFileDialog();dialog.ShowDialog();// 该方法会返回一个bool类型，当成功浏览时返回true，否则返回false。 数字保留n位小数这里以两位小数为例 12double x;x.ToString(&quot;0.00&quot;); 如代码所示，想保留几位就在小数点后面放几个0。 或者这样： 12345double a = 10.9876544;int b;b = Convert.ToInt32(a * 100);a = Convert.ToDouble(b);a /= 100; 就是先将a乘100后转化乘整型，这样它的小数部分就丢弃了，之后再转化成double，再除以100。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#方法</tag>
        <tag>Wpf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git教程]]></title>
    <url>%2F2019%2F10%2F15%2FGit%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本教程参考廖雪峰的Git教程 Git是一个分布式版本控制系统 Git安装安装过程请自行百度👀 安装之后要在命令行中设置自己的用户名和邮箱，需要在命令行中输入如下命令： 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 版本库(repository)版本库：你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 创建版本库很简单，即用git打开一个空文件夹，输入： 1git init //初始化一个仓库 要想将文件添加到仓库中，需要分两步 第一步先把文件放到仓库目录或子目录中，然后输入如下命令(例如文件名为：readme.txt)： 1git add readme.txt //将readme.txt文件添加到仓库中 第二步需要用git commit提交到仓库 1git commit -m &quot;wrote a readme file&quot; //将修改提交到仓库并说明 其中- m “xxx”是对本次提交的说明，等同于注释，有助于别人对你提交的理解。 版本控制查看当前仓库的状态(例如什么文件被修改了)： 1git status 若想查看哪个文件具体修改了什么，可以用如下命令： 1git diff readme.txt //查看readme.txt文件具体修改了什么内容 版本回退版本退回有如下几个命令用于查看历史： 123git log//1.git log --pretty=oneline//2.git reflog//3. 查看详细历史提交记录(包括commit_id、作者、日期、提交注释)，确定要退回哪个版本，每个版本都有一个commit_id 可以让每个版本只输出一行，简化输出信息(只显示commit_id和提交注释) 查看历史命令 版本退回命令： 1git reset --hard HEAD^//1. 退回到当前版本的上一个版本，如果想退回上上一个版本就是… HEAD^^，前一百个版本可以用HEAD~100表示。–hard参数暂不讲解。这里的HEAD^也可以替换为想要退回版本的commit_id，由于commit_id很长，只用写前几位能区别于别的版本就行。 例： ​ 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL ​ e475afc93c209a690c39c13a46716e8fa000c366 add distributed ​ eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 这是我当前有的版本，我想回到add distributed版本，我可以再commit_id处填写”HEAD^”或者”e4751fc” 带有(HEAD -&gt; master)的即为当前版本 当退回某一个版本之后再用git log就不能看到原来版本的commit_id了，此时可以用git reflog来查看历史命令，找到commit_id 工作区和暂存区工作区就是我们创建的仓库文件夹。工作区有一个隐藏文件夹是.git，这里是版本库。版本库里面有一个stage（或index）叫暂存区，还有一个git自动创建的master分支，以及指向master分支的指针HEAD 。 当我们git add时是把文件提交到stage中，git commit时是把stage中的所有修改一次性提交到分支中 当你commit过之后，没有对工作区的文件进行修改，那么版本库就变成这样： 管理修改Git管理的是修改而非文件 当你对文件readme.txt进行如下操作时：第一次修改readme.txt-&gt;git add-&gt;第二次修改readme.txt-&gt;git commit。会发现master中的readme.txt文件是第一次修改过的而非第二此修改过的。 如果想让master中的readme.txt文件是第二次修改的：第一次修改readme.txt-&gt;git add(有没有都行)-&gt;第二次修改readme.txt-&gt;git add-&gt;git commit 撤销修改例如撤销对readme.txt文件的修改： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时1git checkout -- readme.txt//1. 把readme.txt文件在工作区的修改全部撤销 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改在commit之前可以先用git status查看哪个文件被修改了，撤销可用如下命令： 1git reset HEAD readme.txt 已经提交了不合适的修改到版本库时，想要撤销本次提交直接使用版本退回就好了呀 删除文件例如删除工作区中的readme.txt文件： 12git rm test.txt//删除git commit//提交 在提交之前如果发现删错了可以用： 1git checkout -- readme.txt 远程仓库git是分布式版本控制，同一个git仓库可以分布到不同的机器上面。而拿一个机器来当作服务器，全天24小时开机，其他人久都可以从这台服务器上把仓库克隆到自己的电脑上了，并且可以把各自的提交推送到服务器仓库中，也可以从服务器仓库拉取别人的提交。 现在我们不需要自己搭建服务器了，我们可以使用GitHub或者码云，但是在国内GitHub速度比较慢。。。下面先以GitHub为例讲解远程仓库。（码云的用法会在后面说到） 创建SSH Key：在用户主目录下看看有没有（.ssh）目录，如果有再看看这个目录下有没有（id_rsa）和（id_rsa.pub）这两个文件，如果都有则可以直接跳到下一步。如果没有，则在用户主目录下用git bash here（Windows）或者用shell（Linux）打开，输入如下命令创建SSH Key： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 这里要把邮箱换成自己的邮箱，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到（.ssh）目录，里面有（id_rsa）和（id_rsa.pub）两个文件，这两个就是SSH Key的秘钥对，（id_rsa）是私钥，不能泄露出去，（id_rsa.pub）是公钥，可以放心地告诉任何人。 ​ 登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴（id_rsa.pub）文件的内容，然后就可以在SSH keys界面看到你添加的密钥。 SSH Key用于绑定将你的电脑和GitHub绑定，GitHub是开源仓库，你在上面提交的代码可以被别人看到。 添加远程仓库先在GitHub创建一个仓库： （这是仓库创建好的样子）我创建了一个名叫test的仓库，刚刚创建的仓库是空的。现在GitHub告诉我们可以从这个仓库克隆出新的仓库，也可以把一个已有的仓库与之关联，然后把本地仓库的内容推送到GitHub仓库。 我这里是在本地也新建了一个叫test的仓库，并且在仓库根目录创建了一个（README.md）的文件。之后根据前面讲过的命令，或者GitHub上面提示的命令将本地test仓库与GitHub上的远程仓库相关联，需要在新建的空文件夹下依次运行如下命令： 12345git initgit add README.mdgit commit -m &quot;wrote a readme file&quot; //1.git remote add origin https://github.com/ZhangZef/test.git //2.git push -u origin master //3. 这里双引号里面为提交注解，前面讲过 这里要把网址换成自己的GitHub仓库地址，提示页面中给出了。origin就是远程仓库的名字，在git中默认这样叫，也可以改成别的，不过不推荐，修改不利于以后和别人合作或者自己忘了。 git push是把当前分支master推送到远程仓库。由于远程库是空的，我们第一次推送时加上-u参数，git不但会把本地的master分支内容推送到远程新的master分支，还会把本地master分支和远程master分支关联起来，在以后的推送和拉取时可以简化命令。 如果已有本地仓库可直接执行后两个命令。 这是推送成功后的样子： 以后只要本地提交过，直接运行：（git push origin master）命令就可以提交 从远程仓库克隆将远程仓库克隆到本地可以用如下命令： 1git clone git@github.com:ZhangZef/test.git 注意要把仓库地址换成自己的地址 分支管理创建并合并分支在git中，master是主分支。master是指向提交的分支，而HEAD是指向当前分支的指针。 一开始，master分支是一条线，git用master指向最新提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点，每次提交，master就向前移动一步。 当我们新建了一个分支dev（自己命名）的时候，git就会新建一个叫dev的指针，指向master相同的提交。再把HEAD指向dev就表示当前分支在dev： 从现在开始，你对工作区的修改和提交就是针对dev分支的了，每提交一次，dev分支就向前挪一步： 我们要想把dev合并到主分支master上，就是把master指针指向dev的位置就可以了： 这时候我们可以把dev分支给删去，他不会修改工作区的任何内容，只会将dev指针删掉： 下面来实际进行上述操作，创建并切换分支用如下命令： 1234git checkout -b dev //1.git branch dev //2.git checkout dev //3.git branch //4. git checkout命令加上-b参数表示创建并切换，dev处可换成你起的分支名 git branch + name表示创建分支 切换到分支 查看当前分支，名字前面带*号的表示当前HEAD指向的分支 我们创建一个新分支dev，并转向dev分支，并在dev分支中做修改然后提交： 之后我们将dev的改变合并到master分支上，先将转向master分支，之后用如下命令： 1git merge dev 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 之后我们就可以将dev删除了，之后运行branch命令就看到只有master分支了： 1git branch -d dev 还有switch命令： 12git switch -c dev //1.git switch master //2. 这个也是创先并转向新分支 这个是转向分支，和checkout用法类似 小结12345678git branch //1.git branch &lt;name&gt; //2.git checkout &lt;name&gt; //3.git switch &lt;name&gt; //4.git checkout -b &lt;name&gt; //5.git switch -c &lt;name&gt; //6.git merge &lt;name&gt; //7.git branch -d &lt;name&gt; //8. 查看分支 创建分支 转向分支 转向分支 创建并转向分支 创建并转向分支 合并分支 删除分支 解决冲突当新建的分支和原来的分支同时向前推进，导致生成了分叉，这时候就发生了冲突，这节要来解决冲突。 我们先新建一个分支dev，并在dev分支修改文件并提交，这样dev分支就比master分支超前了一个提交： 之后我们再切换回master分支，系统就提示我们当前分支比master分支超前了一个分支（这里他显示的超前两次，是因为我的master分支修改过之后没有对远程仓库提交，它显示的‘origin/master’意思是远程仓库的master分支）： 之后我们再在master修改一次并提交： 会发现合并的时候git会提示我们发生冲突（conflict），这时分支的状态是这样的： 我们可以用（git status）来查看哪些文件发生了冲突： 这时git提示我们README.md文件发生了冲突，要我们手动解决冲突，之后我们打开README.md文件查看： 会发现两个分支中的提交分别在文件中提示出来，我们手动修改后再提交即可： 这是修改过的文件，我们将修改过的文件提交后可以用如下命令查看分支合并状态： 1git log --graph --pretty=oneline --abbrev-commit 可以看到我们的分支已经合并完成，这时可以将dev分支删除。 小结git无法自动合并冲突分支，合并后必须手动解决冲突，再提交，用如下命令可以查看分支合并图： 1git log --graph 分支管理策略在一般情况，合并分支时git会使用Fast forward模式进行合并。在这种模式下删除分支后会丢掉分支信息。 fast forward那么什么是fast forward模式呢？假设现在有两个分支，一个是主分支master，另一个是dev分支。 当我们在dev分支做了一个提交为“new 444444”：当HEAD指向dev时我们可以看到“new 444444”这次提交，当我们将HEAD指向master时则看不到这个“new 444444”提交： 这次我们使用fast forward模式进行合并，合并之后的分支图如图所示：可以看出git将“new 444444”这次提交和master分支强行糅合到了一块儿。 接下来我们来看关闭 fast forward模式的合并是什么样子的，这次我先删除了dev分支，又创建了新的dev分支，以避免和前面的混淆，其他操作类似，这次在dev的提交换成了“new 666666”： 可看出这次合并之后git并没有将“new 666666”这次提交和master分支强行糅合在一起。 可用两张图总结一下，第一张为fast forward合并，第二张为非fast forward合并： 看到廖雪峰老师对fast forward这里讲解的不是很清楚，我对这里也有点迷，就动手实践了一下，唠叨唠叨。关闭fast forward可以避免丢失信息，对以后的代码分析很有用（看网上说的👀），不过fast forward模式确实将一部分信息给抹去了，比如上面第一个图，我们就看不出曾经有过dev的痕迹，而第二张图则可以看出原来有某个分支提交了这个功能。 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 如图michael在他自己的分支上工作，bob在他自己的分支上工作，他们每次完成工作都把自己的分支合并到dev分支，当dev分支上的项目稳定下来，则将dev合并到master上。 Bug分支当你正在dev分支中做某项工作时，突然通知让你去修复master分支中的一个非常紧急bug-001，但是你手头的工作一时半会儿也做不完。这时候要先保护工作现场，就像调用函数时，系统会先保护工作现场，将各寄存器中的值压入栈中，再去调用别的函数。 git也提供了一个保护工作现场的功能： 1git stash 可以将当前未提交的修改先存起来，以便bug修复完成后恢复现场。恢复现场的命令如下： 123git stash list //1.git stash apply //2.git stash pop //3. 这个命令用于查看当前有哪些被保存起来的工作现场，这个list其实是一个栈结构，即后进先出。 第二条和第三条命令都是恢复工作现场，但是apply不会删除list中的记录，想要删除还要用（git stash drop），而pop是应用并删除。 master分支中存在bug，那么说明dev分支中一定也存在bug。那么怎么方便快捷地修复dev上的bug呢？ 要先再master分支中查看那个bug分支的commit_id（例如是aadbd3d……，取前几位就行），然后转到转到dev分支使用如下命令： 1git cherry-pick aadbd3e 这样就可以将那次bug修复直接合并到dev分支中，不过还需要手动解决冲突并提交。 Feature分支当新开发功能时，肯定不能从master分支中修改。这时候要从dev分支新建一个feature分支来开发新功能，但是当你开发完新功能提交过还未合并时又被要求取消这个功能，这时候用（git branch -d + 分支名）是删除不了的，因为分支还未合并。git会提示你要用（-D）来删除（例如分支名为feature）： 1git branch -D feature 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。查看远程仓库的信息（第一个是查看信息，第二个是查看详细信息，remote中文翻译是偏僻的、偏远的😁）： 12git remotegit remote -v 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上（比如说要推送master分支，origin是远程仓库的意思）： 1git push origin master 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支想要抓取分支，先要获取你的工程在GitHub上的地址，先在GitHub中打开你的工程，之后（这个按钮是将地址信息复制到粘贴板）： 之后使用（git clone）命令，例如上图中的工程： 1git clone git@github.com:ZhangZef/test.git 但是在GitHub上我的工程有两个分支，一个是master分支，一个是dev分支，当你clone之后使用（git branch）命令时会发现只有一个master分支，这时候想将dev分支也抓取下来要用如下命令： 1git checkout -b dev origin/dev 后面带上（origin/dev）意思是将本地仓的dev分支和远程仓库的dev分支相关联，以后推送拉取的时候git会自动寻找远程仓库和当前推送拉取分支相关联的分支，如果远程仓库没有关联分支： 拉取时则会拉取失败 而推送时没有关联分支且无同名分支则会自动在远程仓库创建新分支，但是创建的新分支并不会和本地仓库的分支相关联，还要手动将远程仓库的分支和本地分支相关联 而推送时没有关联分支且有同名分支则不会发生任何事，没有推送上去，也没有创建新分支 要想关联远程仓库和本地仓库的分支可用如下命令（例如要关联分支是dev）： 1git branch --set-upstream-to=origin/dev dev 当然你也可以指定将本地dev和远程仓库的其他分支相关联，修改origin后面的分支名字即可，但是并不推荐 解决推送冲突当你的小伙伴向远程仓库的dev推送分支推送之后，你再向远程仓库推送时git会提示你产生冲突，并且提示你要用（git pull）命令： 此时就使用（git pull）将远程仓库的分支抓取下来，手动解决冲突再合并（拉取失败时记得关联远程仓库的分支和本地仓库分支）。 Rebase当解决冲突时，后push的人要先pull，再add…commit…push，这样分支图就会变得很杂乱。利用git的rebase（变基）操作可以将解决冲突时的分支图整理成一条直线。（不太理解rebase的操作，回来再写吧，先跳过去） 标签管理标签用于标记某个commit，方便使用。 创建标签12345git tag &lt;name&gt; //1.git tag &lt;name&gt; &lt;commit_id&gt; //2.git tag //3.git show &lt;tagname&gt; //4.git tag -a &lt;tagname&gt; -m &quot;......&quot; //5. 创建一个标签，默认指向当前HEAD指向的提交 指定某一个commit创建标签，用于指定以前的提交未添加标签 查看所有标签 显示某个标签（标签指向的commit）的信息 可以指定某个标签的注解 操作标签1234git tag -d &lt;tagname&gt; //1.git push origin &lt;tagname&gt; //2.git push origin --tags //3.git push origin :refs/tags/&lt;tagname&gt; //4. 删除本地的某个标签 将某个标签推送到远程仓库 一次性推送全部尚未推送到远程的本地标签 删除远程标签，要先删除本地的标签，再使用这个命令删除远程的标签 使用GitHub想要修改别人的文件，就要先fork到自己的仓库，然后才能进行修改提交。当你想要别人能接受你的提交，你就可以在GitHub上发起一个pull request，之后要看别人接受不接受了。 使用码云由于GitHub是国外的网站，国内用户访问时速度有时候令人抓狂。这时候你可以使用国内的git托管服务码云 不过码云的免费git仓库有5人的成员上限。 添加SSH Key的步骤就略过了。 在码云上的git操作和GitHub类似，就不赘述了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>码云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《现代操作系统（第四版）》 课后习题答案--第一章]]></title>
    <url>%2F2019%2F10%2F07%2F%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E3%80%8B-%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88-%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[自己写的，可能会有错误，望大家指正。 第一题 操作系统的两大主要作用是什么？（Page. 1） 解： 为用户程序提供一个更好、更简单、更清晰的计算机模型。 管理cpu、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口等设备。 第二题 在1.4节中描述了9中不同类型的操作系统，列举每种操作系统的应用（每种系统一种应用）。（Page. 20） 解： 大型机操作系统（Mainframe Operating Systems）： 批处理系统应用于保险公司的索赔处理或连锁商店的索赔报告 事务处理系统应用于银行支票处理或航班预定 分时系统应用于大型数据库的查询 服务器操作系统（Server Operating Systems）： 应用于Web站点保存页面并处理进来的请求 多处理器操作系统（Multiprocessor Operating Systems）： Windows和Linux都可以运行在多核处理器上，可谓计算机带来更高的性能 个人计算机操作系统（Personal Computer Operating Systems）： 应用于文字处理、电子表格、游戏和Internet访问 掌上计算机操作系统（Handheld Computer Operating Systems）： 手机的操作系统如Android和ios 嵌入式操作系统（Embedded Operating Systems）： 应用于微波炉、冰箱、电视机、智能家居、汽车等 传感器节点操作系统（Sensor-Node Operating Systems）： 应用于建筑物周边保护、国土边界保卫、森林火灾探测、气象预测等 实时操作系统（Real-Time Operating Systems）： 硬实时系统应用于工业过程控制、民用航空、军事等 软实时系统应用于数字音频或多媒体系统等 智能卡操作系统（Smart Card Operating Systems）： 应用于电子支付等 第三题 分时操作系统和多道程序系统的区别是什么？（Page. 6） 解： 分时操作系统：按一定时间间隔将计算机的轮流分配给程序使用，由于间隔非常短，所以就像每个程序独占一样。 多道程序系统：将内存分为几部分存放不同的程序，一个程序不能让cpu和I/O设备始终忙碌，当cpu的正在执行的作业需要等待某个动作完成才能继续进行（如I/O操作完成），如果是单道程序设计此时cpu会等待，而多道程序设计则会让cpu开始处理另一个作业，提高了cpu的利用率。 区别：分时操作系统是按一定时间间隔将计算资源分配给不同的程序，而多道程序系统则是在当前作业进行其他动作时才回去处理别的作业。 第四题 为了使用高速缓存，主存被划分为若干cache行，通常每行长32或64字节。每次缓存一整个cache行。每次缓存一整行而不是一个字节或一个字，这样做的优点是什么？ 解： 因为程序局部性原理，即当要访问某一个字或字节，则其后面的数据被访问的概率很大，这样就可以提高缓存命中的概率。 第五题 在早期计算机中，每个字节的读写直接由CPU处理（即没有DMA）。对于多道程序而言这种组织方式有什么含义？ 解： DMA（Direct Memory Access）直接存储器访问：当cpu要进行I/O操作时只需要对DMA控制器进行设置，之后DMA控制器会完成cpu给定的工作，而cpu可在此时空闲下来去处理别的事情。 如果每个字节的读写是由cpu读写，则在I/O操作时cpu就不能处理其他程序作业，此时cpu将被I/O操作占用，无法空闲下来，由于I/O操作远慢于cpu的处理速度，cpu运行效率会大幅度下降。若有DMA控制器则在较慢的I/O操作时cpu可以空闲下来去运行别的作业，会使进行I/O操作时cpu效率大幅度提高，也提高了多道程序设计的收益（多道程序概念看第三题）。 第六题 与访问I/O设备相关的指令通常是特权指令，也就是说，他们能在内核态执行而在用户态则不行，说明为什么这些指令是特权指令。 解： 特权指令：具有特殊权限的指令，只能由操作系统调用，在系统的内核态运行。 操作系统的一个主要任务就是给用户提供一个良好的计算机模型，然而这一任务的一个主要准则就是弱化用户对硬件的感知，而I/O操作就是对硬件的直接操作。 进行I/O操作时操作系统往往要检查相应权限，如果I/O操作可以由用户任意调用，则会容易引发系统崩溃。 第七题 系列计算机的思想在20世界60年代由IBM引入System/360大型机。现在这种思想是消亡还是存活？ 解： 这还用问吗，看看不同版本的ipad、surface、相同系列不同配置的电脑。。。 第八题 缓慢采用GUI的一个原因是支持他的硬件的成本高昂，为了支持25行80列的单色文本屏幕，需要多少视频RAM？对于1024x768像素24位色彩图需要多少RAM？在1980年每Kb 5美元，这些RAM成本是多少？现在成本多少？ 每个文本一个字节，则25行80列最大就是25×80字节，即2000字节视频RAM 1024×768个像素，每个像素24位，一字节有8位，则总共是1024×768×24÷8，即2359296字节，2304KB。 1980年成本是11520美元，在今天按jd金士顿8g 2400的内存价格算是0.03125人民币每KB（进制为1024），则其成本是72人民币，按当前美元汇率是10.0732美元。 第九题 在建立一个操作系统时有几个设计目的，例如资源利用、及时性、健壮性等，请列举两个可能相互矛盾的设计目的。 解： 考虑硬实时操作系统，其及时性和可靠性较高，但是健壮性较差，当出错时会导致后续工作无法进行。 第十题 内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同的模式有什么帮助。 解： 内核态：可以无限制地对系统存储、外部设备进行访问，具有最高级别的权限，可以执行cpu的所有指令。 用户态：访问受限制，无法访问外部设备，无法执行特权指令。 区别：相对与用户态，内核态拥有的权力更高，而用户态访问设备都需要内核态来帮助。 对操作系统的帮助： 可以使用户程序不需要接触底层物理设备的细节，仅由一个函数来实现一系列复杂的工作。 保护硬件信息，对用户程序进行限制，当用户程序需要进行某些硬件访问，可以向操作系统申请，操作系统会检查它的权限。 小结 这几题都是偏思维题，觉得这种题要先列举这些东西的性质，再对比总结。 有些名词书上没有讲解，在网上的资料也比较少，可能不太准确 第十一题 一个255GB大小的磁盘有65535个柱面，每个柱面255个扇区。每个扇区512字节。这个磁盘有多少盘片和磁头？假设平均寻道时间为11ms,平均旋转延迟为7ms,读取速度100MB/s,计算从一个扇区读取400kb需要的平均时间。 解： 如图，红色为一个柱面，蓝色为扇区，即每个盘面有若干柱面，每个柱面有若干扇区，每个盘面有一个磁头，每个盘片有两个盘面，也即两个磁头。（用触摸板画的👀） 由此可得每个盘面的存储容量为255×512×65535=‭8556249600‬B=‭8355712.5KB≈8160MB≈8G 所以盘面数即磁头数为255÷8≈32 所以共有16个盘片 平均时间=寻道时间+旋转延迟+读取时间：11ms+7ms+400kb÷(100MB/s×1024÷1000)≈22ms 第十二题 下面哪一条指令只能在内核态使用？ a 禁止所有的中断 b 读日期-时间时钟 c 设置日期-时间时钟 d 改变存储器映像 解：a、c、d 第十三题 考虑一个有两个CPU的系统，且每一个CPU有两个线程（超线程）。假设有三个程序P0、P1、P2，分别以运行时间5ms, 10ms,20ms开始，运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻赛，并且一旦设定就不改变CPU。 不太理解他的线程要怎么算，看百度百科英特尔超线程技术是将cpu内部使用频率较高的部件复制一份，这样就可以提高使用频率较低的部件的使用效率，就可以把他看成两个逻辑线程。但是看网上答案都没有考虑两个线程同时工作的问题。 第十四题 一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns, 这台机器每秒可执行多少条指令？ 解： 1s = 1000000000ns 分成四级流水线，应该是一条指令分成四部分，即每条指令执行时间为4ns，四级流水线图示： 由图可推算出10亿ns可运行1000000000-3条指令 第十五题 假设一个计算机系统有高速缓存、内存(RAM)以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要1ns, RAM需要10ns, 磁盘需要10ms。如果缓存命中率是95%， 内存的是99%（缓存失效时），读取一个词的平均时间是多少？ 解： 10ms = 10000000ns 平均时间即： 1ns×0.95(缓存命中) +10ns×0.05×0.99(缓存未命中内存命中) +10000000ns×0.05×0.01(缓存内存都未命中) =5001.455ns 第十六题 在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？ 不太懂。。。 第十七题 什么是陷阱指令？在操作系统中解释他的用途。 解： 在网上看到好像和tarp指令类似的还有一个叫访管指令(还有人说两个大致相等，没搞明白两个有啥关系)，好像是因为内核态又叫管态，用户态又叫目态。 trap指令是一个非特权指令，他是从用户态进入到内核态唯一的入口，该指令允许用户程序调用特权指令。 第十八题 分时系统中为什么需要进程表？在只有一个进程存在的个人计算机系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？ 解： 进程表是用来管理进程，当分时系统将某些进程挂起时，他们将进入进程表，分时系统从进程表中取出另一个需要处理的进程。 当只有一个进程时不需要，因为他无需管理其他进程。 第十九题 说明有没有理由在一个非空的目录中安装一个文件系统。如果这样做，如何做？ 不太懂，希望有大佬能帮我解答一下。 第二十题 对于下列系统调用，给出引起失败的条件：fork,exec以及unlink. 解： fork：如果在进程表中没有空闲的内存用于创建子进程，则调用失败 exec：当其参数中执行的文件名称错误时 unlink：要删除的目录不存在或者权限不足时 第二十一题 下列资源能使用哪种多路复用（时间、空间或者两者皆可）：CPU、内存、磁盘、网卡、打印机、键盘以及显示器？ 解： 时间复用：CPU、网卡、打印机、键盘 空间复用：内存、磁盘、 两者皆可：显示器 第二十二题 在count = write(fd, buffer,nbytes);调用中，是否能将函数返回值传递给 count除nbtes变量以外的任何值吗？如果能，为什么？（这点书上翻译错了。。。） 解： write返回值：通常与参数nbytes相同，否则表示出错。 若返回-1，表示write系统调用错误。 若返回值为0，则表示没有写入任何数据 第二十三题 有一个文件，其文件描述符是fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。有如下系统调用： 123&gt; lseek(fd, 3, SEEK_SET);&gt; read(fd, &amp;buffer, 4);&gt; 其中lseek调用寻找文件中的字节3。在读操作完成之后，buffer中的内容是什么？ 解： lseek：用于修改指针在文件中的位置。三个参数分别为文件描述、文件中的位置、说明相对于文件的起始位置，当前位置还是结尾。其返回值是文件中的绝对位置。 set我查的有start sth. happening的意思，也许在这里就是开始的意思吧，这个名字起的好抽象，以前都不知道set还有开始的意思。。。所以SEEK_SET就是从文件的开头，从开头算起第三个就是字符1了。 那read就是从字符1开始算4个字符即：1，5，9，2 我不太清楚他的指针是什么机制，但是当运行如下代码 123&gt; lseek(fd, 0, SEEK_SET);//将指针设置在文件的起始位置&gt; //懒得打开Linux试了，还要重启换系统&gt; 如果文件起始位置是1，写的时候是不会从0开始写的，因为0不是一个位置，而是从1开始写，也即指针位置的下一个位置，那么lseek就会把指针设置在下一个要读写位置的前面，即每次读写都从指针的下一位开始读写（好像有些类似STL中的rbegin迭代器，我也记不清楚了）。但是，这个说法和书上的说法相矛盾，书上Page. 32的1.6.2中说“在顺序读(写)时，该指针通常指向要读(写)的下一个字节”。 如果文件起始位置是0，那么lseek会将指针设置在第0位，按书上说，下一次将在第0位开始读(写)，所以题目中的3可能指的就是文件中的第四个字符。 第二十四题 假设一个10MB的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第100号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要1ms，当文件的开始部分存储在的扇区旋转到磁头下需要5ms，并且读的速率是200MB/s。 解： 读取文件时间：(10MB) ÷ (200MB/s) = 0.05s = 50ms 总时间：50ms + 50ms + 5ms = 105ms 第二十五题 块特殊文件和字符特殊文件的基本差别是什么？ 解： 如果一个硬件设备是以字符流的方式被访问的话，那就应该将它归于字符设备；反过来，如果一个设备是随机（无序的）访问的，那么它就属于块设备。块设备常见的是硬盘，而字符设备常见的是键盘等。 块特殊文件和字符特殊文件又叫做块设备和字符设备，在百度查块特殊文件和字符特殊文件基本查不到什么有用的资料，还能索引到有道词典的翻译是什么鬼？？？辣鸡百度。。。而查块设备和字符设备还能查到一些有用的东西。 第二十六题 在图1-17的例子中库调用称为read，而系统调用自身称为read，这两者都有相问的名字是正常的吗？ 如果不是，哪一个更重要？ 解： 书上Page. 29说“第七步：跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分配给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成”， 即这些系统调用其实没有名字，只是一些编号。应该在用户态的read更重要，因为他要写成代码，更抽象且容易被理解。 第二十七题 现代操作系统将进程的地址空间从机器物理内存中分离出来，列举这种设计的两个好处。 解： 他为虚拟内存提出奠定了基础，如果进程地址空间和机器内存一一对应，则就不可能有虚拟内存存在。 防止其他恶意程序或者有bug的程序修改别的程序的内存。 第二十八题 对程序员而言，系统调用就像对其他库过程的调用一样。有无必要让程序员了解哪一个库过程导致了系统调用？在什么情形下，为什么？ 解： 我认为，一个好的库，应该是更抽象、美观。他应该让程序员忽略那些硬件细节和系统细节以达到更高效的开发。 第二十九题 图1-23说明有一批UNIX的系统调用没有与之相等价的Win32 API，对于所列出的每一个没有Win32等价的调用，若程序员要把一个UNIX程序转换到Windows下运行，会有什么后果？ 解： link：在win32中文件将不能以另一个名字出现在其他目录中 mount和unmount：在win32中不能合并两个文件系统，也就必须分清楚哪些文件是在哪个驱动器上面。 chmod：在Win32中不能灵活改变文件的保护属性 kill：在Win32中不能杀死失常的程序 第三十题 可移植的操作系统是能从一个系统体系结构到另一个体系结构的移动不需要任何修改的操作系统。请解释为什么建立一个完全可移植性的操作系统是不可行的。描述一下在设计一个髙度可移植的操作系统时你设计的两个高级层是什么样的。 解： 因为不同的硬件往往都有着自己独有的指令集，而某些硬件专用于实现一些功能，不同功能的指令集往往各不相同。即使功能相同的硬件指令集也不尽相同。 应该有一个用于屏蔽硬件细节吧，类似于计算机网络中的物理层。另一个不知道。。。（什么鬼问题，我对操作系统还不了解了，上来问这种劝退问题） 第三十一题 请解释在建立基于微内核的操作系统时策略与机制的分离带来的好处。 解： 让内核体积更小，将复杂的策略实现交给用户态，使内核做的事情更加专一，效率更高。 第三十二题 虚拟机由于很多因素而十分流行，然而他们也有一些缺点，给出一个缺点。 解： 虚拟机建立在宿主操作系统之上，会给处理器和内存带来很大的开销来使虚拟机看似和宿主操作系统相同。 第三十三题 下面是单位转换的练习： a)一微年是多少秒？ b)微米常称为micron。那么gigamicron是多长？ c) 1TB存储器中有多少字节？ d)地球的质量是6000 yottagram, 换算成kilogram是多少？ 解： 0.000001×365×24×3600 = 31.536s 1000000000×0.000001 = 1000m 2^40字节 6×10^21 kg 参考《现代操作系统（中文第四版）》课后习题答案 第一章 引论]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>现代操作系统</tag>
        <tag>课后习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven]]></title>
    <url>%2F2019%2F10%2F06%2FMaven%2F</url>
    <content type="text"><![CDATA[视频分享 提取码：x8tf Maven的好处及概要maven的好处及核心普通项目通过把jar包复制进工程，而Maven则是建立一个jar包仓库，通过坐标（即公司名称+项目名称+版本号）来向仓库中寻找坐标 maven的两大核心： 依赖管理：对jar包的管理过程 项目构建：项目在编码完成后，对项目进行编译、测试、打包、部署等一系列操作通过命令来实现 通过maven命令将web项目发布到tomcat：mvn tomcat:run maven的配置及仓库maven的组成maven文件组成： 查询maven版本信息：cmd中键入mvn -v maven仓库类型 maven项目标准目录结构 src：项目源码 main：主要代码 java：java代码 recources：配置文件 webapp：页面素材：jsp文件、css文件等等 test：单元测试 java：单元测试类 tarjet：存放编译后的文件（不属于maven标准目录结构） pom.xml：maven项目核心配置文件 maven常用的命令clean：清理命令将已生成的.class文件清理掉（将根目录下的tarjet目录清理掉） compile：编译命令将.java文件编译成.class文件 test：测试命令将项目根目录下：test/java目录下的单元测试类全部执行 类名必须是XxxxTest.java package：打包命令动态打包： web project ……war包 java project ……jar包 将项目打包到根目录下target目录 install：安装命令解决本地多个项目公用一个jar包 将项目打包到本地仓库 maven项目的生命周期在maven项目中存在三套生命周期，每一套生命周期都是相互独立，即执行每一套生命周期中的命令时不会执行其他生命周期中的命令。在一套生命周期中，执行后面的命令，前面的命令会自动执行。 例：当执行install时命令执行顺序：compile -&gt; test -&gt; package -&gt; install CleanLifeCycle：清理生命周期 Clean命令 DefaultLifeCycle：默认生命周期（主要） compile命令 test命令 package命令 install命令 deploy命令 SiteLifeCy：站点生命周期 site命令 maven整合struts2框架 通过工具生成web.xml 添加struts2依赖 创建struts.xml 创建action类 在web.xml中配置struts2框架核心过滤器 编写action中方法 在struts.xml中配置 maven概念模型 概念模型即两大核心： 依赖管理：通过pom.xml文件完成 项目构建：通过生命周期完成]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>依赖管理</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring--二、Spring基于注解的IOC及IOC的案例]]></title>
    <url>%2F2019%2F10%2F04%2FSpring--%E4%BA%8C%E3%80%81Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC%E5%8F%8AIOC%E7%9A%84%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[视频：Spring5教程IDEA版-4天-2018黑马 教学资源 提取码：cwbz 基于注解的IOC配置和xml配置实现的功能都是一样的，都是降低程序间的耦合，只是配置的形式不一样。 Spring中IOC的常用注解注解分类 用于创建对象的：作用和在xml配置文件中写一个bean标签实现的功能相同 用于注入数据的：作用和在xml配置中的bean标签中写一个property标签功能相同 用于改变作用范围的：作用和bean标签使用scope属性实现功能相同 和生命周期相关：作用和在bean标签中使用init-method和destory-method作用相同 环境搭建导入jar包在基于注解的配置中，我们还要将aop的jar包拷贝到lib目录 使用@Component注解配置管理的资源1234567891011121314//账户的业务层实现类 @Component("accountService") public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; &#125; //账户的持久层实现类 @Component("accountDao") public class AccountDaoImpl implements IAccountDao &#123; private DBAssit dbAssit; &#125; 注意：当我们使用注解注入时，set方法不用写。 创建Spring的xml配置文件并开启对注解的支持导入约束时需要多导入一个context名称空间下的约束，并且告知Spring在创建容器时要扫描的包。 常用注解相当于： 1&lt;bean id="" class=""&gt; 用于创建对象的@Component 作用：把资源让Spring来管理，相当于在xml中配置一个bean。 属性： value：指定bean的id。如果不指定value属性，默认bean的id是当前类的类名，首字母小写。 @Controller @Service @Repository这三个注解和Component注解的衍生，作用及属性都是一模一样的，只不过提供了更加明确的语义化： @Controller：一般用于表现层的注解 @Service：一般用于业务层的注解 @Repository：一般用于持久层的注解 细节：如果注解中有且只有一个属性要赋值时，且名称是value，value在赋值时可以不写。 用于注入数据的相当于： 12&lt;property name="" ref=""&gt;&lt;/property&gt;&lt;property name="" value=""&gt;&lt;/property&gt; @Autowired在Spring的IOC容器中寻找变量自动按类型匹配。（容器中的变量即用@Component或其他三个注解的对象）当使用注解注入属性时，set方法可以忽略。它只能注入其他bean类型。 作用： 当只有一个变量的类型匹配时则成功。 当有多个变量的类型匹配时，使用要注解的对象变量名称作为bean的id，在Spring的IOC容器中查找，找到了就可以注入成功，找不到就报错。 出现位置： ​ 可以是变量上，也可以是方法上。 @Qualifier作用：在自动按照类型注入的基础之上，再按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowired一起使用；但是给方法参数注入时，可以独立使用。 属性：value：指定bean的id。 @Resource作用：直接按照Bean的id注入。它也只能注入其他bean类型。 属性：name：指定bean的id @Value作用：注入基本数据类型和String类型数据的 属性： value：用于指定值（可以支持Spring的SpEL表达式：${表达式}） 用于改变作用范围的相当于 1&lt;bean id="" class="" scope=""&gt; @Scope作用： 指定bean的作用范围。 属性： value：指定范围的值。 取值：singleton prototype request session globalsession 和生命周期相关（了解）相当于 1&lt;bean id="" class="" init-method="" destroy-method="" /&gt; @PostConstruct作用： 用于指定初始化方法。 @PreDestroy作用： 用于指定销毁方法。 关于Spring注解和XML的选择问题 注解的优势： 配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。 XML的优势： 修改时，不用改源码。不涉及重新编译和部署。 两者比较： 案例使用xml方式和注解方式实现单表的CRUD操作CRUD即增(Create)、查(Retrieve)、改(Update)、删(Delete) 此处可看链接视频的P35-P38 改造基于注解的IOC案例，使用纯注解的方式实现经过上面的改造，我们还有几种配置需要从xml改成注解配置。 @Configuration作用： 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 属性： value:用于指定配置类的字节码 @ComponentScan作用： 用于指定spring在初始化容器时要扫描的包。作用和在spring的xml配置文件中的： &lt;context:component-scan base-package=”com.itheima”/&gt;是一样的。 属性： basePackages：用于指定要扫描的包。和该注解中的value属性作用一样。 例： 123@Configuration @ComponentScan("com.itheima") public class SpringConfiguration &#123; &#125; @Bean作用： 该注解只能写在方法上，表明使用此方法创建一个对象，将方法的返回值放入spring容器。 属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）（当不写时默认为当前方法的名字）。 细节：当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象，查找方式和Autowired注解的作用是一样的。 例： 1234@Bean(name="dbAssit") public DBAssit createDBAssit(DataSource dataSource) &#123; return new DBAssit(dataSource); &#125; @Import作用： 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解。当然，写上也没问题。 有import的为父配置类，导入的是子配置类。 属性： value[]：用于指定其他配置类的字节码。 1234@Configuration @ComponentScan(basePackages = "com.itheima.spring") @Import(&#123; JdbcConfig.class&#125;) public class SpringConfiguration &#123; &#125; @PropertySource作用：用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。 属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath: 123456789jdbc.properties文件： jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/day44_ee247_springjdbc.username=root jdbc.password=1234@Configuration @PropertySource("classpath:jdbc.properties") public class JdbcConfig&#123; &#125; Spring和Junit的整合JUnit是一个Java编程语言的单元测试框架。 问题及解决思路在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");IAccountService as = ac.getBean("accountService",IAccountService.class); 这两行代码的作用分别是获取容器和创建业务层对象，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。但是测试人员不会管你使用的到底是什么框架，所以可能他根本不知道容器是个什么东西，所以我们需要的是程序能自动帮我们创建容器。 Junit的一个注解可以让我们替换他的运行器，这时我们可以用这个注解将运行器替换为spring框架的运行器，它可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。 配置导入jar包导入spring-test的jar包和spring-aop的jar包。 使用@RunWith注解替换原有运行器例： 12@RunWith(SpringJUnit4ClassRunner.class) public class AccountServiceTest &#123; &#125; 使用@ContextConfiguration指定spring配置文件的位置例： 123@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;) public class AccountServiceTest &#123; &#125; @ContextConfiguration注解： locations属性：用于指定配置文件的位置。如果是类路径下，需要用classpath:表明 classes属性：用于指定注解的类。当不使用xml配置时，需要用此属性指定注解类的位置。 使用@Autowired给测试类中的变量注入数据例： 12345@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;) public class AccountServiceTest &#123; @Autowired private IAccountService as ; &#125; 为什么不把测试类配到xml中 当我们在xml中配置了一个bean，spring加载配置文件创建容器时，就会创建对象。 测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。 接下来请看下一篇。。。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring--一、Spring概述及Spring中基于XML的IOC配置]]></title>
    <url>%2F2019%2F10%2F02%2FSpring--%E4%B8%80%E3%80%81Spring%E6%A6%82%E8%BF%B0%E5%8F%8ASpring%E4%B8%AD%E5%9F%BA%E4%BA%8EXML%E7%9A%84IOC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[视频：Spring5教程IDEA版-4天-2018黑马 教学资源 提取码：cwbz Spring的概述（了解）spring是什么Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。而这次要讲的Spring框架是处于业务层的框架。 Spring的优势 方便解耦，简化开发 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 AOP编程的支持 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀框架 Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。 降低JavaEE API的使用难度 Spring对JavaEE API（如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。 Java源码是经典学习范例 Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 Spring的体系结构 Spring的两大核心为：AOP和IOC AOP部分为：AOP、Aspects、Instrumentation、Messaging IOC（核心容器）部分为Core Container部分 IOC的概念和作用程序的耦合与解耦程序的耦合即程序间的依赖关系：①类之间的依赖关系。②方法间的依赖关系。 解耦即降低程序间的依赖关系，实际开发中应做到编译期不依赖，运行时才依赖： 使用反射（Class.forName()）来创建对象，避免使用new来创建对象。 通过读取配置文件来获取要创建的对象的全限定类名。 配置文件内容：唯一标识=全限定类名（key=value） 工厂模式解耦在实际开发中我们可以把三层（参考JavaEE三层结构：Web(表现)层、业务层、DAO(数据)层）的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 建议了解单例多例对象来提高工厂模式解耦效率。 控制翻转-Inversion Of Control（IOC）控制反转（IOC）即把创建对象的权利交给框架，是框架的重要特征，它包括依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup） 原来我们创建对象是用new来主动创建的，即我们的项目对资源的使用是直接关联的，如图： 现在，我们引入框架的工厂来帮我们创建生产对象，他负责给我们从指定容器中获取指定对象的类，这时候这个对象获取过来是不是我能用的，我们的应用本身已经无法得知了，工厂能得到哪个对象是根据配置文件中的全限定类名（key=value）获得的，我们的应用本身没有自主控制权。而原来的直接new的方法则应用本身是有自主控制权的。所以这种工厂模式降低了我们程序间的依赖关系，如图： 即IOC用来削减计算机程序间的耦合。 使用Spring的IOC解决程序耦合Spring的开发包官网：http://spring.io/ Spring的目录结构： dcos：API和开发规范 libs：jar包和源码 schema：约束 Spring基于XML的IOC细节Spring中工厂的类结构图 BeanFactory和ApplicationContext的区别BeanFactory 才是Spring 容器中的顶层接口。ApplicationContext 是它的子接口。 BeanFactory 和ApplicationContext 的区别：创建对象的时间点不一样。 ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。单例对象适用。常用此接口，Spring会根据对象的单例多例来选择。 BeanFactory：什么使用什么时候创建对象。多例对象适用。 ApplicationContext接口的实现类 ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件 推荐使用这种 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。 IOC中bean标签和管理对象细节bean标签作用： 用于配置对象让spring来创建的。 默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 scope：指定对象的作用范围。 singleton :默认值，单例的. prototype :多例的. request :WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中. session :WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中. global session :WEB项目中,应用在Portlet环境.如果没有Portlet环境那么globalSession相当于session. init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 bean的作用范围和生命周期单例对象：scope=”singleton” 一个应用只有一个对象的实例。它的作用范围就是整个引用。 生命周期： 对象出生：当应用加载，创建容器时，对象就被创建了。 对象活着：只要容器在，对象一直活着。 对象死亡：当应用卸载，销毁容器时，对象就被销毁了。 多例对象：scope=”prototype” 每次访问对象时，都会重新创建对象实例。 生命周期： 对象出生：当使用对象时，创建新的对象实例。 对象活着：只要对象在使用中，就一直活着。 对象死亡：当对象长时间不用时，被java的垃圾回收器回收了。 实例化bean的三种方式第一种方式：使用默认无参构造函数 123&lt;!--在默认情况下： 它会根据默认无参构造函数来创建类对象。如果bean中没有默认无参构造函数，将会创建失败。--&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"/&gt; 第二种方式：spring管理静态工厂-使用静态工厂的方法创建对象 123456/*模拟一个静态工厂，创建业务层实现类*/ public class StaticFactory &#123; public static IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; 123456789&lt;!-- 此种方式是: 使用StaticFactory类中的静态方法createAccountService创建对象，并存入spring容器 id属性：指定bean的id，用于从容器中获取 class属性：指定静态工厂的全限定类名 factory-method属性：指定生产对象的静态方法--&gt; &lt;bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 第三种方式：spring管理实例工厂-使用实例工厂的方法创建对象 123456789/** * 模拟一个实例工厂，创建业务层实现类* 此工厂创建对象，必须现有工厂实例对象，再调用方法 **/public class InstanceFactory &#123; public IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125; &#125; 12345678910&lt;!-- 此种方式是： 先把工厂的创建交给spring来管理。 然后在使用工厂的bean来调用里面的方法 factory-bean属性：用于指定实例工厂bean的id。 factory-method属性：用于指定实例工厂中创建对象的方法。--&gt; &lt;bean id="instancFactory" class="com.itheima.factory.InstanceFactory"&gt;&lt;/bean&gt;&lt;bean id="accountService" factory-bean="instancFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; Spring的依赖注入依赖注入的概念依赖注入是Spring框架核心IOC的具体实现 什么是依赖注入呢？即在当前类需要其他类的对象时，由Spring为我们提供，而不是自己创建，我们只需要在配置文件中说明依赖关系的维护。 依赖注入： 能注入的数据有三类： 基本类型和String 其他bean类型（在配置文件或注解配置过的bean） 复杂类型/集合类型 注入的方式： 使用构造函数提供 使用set方法提供 使用注解提供（下一篇） 构造函数的依赖注入就是通过类的构造函数，给成员变量赋值。赋值操作是通过配置文件的方式，让Spring框架来帮我们注入。一般这种方式用于不经常更变的成员变量。 1234567891011121314151617//这是我们需要调用的类public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125; &#125; 12345678910111213141516171819&lt;!-- 使用构造函数的方式，给service中的属性传值 要求： 类中需要提供一个对应参数列表的构造函数。 涉及的标签： constructor-arg （bean标签内部） 属性： index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 用这个找给谁赋值=======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== value:它能赋的值是基本数据类型和String类型 ref:它能赋的值是其他bean类型，也就是说，必须得是在配置文件中配置过的bean --&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg name="name" value="张三"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; Spring注入的类型默认为字符串，要注入其他bean类型时，他不能强制转换成该类型，需要另外在配置文件中创建一个bean类型，让该类型的构造函数帮我们创建好，再将该类型通过配置文件传入要注入的对象。 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。 弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。 set方法注入就是利用类中提供set方法类设置成员变量的值 123456789101112131415161718public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125; &#125; 123456789101112131415&lt;!-- 通过配置文件给bean中的属性传值：使用set方法的方式 涉及的标签： property（bean标签里面） 属性： name：找的是类中set方法后面的部分 ref：给属性赋值是其他bean类型的 value：给属性赋值是基本数据类型和string类型的 实际开发中，此种方式用的较多。 --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="name" value="test"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;property name="birthday" ref="now"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 优势：创建对象时没有明确的限制，可以直接使用默认构造函数 弊端：如有某个成员必须有值，则获取对象可能set方法没有执行 复杂类型注入本质上还是使用set方法 123456789101112131415161718192021222324252627282930public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- 注入集合数据 List结构的： array,list,set Map结构的 map,entry,props,prop --&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &lt;!-- 给数组注入数据 --&gt; &lt;property name="myStrs"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入list集合数据 --&gt; &lt;property name="myList"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 注入set集合数据 --&gt; &lt;property name="mySet"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Map数据 --&gt; &lt;property name="myMap"&gt; &lt;props&gt; &lt;prop key="testA"&gt;aaa&lt;/prop&gt; &lt;prop key="testB"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 注入properties数据 --&gt; &lt;property name="myProps"&gt; &lt;map&gt; &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt; &lt;entry key="testB"&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 使用P名称空间注入数据通过再xml中导入p名称空间，使用p：propertyName来注入数据，本质还是调用set方法（视频里没讲，可能是少了一集） 123456789101112131415161718public class AccountServiceImpl4 implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125; &#125; 123456789&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl4" p:name="test" p:age="21" p:birthday-ref="now"/&gt; &lt;/beans&gt; 接下来请看下一篇。。。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记--20190923]]></title>
    <url>%2F2019%2F09%2F23%2F%E8%AE%B0-20190923%2F</url>
    <content type="text"><![CDATA[今天的心情可能就像过山车一样，落起落落落落落。。。到晚上的时候已经麻木，什么都无所谓了。。。 蓝桥杯报销关于蓝桥杯报销的事跑了挺长时间了，可能是自己办事能力太差了，每次都像无头苍蝇一样到处乱撞。问了计算机院的老师，还问了16级的辅导员，跑了新区老区，今天终于给他弄完了，不过最后做的不太好，忘记将报销明细给记下来算一算，挺失误的。其实最后挺感谢16级的辅导员的，还是她帮我找的老师去算报销，要不然又得问一大堆人。。。最后办完专门给老师发了个短信谢谢老师。 ACM省赛单项奖学金审核前一段时间导员给我说我的ACM省赛单项奖学金没有过审，我突然一愣，一脸懵逼。当时老师说级别不够，然后我觉得不可能啊，就问老师能不能申诉，可能是自己语气不太好，老师直接说不能。（自己有时候脾气太急了）后来问了学长啥的，又和老师联系了一下，老师也帮忙问了问。最后让我去行政楼问，还专门叮嘱我是去咨询，不是去质问。 今天去了行政楼，那个老师说这个奖从今年开始都不算了。WTM……当时就想怼一句，这个奖不算哪个省赛的奖还有资格算？？？最后说了两句，心里火大的很，可能语气也不太好，就走了。。。 三好学生本来想着今年有希望能申请三好学生的，后来公布名单的时候没有我，心里挺失落的，就和前面那个人综合测评差了0.3分，正正好到我前面一个人，实力不行，无话可说。今天班长和我说我们专业多出来一个三好学生名额，最后导员说我文化课成绩不够年级前百分之三十，没有给我，行吧，莫得办法，菜就是菜。。。 关于考研今天听了某考研机构的讲课，突然感觉要开始学英语和数学了，虽然他讲的有些夸张，想让我们报辅导班，但是英语和数学确实得拉长战线，感觉好紧张啊，还想啃一啃西瓜书和两本黑砖头的操作系统和计网的书了，光这三本砖头就够我看的了，感觉时间不够啊，还要准备接下来的区域赛，卧槽，压力好大啊。。。 总结自己在办事能力和与人交流能力上差太多了，以后对老师和找别人办事一定要忍住脾气，对别人一定要谦逊有礼貌，办完事别忘说谢谢，麻烦您了，和别人打声招呼。对未来这学期的规划也该做一做了，考研英语数学，看书，ACM区域赛。希望能在区域赛拿个牌子，要是什么都没拿到，大学四年真的是废了。。。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>心情</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #587 (Div. 3) 比赛&补题]]></title>
    <url>%2F2019%2F09%2F21%2FCodeforces-Round-587-Div-3-%E6%AF%94%E8%B5%9B-%E8%A1%A5%E9%A2%98%2F</url>
    <content type="text"><![CDATA[tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁 想开始打一打cf，刷题刷的太少了，太吃亏了。 1216A. Prefixes题意给一个字符串，长度为偶数，只包含小写字母a和b，你可以变换其中任意一个字母，把a换成b或者把b换成a。要求最后结果中的字符串任意偶数前缀a和b的数量相同。 题解只需要保证第i个字母和第i+1个字母不相同就行了，i每次递增2。 代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 31;int main()&#123; string s; int n, ans=0; cin &gt;&gt;n &gt;&gt;s; for(int i=0; i&lt;n-1; i+=2) &#123; if(s[i]==s[i+1]) &#123; if(s[i]=='a') s[i] = 'b'; else s[i] = 'a'; ans++; &#125; &#125; cout &lt;&lt;ans &lt;&lt;endl; cout &lt;&lt;s &lt;&lt;endl; return 0;&#125; 1216B. Shooting题意给你几个罐子，每个罐子的耐久度为ai，你要将所有罐子击碎，当你要击碎第i个罐子时，你需要射击(ai*x+1)次，其中x为你已经击碎的罐子，可认为你将一个罐子击碎才会去射击下一个罐子。 题解x是重点，只要反向排一下序就行了，有些类似哈夫曼树。一开始以为最后让依次输出第i个罐子是第几次被射击的，后来WA了一次才发现是让依次输出射击的是第几个罐子。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000+10;struct A&#123; int ai, index;&#125;ax[maxn];bool cmp1(A a, A b)&#123; return a.ai&gt;b.ai;&#125;int main()&#123; int n; cin &gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin &gt;&gt;ax[i].ai; ax[i].index = i+1; &#125; int x=0, ans=0; sort(ax, ax+n, cmp1); for(int i=0; i&lt;n; i++) &#123; ans+=(ax[i].ai*x+1); x++; &#125; cout &lt;&lt;ans &lt;&lt;endl; cout &lt;&lt;ax[0].index; for(int i=1; i&lt;n; i++) cout &lt;&lt;' ' &lt;&lt;ax[i].index; cout &lt;&lt;endl; return 0;&#125; 1216C. White Sheet题意给你一个白纸的左下角和右上角坐标，还有两张黑纸的左下角和右上角坐标，保证这三张纸的边缘都平行于坐标轴，问你黑纸是否能完全覆盖住白纸。 题解坐标范围1e6，可以依次遍历白纸边缘的每一个点，看他是否在黑纸内，递增要设成0.5，不能设成1，最后没时间了，不知道思路对不对，回来再来补吧。（补：果然过了，太智障了。。。） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+10;int main()&#123; int x1, y1, x2, y2; int x3, y3, x4, y4; int x5, y5, x6, y6; cin &gt;&gt;x1 &gt;&gt;y1 &gt;&gt;x2 &gt;&gt;y2; cin &gt;&gt;x3 &gt;&gt;y3 &gt;&gt;x4 &gt;&gt;y4; cin &gt;&gt;x5 &gt;&gt;y5 &gt;&gt;x6 &gt;&gt;y6; for(double i=x1; i&lt;=x2; i+=0.5) &#123; if((i&lt;=x4&amp;&amp;i&gt;=x3&amp;&amp;y1&lt;=y4&amp;&amp;y1&gt;=y3) || (i&lt;=x6&amp;&amp;i&gt;=x5&amp;&amp;y1&lt;=y6&amp;&amp;y1&gt;=y5)) continue; else &#123; cout &lt;&lt;"YES" &lt;&lt;endl; return 0; &#125; &#125; for(double i=y1; i&lt;=y2; i+=0.5) &#123; if((i&lt;=y4&amp;&amp;i&gt;=y3&amp;&amp;x1&lt;=x4&amp;&amp;x1&gt;=x3) || (i&lt;=y6&amp;&amp;i&gt;=y5&amp;&amp;x1&lt;=x6&amp;&amp;x1&gt;=x5)) continue; else &#123; cout &lt;&lt;"YES" &lt;&lt;endl; return 0; &#125; &#125; for(double i=x2; i&gt;=x1; i-=0.5) &#123; if((i&lt;=x4&amp;&amp;i&gt;=x3&amp;&amp;y2&lt;=y4&amp;&amp;y2&gt;=y3) || (i&lt;=x6&amp;&amp;i&gt;=x5&amp;&amp;y2&lt;=y6&amp;&amp;y2&gt;=y5)) continue; else &#123; cout &lt;&lt;"YES" &lt;&lt;endl; return 0; &#125; &#125; for(double i=y2; i&gt;=y2; i-=0.5) &#123; if((i&lt;=y4&amp;&amp;i&gt;=y3&amp;&amp;x2&lt;=x4&amp;&amp;x2&gt;=x3) || (i&lt;=y6&amp;&amp;i&gt;=y5&amp;&amp;x2&lt;=x6&amp;&amp;x2&gt;=x5)) continue; else &#123; cout &lt;&lt;"YES" &lt;&lt;endl; return 0; &#125; &#125; cout &lt;&lt;"NO" &lt;&lt;endl; return 0;&#125; 1216D. Swords题意地下室有n种剑，每种剑有x个，有y个人来地下室偷剑，每个人只拿一种剑，每个人拿了z个剑。现在发现地下室的剑被偷了，每种剑剩下ai个，其中x, y, z未知，给出n和ai，让你求出最少y个人来偷剑和每个人偷了多少剑z。 题解用最大的数依次减去其他所有ai，求他们所有的最大公因数，然后再用前面算出来的最大数和其他数的差除以最大公因数，则可算出有多少人来偷剑了，最大公因数即为每个人偷了多少剑。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5+10;int a[maxn];stack&lt;int&gt; s, ss;bool cmp(int x, int y)&#123; return x&gt;y;&#125;int main()&#123; int n; scanf("%d", &amp;n); for(int i=0; i&lt;n; i++) scanf("%d", &amp;a[i]); sort(a, a+n, cmp); int x, y; for(int i=1; i&lt;n; i++) &#123; x = a[0]-a[i]; if(x) &#123; s.push(x); ss.push(x); &#125; &#125; while(s.size()&gt;1) &#123; x = s.top(); s.pop(); y = s.top(); s.pop(); s.push(__gcd(x, y)); &#125; ll ans=0; while(!ss.empty()) &#123; x = ss.top(); ss.pop(); ans+=(x/s.top()); &#125; printf("%lld %d\n", ans, s.top()); return 0;&#125; 1216E1. Numerical Sequence (easy version)题意11212312341234512345612345671234567812345678912345678910……，给你一个这样的无限循环数列，1、12、123、1234、12345……这样循环，询问q次，每次询问在这个数列中第k位是什么数字。注意：11算两位数字，而不是一个数字。k最大为1e9，q不大于100。 题解 由程序算出当k为1e9时总共也才21837个数，所以我们只用预处理出前1e5个数的排列，预处理时记录下每个数的最后一位排到哪里了，最后直接查表就行了。 计算程序： 12345678ll k=0, i=1, x; while(k&lt;=1000000000)&#123; for(ll j=1; j&lt;=i; j++)&#123; x = j; while(x)&#123;k++;x/=10;&#125; &#125; i++; &#125; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#define ll long longusing namespace std;const int maxn = 1e5+10;int num[maxn*5], pre[maxn], n;inline void cal(int x)&#123; if(!x) return; cal(x/10); num[++n] = x%10; return;&#125;int main()&#123; int x; n = 0; for(int i=1; i&lt;=100000; i++) &#123; cal(i); pre[i] = n; &#125; int q; ll k; cin &gt;&gt;q; while(q--) &#123; cin &gt;&gt;k; ll sum=0; for(int i=1; i&lt;100000; i++) &#123; if(sum+pre[i]&lt;k) sum+=pre[i]; else &#123; cout &lt;&lt;num[k-sum] &lt;&lt;endl; break; &#125; &#125; &#125; return 0;&#125; 参考准点的星辰Codeforces Round #587(Div.3)]]></content>
      <categories>
        <category>比赛&amp;补题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbin专题一简单搜索]]></title>
    <url>%2F2019%2F09%2F19%2Fkuangbin%E4%B8%93%E9%A2%98%E4%B8%80%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[tips：大家评论的时候写一下邮箱和昵称呀，头像是根据昵称和邮箱随机生成的😁 kuangbin专题合集 ACM正确入门方式——数学lover ——————————分割线—————————— 2020-01-27更新快要考研了，在acm里面也没什么成就，唉下学期还要参加蓝桥杯，就趁寒假在家复（yu）习考研课程的间隙练一练题吧，蓝桥杯报的Java组，水一个国奖算了，大学四年最后两个愿望了，蓝桥杯拿个国奖＋考研顺利，加油！！！ 2020-0202更新 终于把暑假挖的坑给填上了，接下来要开始专题四，这几天都没有背单词看高数，得多看一看了。 ——————————分割线—————————— 题目列表 POJ 1321 棋盘问题 AC: 2018-07-17 23:54:31 POJ 2251 Dungeon Master AC: 2019-09-19 18:32:04 POJ 3278 Catch That Cow AC: 2019-09-21 19:37:10 POJ 3279 Fliptile AC: 2019-09-22 16:09:25 POJ 1426 Find The Multiple AC: 2019-09-23 20:09:26 POJ 3126 Prime Path AC: 2019-09-24 22:48:09 POJ 3087 Shuffle’m Up AC: 2020-01-31 18:33:39 POJ 3414 Pots AC: 2020-02-01 18:51:43 FZU 2150 Fire Game 待定，oj挂了 UVA 11624 Fire! AC: 2020-02-02 16:13:29 POJ 3984 迷宫问题 AC: 2020-01-27 22:42:36 HDU 1241 Oil Deposits AC: 2020-02-02 17:05:05 HDU 1495 非常可乐 AC: 2020-01-31 16:58:53 HDU 2612 Find a way AC: 2020-02-02 17:58:08 POJ-1321 棋盘问题题意就是在棋盘上放棋子，放的时候不能同行同列，和八皇后问题类似，只不过空白的地方不能放。这是我去年暑假acm训练时写的，现在已经忘了当时咋写的了，看着自己WA了好多发，太菜了。。。dfs时记得复原。 题解dfs吧，没什么可说的，八皇后模板题。好烦啊，POJ不能用万能头文件。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;//#include &lt;bits/stdc++.h&gt;#include &lt;string.h&gt;typedef long long ll;const int INF = 1 &lt;&lt; 30;const int maxn = 1e5;using namespace std;int n, m, ans;char pan[10][10];bool vis[10];int cnt;void dfs(int l)&#123; if(cnt == m) &#123; ans++; return; &#125; else if(l&gt;=n) return; else &#123; for(int i=0; i&lt;n; i++) if(pan[l][i]=='#' &amp;&amp; !vis[i]) &#123; cnt++; vis[i]=1; dfs(l+1); vis[i]=0; cnt--; &#125; dfs(l+1); &#125; return;&#125;int main()&#123; //ios::sync_with_stdio(0), cin.tie(0); while(cin &gt;&gt;n &gt;&gt;m) &#123; if(n==-1 &amp;&amp; m==-1) break; memset(vis, 0, sizeof(vis)); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++) cin &gt;&gt;pan[i][j]; ans = cnt = 0; dfs(0); cout &lt;&lt;ans &lt;&lt;endl; &#125; return 0;&#125; POJ-2251 Dungeon Master题意一个3D迷宫，总共六个方向，上下左右前后。有的地方不能走有的能走，给出起点终点，问你能不能走到终点，如果能的话应该是求用时最短的吧（题目中没说，一开始用dfsWA了，后来看别人都用bfs才发现是不是要求最短路）。没移动一次要花费一分钟。 题解bfs，一开始用bfs一直内存超限，快给我郁闷死了。。。要把走过的点用#堵上，防止多余的结点入队列。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 31;struct node&#123; int x, y, z, step;&#125;;node make_node(int x, int y, int z, int step)&#123; node a; a.x = x, a.y = y, a.z = z, a.step=step; return a;&#125;int main()&#123; int l, r, c; char mp[maxn][maxn][maxn]; int dx[6]= &#123;1, -1, 0, 0, 0, 0&#125;; int dy[6]= &#123;0, 0, 1, -1, 0, 0&#125;; int dz[6]= &#123;0, 0, 0, 0, 1, -1&#125;; while (cin &gt;&gt;l &gt;&gt;r &gt;&gt;c &amp;&amp; l+r+c) &#123; int x, y, z; queue&lt;node&gt; q; for(int i=0; i&lt;l; i++) &#123; for(int j=0; j&lt;r; j++) for(int k=0; k&lt;c; k++) &#123; cin &gt;&gt;mp[i][j][k]; if(mp[i][j][k]=='S') q.push(make_node(i, j, k, 0)); if(mp[i][j][k]=='E') &#123; x = i; y = j; z = k; &#125; &#125; getchar(); &#125; bool flag = false; while(!q.empty()) &#123; node a = q.front(); q.pop(); if(a.x==x &amp;&amp; a.y==y &amp;&amp; a.z==z) &#123; flag = true; cout &lt;&lt;"Escaped in "&lt;&lt;a.step &lt;&lt;" minute(s)." &lt;&lt;endl; break; &#125; for (int i = 0; i &lt; 6; ++i) &#123; if(mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]]!='#') if(a.x+dx[i]&gt;=0 &amp;&amp; a.x+dx[i]&lt;l &amp;&amp; a.y+dy[i]&gt;=0 &amp;&amp; a.y+dy[i]&lt;r &amp;&amp; a.z+dz[i]&gt;=0 &amp;&amp; a.z+dz[i]&lt;c) &#123; q.push(make_node(a.x+dx[i], a.y+dy[i], a.z+dz[i], a.step+1)); mp[a.x+dx[i]][a.y+dy[i]][a.z+dz[i]] = '#'; &#125; &#125; &#125; if(flag) continue; else cout &lt;&lt;"Trapped!" &lt;&lt;endl; &#125; return 0;&#125; POJ-3287 Catch That Cow题意你的牛跑了，要把它抓回来。你的位置在n，牛的位置在k，牛不会跑，你要用最少的时间走到牛的位置。你们的位置都在同一个数轴上，只有左右两个方向，你有三种走法，左走一步、右走一步或者传送到你当前坐标的二倍的位置，这三种走法都只花费一分钟。n和k都小于等于100000 题解只有三种操作，求最短时间，可以用bfs。bfs要设置一个vis数组，注意不能数组越界。还要注意当n==k的时候。一开始一直超内存，后来发现要设一个vis数组剪枝。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 1e5+10;bool vis[maxn];struct node&#123; int p, t;&#125;;node make_node(int p, int t)&#123; node a; a.p = p; a.t = t; return a;&#125;int main()&#123; int n, k; while(cin &gt;&gt;n &gt;&gt;k) &#123; if(n==k) &#123; cout &lt;&lt;0 &lt;&lt;endl; continue; &#125; memset(vis, 0, sizeof vis); queue&lt;node&gt; q; q.push(make_node(n, 0)); vis[n] = true; while(!q.empty()) &#123; node a = q.front(); q.pop(); if(a.p+1==k || a.p-1==k || a.p*2==k) &#123; cout &lt;&lt;a.t+1 &lt;&lt;endl; break; &#125; if(a.p&lt;k) &#123; if(a.p+1&lt;=100000 &amp;&amp; !vis[a.p+1]) &#123; q.push(make_node(a.p+1, a.t+1)); vis[a.p+1] = true; &#125; if(a.p*2-k&lt;k-a.p &amp;&amp; a.p*2&lt;=100000 &amp;&amp; !vis[a.p*2]) &#123; q.push(make_node(a.p*2, a.t+1)); vis[a.p*2] = true; &#125; if(a.p-1&gt;=0 &amp;&amp; !vis[a.p-1]) &#123; q.push(make_node(a.p-1, a.t+1)); vis[a.p-1] = true; &#125; &#125; else if(a.p&gt;k &amp;&amp; a.p-1&gt;=0 &amp;&amp; !vis[a.p-1]) &#123; q.push(make_node(a.p-1, a.t+1)); vis[a.p-1] = true; &#125; &#125; &#125; return 0;&#125; POJ-3279 Fliptile题意有n*m个方格，每个方格都有一块瓷砖，瓷砖的两面分别是黑色和白色，当你翻转瓷砖时瓷砖会从白色翻转成黑色，或者从黑色翻转成白色。样例输入为每个方格瓷砖的初始颜色，0代表白色，1代表黑色。现在让你的奶牛来将所有格子翻成白色，由于奶牛的蹄子比较大，它每次反转的时会将相邻的瓷砖也翻转过来，即上下左右的瓷砖。最后输出每个瓷砖的翻转次数，要求总的翻转次数最少，如果答案有多种，则输出字典序最小的那个答案。 题解这题有个最重要的思想，就是第i层如果有黑色瓷砖，要通过第i+1层的翻转将其翻转成白色。这样只用保证前一层没有黑色即可，不用管当前层翻转成什么样，也不用管下一层。这样的话只要第一层的状态确定，后面所有的状态都确定了。因为第二层需要将第一层的黑瓷砖翻成白色的，这个过程中第二层可能会出现黑瓷砖，再用第三层将第二层翻转成白色的，再用第四层将。。。我们可以枚举第一层所有的状态，即每一块瓷砖翻或不翻，总共有2^m个，然后用第二层将第一层翻成白色。。。用最后一层将倒数第二层翻成白色，因为后面没有瓷砖来翻转最后一层了，所有我们通过判断最后一层有没有黑色瓷砖，就可以判断这个方法是否可行。 输出次数最少的那一个可以每次翻转记录一下，最后对比所有可能性的翻转次数取最小即可。 字典序最小，即输出答案时每行的字典序最小，每行的字典序即把所有数字串成一个字符串，让他们字典序最小，即将0 0 0 1 1串成00011，而00011的字典序比10010小。保证字典序最小可以先保证第一行字典序最小，第一行有2^m种可能，我们把没个瓷砖看成二进制的一位数，那第一行的所有操作就是0~(1&lt;&lt;m-1)，我们枚举的时候直接从0开始枚举就行了。 一开始写的时候怎么想都没思路，最后看了别人的题解才写出来，还是做题太少了，太菜了。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 30;const int INF = 1 &lt;&lt; 30;int n, m, turnnum, turnans;int mp[maxn][maxn], a[maxn][maxn], fn[maxn][maxn], ans[maxn][maxn];int dx[] = &#123; 1, -1, 0, 0 &#125;;int dy[] = &#123; 0, 0, 1, -1 &#125;;void turn(int i, int j)&#123; fn[i][j] = 1; turnnum++; a[i][j] = !a[i][j]; for (int k = 0; k &lt; 4; k++) a[i + dx[k]][j + dy[k]] = !a[i + dx[k]][j + dy[k]];&#125;int main()&#123; while (cin &gt;&gt;n &gt;&gt;m) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mp[i][j]; &#125; &#125; int lp = 1 &lt;&lt; m; turnans = INF; for (int i = 0; i &lt; lp; i++) &#123; memset(fn, 0, sizeof fn); memcpy(a, mp, sizeof mp); turnnum = 0; int p = i; for (int j = 1; j &lt;= m; j++) &#123; if (p &amp; 1) turn(1, j); p &gt;&gt;= 1; &#125; for (int j = 2; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= m; k++) &#123; if (a[j - 1][k]) turn(j, k); &#125; &#125; int j; for (j = 1; j &lt;= m; j++) &#123; if (a[n][j]) break; &#125; if (j == m+1 &amp;&amp; turnnum &lt; turnans) &#123; turnans = turnnum; memcpy(ans, fn, sizeof fn); &#125; &#125; if (turnans == INF) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl; else &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cout &lt;&lt; ans[i][j] &lt;&lt; ' '; &#125;cout &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 参考POJ3279 二进制的搜索 POJ-1426 Find The Multiple题意给你一个不超过200的数n，让你求一个数m，m不超过100位，m只包含0和1且（m%n）== 0。 题解不知道为什么，直接定义longlong + BFS就过了。。。一开始想模拟，还超时了，菜。。。 在网上看到有个大佬在用这题讲同余模定理，抽空看一下。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int maxn = 1e5+10;queue&lt;int&gt; q;int main()&#123; unsigned ll n, m=1; while(cin &gt;&gt;n &amp;&amp; n) &#123; while(!q.empty())q.pop(); m = 1; q.push(m); if(m%n==0) &#123; cout &lt;&lt;m &lt;&lt;endl; continue; &#125; while(!q.empty()) &#123; m = q.front(); q.pop(); m *= 10; if(m%n==0) &#123; cout &lt;&lt;m &lt;&lt;endl; break; &#125; q.push(m); m += 1; if(m%n==0) &#123; cout &lt;&lt;m &lt;&lt;endl; break; &#125; q.push(m); &#125; &#125; return 0;&#125; POJ-3126 Prime Path题意测试数据不超过一百组，每组给出两个四位素数，要求你将第一个数字变换成第二个数字。没回只能变换一位数字，而且首位数字不能变成0，变换过的数字也必须为素数。每次变换需要花1磅，问你从第一个数字变换到第二个数字最小花费是多少。 题解最少花费，肯定BFS了，先用线性素数筛打个表，每次进队的数据查表时间复杂度为O(1)，然后每一层循环，要把四位数字全换一遍，换一个数字进一次队列，用vis数组剪枝。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int maxn = 1e5+10;int prime[maxn], pNum = 0;bool p[maxn] = &#123;false&#125;, vis[maxn]=&#123;false&#125;;struct num&#123; int a, cos;&#125;;num make_num(int a, int cos)&#123; num x; x.a = a; x.cos = cos; return x;&#125;void eulerSieve(int n)&#123; for (int i = 2; i &lt;= n; i++) &#123; if (p[i] == false) prime[pNum++] = i; for (int j = 0; j &lt; pNum; j++) &#123; if (i * prime[j] &gt; n) break; p[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main()&#123; eulerSieve(100000); int t; cin &gt;&gt;t; while(t--) &#123; memset(vis, false, sizeof vis); int a, b; cin &gt;&gt;a &gt;&gt;b; queue&lt;num&gt; q; q.push(make_num(a, 0)); vis[a] = true; while(!q.empty()) &#123; num x = q.front(); q.pop(); if(x.a==b) &#123; cout &lt;&lt;x.cos &lt;&lt;endl; break; &#125; for(int i=1; i&lt;10; i++) &#123; int y = x.a; if(y/1000==i) continue; y = i*1000+y%1000; if(!vis[y] &amp;&amp; !p[y]) &#123; q.push(make_num(y, x.cos+1)); vis[y] = true; &#125; &#125; for(int i=0; i&lt;10; i++) &#123; int y = x.a; if(y/100%10==i) continue; y = (y/1000*10+i)*100+y%100; if(!vis[y] &amp;&amp; !p[y]) &#123; q.push(make_num(y, x.cos+1)); vis[y] = true; &#125; &#125; for(int i=0; i&lt;10; i++) &#123; int y = x.a; if(y%100/10==i) continue; y = (y/100*10+i)*10+y%10; if(!vis[y] &amp;&amp; !p[y]) &#123; q.push(make_num(y, x.cos+1)); vis[y] = true; &#125; &#125; for(int i=0; i&lt;10; i++) &#123; int y = x.a; if(y%10==i) continue; y = y/10*10+i; if(!vis[y] &amp;&amp; !p[y]) &#123; q.push(make_num(y, x.cos+1)); vis[y] = true; &#125; &#125; &#125; &#125; return 0;&#125; POJ-3087 Shuffle’m Up题意根本不是搜索题，就是简单的模拟题。。。给你两组牌s1,s2，每组牌的数量相同，分为两个步骤洗牌和分牌。洗牌：分别从s1和s2底部每次抽一张牌放到桌上，先从s2的底部开始抽，组成一组牌s12（类似于入栈操作）。分牌：将组成的s12再分成s1和s2，将s12下半部分组成s1，将s12的上半部分组成s2。牌的颜色总共有A~H种，现在又给一组牌s3，问经过几次洗牌能将牌洗成s3的样子，如果可以则输出数据组序号和洗牌次数，不能则输出数据组序号和-1 。（序号从1开始） 题解一开始看到题要求最少的洗牌次数，以为要用bfs，然后在想怎么用bfs的时候发现他每一步的操作都只有固定的一种，没什么可搜索的啊，才发现就是个暴力模拟题。就是用队列模拟洗牌和发牌的过程，如果不能洗成目标牌组的话会发现洗着洗着s1和s2又回到原来的样子了，这个手算一下样例的第二组数据就知道了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int n = cin.nextInt(); for (int i = 0; i &lt; n; i++) &#123; int x = cin.nextInt(); String s1 = cin.nextLine(); s1 = cin.nextLine(); String s2 = cin.nextLine(); String s3 = cin.nextLine(); Queue&lt;Character&gt; queue = new LinkedList&lt;Character&gt;(); String s4 = s1, s5 = s2; boolean flag = false; int step = 0; while (true) &#123; step++; for (int j = 0; j &lt; s1.length(); j++) &#123; queue.offer(s5.charAt(j)); queue.offer(s4.charAt(j)); &#125; String ss = ""; for (int j = 0; j &lt; 2 * x; j++) &#123; ss += queue.peek(); queue.offer(queue.peek()); queue.poll(); &#125; if (ss.equals(s3)) &#123; flag = true; break; &#125; s4 = ""; s5 = ""; for (int j = 0; j &lt; x; j++) &#123; s4+=queue.peek(); queue.poll(); &#125; for (int j = 0; j &lt; x; j++) &#123; s5+=queue.peek(); queue.poll(); &#125; if (s4.equals(s1) &amp;&amp; s5.equals(s2))&#123; break; &#125; &#125; if (flag)&#123; System.out.println(i+1 + " " + step); &#125;else &#123; System.out.println(i+1 + " " + -1); &#125; &#125; &#125;&#125; POJ-3414 Pots题意这题和HDU1495非常可乐太像了，不过比那个复杂一些，操作方法变了一下，而且需要回溯记录路径。感觉是可乐问题+迷宫问题。。。一开始有两个空罐子A和B，每个罐子都有固定容量（倒水题惯例），问你经过一系列操作是否可以使得任意一个罐子中的水有C升，如果可以则求最少操作次数和所有操作步骤，如果不可以则输出”impossible”。操作有如下几种： 将A或B灌满水 将A或B的水全部倒掉 将A的水倒给B，或将B的水倒给A 题解求最少操作次数和操作步骤，用bfs+回溯，vis去重。（用java写这种题代码好长啊，而且感觉我写的代码好笨重） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import java.util.*;class Pot &#123;//用于记录每个状态 int a, b; int step; public Pot(int a, int b, int step) &#123; this.a = a; this.b = b; this.step = step; &#125; public Pot(Pot x) &#123; this.a = x.a; this.b = x.b; this.step = x.step; &#125;&#125;class View &#123;//vis数组 boolean v; int op;//操作种类 int prex, prey;//前驱结点&#125;public class Main &#123; static String[] opt = new String[]&#123;//所有操作种类，方便输出 "FILL(1)", "FILL(2)", "DROP(1)", "DROP(2)", "POUR(1,2)", "POUR(2,1)" &#125;; static View[][] vis = new View[105][105]; public static void print(int x, int y) &#123; if (vis[x][y].prex != -1 &amp;&amp; vis[x][y].prey != -1) print(vis[x][y].prex, vis[x][y].prey); if (vis[x][y].op != -1) System.out.println(opt[vis[x][y].op]); return; &#125; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int A = cin.nextInt(); int B = cin.nextInt(); int C = cin.nextInt(); for (int i = 0; i &lt; 105; i++) &#123; for (int j = 0; j &lt; 105; j++) &#123; vis [i][j] = new View(); vis[i][j].v = false; &#125; &#125; vis[0][0].v = true; vis[0][0].op = -1; vis[0][0].prex = -1; vis[0][0].prey = -1; Queue&lt;Pot&gt; queue = new LinkedList&lt;Pot&gt;(); Pot now = new Pot(0, 0, 0); queue.offer(now); boolean flag = false; while (!queue.isEmpty()) &#123; now = queue.peek(); queue.poll(); if (now.a == C || now.b == C) &#123; flag = true; break; &#125; for (int i = 0; i &lt; 6; i++) &#123; Pot next = new Pot(now); if (i == 0 &amp;&amp; next.a != A &amp;&amp; !vis[A][next.b].v) &#123; vis[A][next.b].v = true; vis[A][next.b].op = 0; vis[A][next.b].prex = now.a; vis[A][next.b].prey = now.b; next.a = A; next.step++; queue.offer(next); continue; &#125; if (i == 1 &amp;&amp; next.b != B &amp;&amp; !vis[next.a][B].v) &#123; vis[next.a][B].v = true; vis[next.a][B].op = 1; vis[next.a][B].prex = now.a; vis[next.a][B].prey = now.b; next.b = B; next.step++; queue.offer(next); continue; &#125; if (i == 2 &amp;&amp; next.a != 0 &amp;&amp; !vis[0][next.b].v) &#123; vis[0][next.b].v = true; vis[0][next.b].op = 2; vis[0][next.b].prex = now.a; vis[0][next.b].prey = now.b; next.a = 0; next.step++; queue.offer(next); continue; &#125; if (i == 3 &amp;&amp; next.b != 0 &amp;&amp; !vis[next.a][0].v) &#123; vis[next.a][0].v = true; vis[next.a][0].op = 3; vis[next.a][0].prex = now.a; vis[next.a][0].prey = now.b; next.b = 0; next.step++; queue.offer(next); continue; &#125; if (i == 4 &amp;&amp; next.a != 0 &amp;&amp; next.b != B) &#123; int vo = B - next.b; if (next.a &gt; vo) &#123; next.a -= vo; next.b = B; &#125; else &#123; next.b += next.a; next.a = 0; &#125; if (!vis[next.a][next.b].v) &#123; vis[next.a][next.b].v = true; vis[next.a][next.b].op = 4; vis[next.a][next.b].prex = now.a; vis[next.a][next.b].prey = now.b; next.step++; queue.offer(next); &#125; continue; &#125; if (i == 5 &amp;&amp; next.a != A &amp;&amp; next.b != 0) &#123; int vo = A - next.a; if (next.b &gt; vo) &#123; next.b -= vo; next.a = A; &#125; else &#123; next.a += next.b; next.b = 0; &#125; if (!vis[next.a][next.b].v) &#123; vis[next.a][next.b].v = true; vis[next.a][next.b].op = 5; vis[next.a][next.b].prex = now.a; vis[next.a][next.b].prey = now.b; next.step++; queue.offer(next); &#125; continue; &#125; &#125; &#125; if (flag)&#123; System.out.println(now.step); print(now.a, now.b); &#125;else &#123; System.out.println("impossible"); &#125; &#125;&#125; FZU-2150 Fire Game题意一个n×m的地图，有的地方是草，有的地方是空的，选两个点同时点火，问是否能将地图上的草烧完，如果是则求出最短燃烧时间。火烧到相邻带有草的格子所需要的时间为1，相邻表示上下左右的格子（即过一个时间，其上有左右有草的格子同时着火），选择的两个点可以相同 题解双起点bfs，我的方法比较笨，先用bfs求出图中草有几个不相邻的分区，如果分区数大于2肯定不能完成，因为最多只能选择两个起点烧，如果两个一下，则将每个分区中的所有点分别加入一个队列，依次从该分区的每个点进行一次bfs遍历该分区，求出其中用时最短的。（由于oj挂了，我也没有测试，只过了样例，但是觉得这题应该没什么坑，而且数据也挺小的，总共才1e6，所以先写着，以后等可以交了我再改一下） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import java.util.*;class Point &#123; char ch; int index, x, y, step; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public Point() &#123; &#125;&#125;public class Main &#123; static int[] dx = &#123;1, -1, 0, 0&#125;; static int[] dy = &#123;0, 0, 1, -1&#125;; static void reset(Point[][] mp)&#123; for (int i = 0; i &lt; 15; i++) &#123; for (int j = 0; j &lt; 15; j++) &#123; mp[i][j].step = 0; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int t = cin.nextInt(); Point[][] mp = new Point[15][15]; for (int i = 0; i &lt; 15; i++) &#123; for (int j = 0; j &lt; 15; j++) &#123; mp[i][j] = new Point(); mp[i][j].x = i; mp[i][j].y = j; &#125; &#125; for (int i = 0; i &lt; t; i++) &#123; int n = cin.nextInt(), m = cin.nextInt(); String s = cin.nextLine(); for (int j = 0; j &lt; n; j++) &#123; s = cin.nextLine(); for (int k = 0; k &lt; s.length(); k++) &#123; mp[j][k].ch = s.charAt(k); mp[j][k].index = -1; mp[j][k].step = 0; &#125; &#125; Queue&lt;Point&gt; queue = new LinkedList&lt;Point&gt;(); Queue&lt;Point&gt; q1 = new LinkedList&lt;Point&gt;(); Queue&lt;Point&gt; q2 = new LinkedList&lt;Point&gt;(); int num = 0; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; m; k++) &#123; if (mp[j][k].ch == '#' &amp;&amp; mp[j][k].index == -1) &#123; Point now = mp[j][k]; now.index = num; if (num==0)q1.offer(now); else q2.offer(now); queue.offer(now); while (!queue.isEmpty()) &#123; now = queue.peek(); queue.poll(); for (int l = 0; l &lt; 4; l++) &#123; if (now.x + dx[l] &gt;= 0 &amp;&amp; now.x + dx[l] &lt; n &amp;&amp; now.y + dy[l] &gt;= 0 &amp;&amp; now.y + dy[l] &lt; m &amp;&amp; mp[now.x + dx[l]][now.y + dy[l]].ch == '#' &amp;&amp; mp[now.x + dx[l]][now.y + dy[l]].index==-1) &#123; mp[now.x + dx[l]][now.y + dy[l]].index = num; queue.offer(mp[now.x + dx[l]][now.y + dy[l]]); if (num==0)q1.offer(mp[now.x + dx[l]][now.y + dy[l]]); else q2.offer(mp[now.x + dx[l]][now.y + dy[l]]); &#125; &#125; &#125; num++; &#125; &#125; &#125; if (num&gt;2)&#123; System.out.println("Case " + (i+1) + ": " + -1); continue; &#125; int t1=10000, t2=10000; while (!q1.isEmpty())&#123; char[][] mmp = new char[15][15]; for (int j = 0; j &lt; 15; j++) &#123; for (int k = 0; k &lt; 15; k++) &#123; mmp[j][k] = mp[j][k].ch; mp[j][k].step = 0; &#125; &#125; while (!queue.isEmpty()) queue.poll(); Point now = q1.peek(); q1.poll(); queue.offer(now); mmp[now.x][now.y] = '.'; while (!queue.isEmpty())&#123; now = queue.peek(); queue.poll(); for (int j = 0; j &lt; 4; j++) &#123; if (now.x + dx[j] &gt;= 0 &amp;&amp; now.x + dx[j] &lt; n &amp;&amp; now.y + dy[j] &gt;= 0 &amp;&amp; now.y + dy[j] &lt; m &amp;&amp; mmp[now.x + dx[j]][now.y + dy[j]] == '#')&#123; mmp[now.x + dx[j]][now.y + dy[j]] = '.'; mp[now.x + dx[j]][now.y + dy[j]].step = now.step+1; queue.offer(mp[now.x + dx[j]][now.y + dy[j]]); &#125; &#125; &#125; t1 = Math.min(t1, now.step); &#125; if (num==2)&#123; while (!q2.isEmpty())&#123; char[][] mmp = new char[15][15]; for (int j = 0; j &lt; 15; j++) &#123; for (int k = 0; k &lt; 15; k++) &#123; mmp[j][k] = mp[j][k].ch; mp[j][k].step = 0; &#125; &#125; while (!queue.isEmpty()) queue.poll(); Point now = q2.peek(); q2.poll(); queue.offer(now); mmp[now.x][now.y] = '.'; while (!queue.isEmpty())&#123; now = queue.peek(); queue.poll(); for (int j = 0; j &lt; 4; j++) &#123; if (now.x + dx[j] &gt;= 0 &amp;&amp; now.x + dx[j] &lt; n &amp;&amp; now.y + dy[j] &gt;= 0 &amp;&amp; now.y + dy[j] &lt; m &amp;&amp; mmp[now.x + dx[j]][now.y + dy[j]] == '#')&#123; mmp[now.x + dx[j]][now.y + dy[j]] = '.'; mp[now.x + dx[j]][now.y + dy[j]].step = now.step+1; queue.offer(mp[now.x + dx[j]][now.y + dy[j]]); &#125; &#125; &#125; t2 = Math.min(t2, now.step); &#125; &#125; if (t1==10000 || t2==10000) System.out.println("Case " + (i+1) + ": " + Math.min(t1, t2)); else System.out.println("Case " + (i+1) + ": " + Math.max(t1, t2)); &#125; &#125;&#125; UVA-11624 Fire!题意火烧屁股，赶紧窜。。。逃出迷宫，只要是挨着迷宫边缘的点都可以逃出迷宫。 题解注意，本题起始时间可能有多个起始火苗！！！（一开始我也没注意到，偶然间在vj的评论里看到的不然我可能也被坑死了）其实就是个bfs的题，数据量比较大，容易超时，要注意一点。应该让火苗先走人再走，我是让每个人走过的点和被火苗烧过的点都变成墙，这样后来走的时候就不会再走了。我把火苗和人放在了两个队列里面了，一开始想复杂了，每个点都有一个属性step，用来记录当前时间，如果进入下一个时间点就让该时间点的火苗全部走一遍，然后再让人走。后来看到别人让火苗和人放在一个队列里面了，只有一开始处理一下，先让所有起始的火苗先进队列，再让人的起始点进入队列就可以了。（不过我后来把我的代码改成这样超时了，就懒得再改了，一开始调试时用的输出代码忘记删了，他还给我判超时，我懵逼了好一会儿。。。） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.*;class Point &#123; int x, y, step; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public Point() &#123; &#125; public void setPoint(int x, int y, int step) &#123; this.x = x; this.y = y; this.step = step; &#125; public Point(int x, int y, int step) &#123; this.x = x; this.y = y; this.step = step; &#125; public Point(Point point) &#123; this.x = point.x; this.y = point.y; this.step = point.step; &#125;&#125;public class Main &#123; static int[] dx = &#123;1, -1, 0, 0&#125;; static int[] dy = &#123;0, 0, 1, -1&#125;; static char[][] mp = new char[1005][1005]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int t = cin.nextInt(); while (t-- &gt; 0) &#123; int r = cin.nextInt(), c = cin.nextInt(); String s = cin.nextLine(); Queue&lt;Point&gt; Fire = new LinkedList&lt;Point&gt;(); Queue&lt;Point&gt; queue = new LinkedList&lt;Point&gt;(); Point now = new Point(); for (int i = 0; i &lt; r; i++) &#123; s = cin.nextLine(); for (int j = 0; j &lt; s.length(); j++) &#123; mp[i][j] = s.charAt(j); if (mp[i][j] == 'F') &#123; mp[i][j] = '#'; Fire.offer(new Point(i, j, 0)); &#125; if (mp[i][j] == 'J') &#123; mp[i][j] = '#'; now.setPoint(i, j, 0); queue.offer(now); &#125; &#125; &#125; int CurStep = -1; boolean flag = false; while (!queue.isEmpty()) &#123; now = queue.peek(); queue.poll(); if (now.y == 0 || now.y == c - 1 || now.x == 0 || now.x == r - 1) &#123; flag = true; break; &#125; if (now.step &gt; CurStep) &#123;//先烧火 CurStep++; Point CurFire; while (!Fire.isEmpty()) &#123; CurFire = Fire.peek(); if (CurFire.step != CurStep) break; Fire.poll(); for (int i = 0; i &lt; 4; i++) &#123; Point next = new Point(CurFire); next.step++; next.x += dx[i]; next.y += dy[i]; if (next.x &gt;= 0 &amp;&amp; next.x &lt; r &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; c &amp;&amp; mp[next.x][next.y] != '#') &#123; mp[next.x][next.y] = '#'; Fire.offer(next); &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; Point next = new Point(now); next.step++; next.x += dx[i]; next.y += dy[i]; if (next.x &gt;= 0 &amp;&amp; next.x &lt; r &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; c &amp;&amp; mp[next.x][next.y] != '#') &#123; mp[next.x][next.y] = '#'; queue.offer(next); &#125; &#125; &#125; if (flag) System.out.println(now.step+1); else System.out.println("IMPOSSIBLE"); &#125; &#125;&#125; POJ-3984 迷宫问题太久没写题了，先拿个简单的练练手吧 Java在OJ交题有好多坑啊，这有一篇比较不错的博客讲的挺全的：JAVA在OJ上提交程序的注意事项（一定要带上包名，别问我为什么知道的（手动狗头）。用Java写题总感觉怪怪的） 题意给一个5×5的迷宫，1是墙，0是路，求出从左上角到右下角的最短路径并输出路径上每个结点的坐标，只能横着走或竖着走，不能斜着走。 题解用bfs求最短路嘛，再定义一个Point结构体，记录前驱结点，最后用递归输出路径。注意逗号后面有一个空格。 其实他这个题的测试数据只有一个，就是样例。。。我看vj上面有人说直接把样例输出就过了。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.*;class Point&#123; int x, y; int prex, prey; int dis; public Point(int x, int y)&#123; this.x = x; this.y = y; &#125; public Point()&#123;&#125;&#125;public class Main &#123; public static int[] dx = &#123;1, -1, 0, 0&#125;; public static int[] dy = &#123;0, 0, 1, -1&#125;; public static Point[][] p = new Point[5][5]; public static void print_point(int x, int y)&#123; if(x==0 &amp;&amp; y==0)&#123; System.out.println("(" + x + ", " + y + ")"); return; &#125; print_point(p[x][y].prex, p[x][y].prey); System.out.println("(" + x + ", " + y + ")"); &#125; public static void main(String [] args)&#123; int[][] mp = new int[5][5]; Scanner cin = new Scanner(System.in); Queue&lt;Point&gt; q = new LinkedList&lt;Point&gt;(); for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; p[i][j] = new Point(); &#125; &#125; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; mp[i][j] = cin.nextInt(); &#125; &#125; Point point = new Point(0, 0); point.dis = 0; point.prex = 0; point.prey = 0; q.offer(point); while (!q.isEmpty())&#123; Point pp = q.peek(); if (pp.x==4 &amp;&amp; pp.y==4) break; for (int i = 0; i &lt; 4; i++) &#123; int xx = pp.x + dx[i]; int yy = pp.y + dy[i]; if(xx&gt;=0 &amp;&amp; xx&lt;5 &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;5 &amp;&amp; mp[xx][yy]!=1)&#123; mp[xx][yy] = 1; p[xx][yy].x = xx; p[xx][yy].y = yy; p[xx][yy].prex = pp.x; p[xx][yy].prey = pp.y; p[xx][yy].dis = pp.dis+1; q.offer(p[xx][yy]); &#125; &#125; q.poll(); &#125; print_point(4, 4); &#125;&#125; HDU-1241 Oil Deposits题意求分块儿数目 题解注意第二个样例，相邻的意思是相邻的八个格不是四个格好像用dfs和bfs都可以，习惯了用bfs我就写了bfs。每找到一个油田，就用bfs遍历这个油田，将油田的所有‘@’变为‘*’就可以了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.*;class Point &#123; int x, y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public Point(Point point) &#123; this.x = point.x; this.y = point.y; &#125;&#125;public class Main &#123; static int[] dx = &#123;1, -1, 0, 0, 1, 1, -1, -1&#125;; static int[] dy = &#123;0, 0, 1, -1, 1, -1, 1, -1&#125;; static char[][] mp = new char[105][105]; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); while (true) &#123; int n = cin.nextInt(), m = cin.nextInt(); if (n==0 || m==0) break; int ans = 0; String s = cin.nextLine(); Queue&lt;Point&gt; queue = new LinkedList&lt;Point&gt;(); for (int i = 0; i &lt; n; i++) &#123; s = cin.nextLine(); for (int j = 0; j &lt; s.length(); j++) &#123; mp[i][j] = s.charAt(j); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (mp[i][j] == '@')&#123; ans++; Point now = new Point(i, j); queue.offer(now); while (!queue.isEmpty()) &#123; now = queue.peek(); queue.poll(); for (int k = 0; k &lt; 8; k++) &#123; Point next = new Point(now); next.x += dx[k]; next.y += dy[k]; if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; mp[next.x][next.y] == '@') &#123; mp[next.x][next.y] = '*'; queue.offer(next); &#125; &#125; &#125; &#125; &#125; &#125; System.out.println(ans); &#125; &#125;&#125; HDU-1495 非常可乐题意有三个杯子，s,n,m，每个被子都有自己的最大容量，初始时s装着满杯可乐。问最少经过几次倒水的步骤，能让其中两个杯子的可乐相等。由于每个杯子都没有刻度，所以每次倒水只能将一个杯子的可乐全部倒进另一个杯子，或者将另一个杯子倒满。（我一开始没理解这个，连样例都没看懂，一直在想他到底怎么倒水的） 题解这题有两种解法，一种比较好想的bfs，另一种是数论（我不会。。。）给出网上dalao链接：HDU 1495 非常可乐（数论） bfs解法：当s中的初始为奇数时肯定不可平分。用一个类记录每个倒水的状态，包括当前每个杯子多少水和经过了多少步骤，每次倒水只有六种倒法：s-&gt;n，s-&gt;m，n-&gt;s，m-&gt;s，n-&gt;m，m-&gt;n，每次遍历这六种方法就行了。然后判断倒水的终止状态：任意两个杯子量相等且另一个杯子为空时才满足条件。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.*;class cola &#123; int[] cup = new int[3]; int step;&#125;public class Main &#123; public static boolean[][][] vis = new boolean[105][105][105]; public static void main(String[] args) &#123; int s, n, m; Scanner cin = new Scanner(System.in); while (true) &#123; s = cin.nextInt(); n = cin.nextInt(); m = cin.nextInt(); if (s == 0 &amp;&amp; n == 0 &amp;&amp; m == 0) &#123; break; &#125; if (s % 2 == 1) &#123; System.out.println("NO"); continue; &#125; for (int i = 0; i &lt; 105; i++) &#123; for (int j = 0; j &lt; 105; j++) &#123; for (int k = 0; k &lt; 105; k++) &#123; vis[i][j][k] = false; &#125; &#125; &#125; vis[s][0][0] = true; cola now = new cola(); now.cup[0] = s; now.cup[1] = 0; now.cup[2] = 0; now.step = 0; Queue&lt;cola&gt; queue = new LinkedList&lt;cola&gt;(); queue.offer(now); boolean flag = false; while (!queue.isEmpty()) &#123; now = queue.peek(); queue.poll(); if ((now.cup[0]==now.cup[1] &amp;&amp; now.cup[2]==0) || (now.cup[0]==now.cup[2] &amp;&amp; now.cup[1]==0) || (now.cup[1]==now.cup[2] &amp;&amp; now.cup[0]==0))&#123; System.out.println(now.step); flag = true; break; &#125; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (i != j) &#123; cola next = new cola(); next.step = now.step; System.arraycopy(now.cup, 0, next.cup, 0, 3); int co = 0; if (j == 0) co = s - next.cup[j]; if (j == 1) co = n - next.cup[j]; if (j == 2) co = m - next.cup[j]; if (next.cup[i] &gt; co) &#123; next.cup[i] -= co; next.cup[j] += co; &#125; else &#123; next.cup[j] += next.cup[i]; next.cup[i] = 0; &#125; next.step += 1; if (!vis[next.cup[0]][next.cup[1]][next.cup[2]]) &#123; vis[next.cup[0]][next.cup[1]][next.cup[2]] = true; queue.offer(next); &#125; &#125; &#125; &#125; &#125; if (!flag)&#123; System.out.println("NO"); &#125; &#125; &#125;&#125; HDU-2612 Find a way题意地图上有好几个kfc（话说我也好久没吃kfc，好想吃kfc的薯条啊，不蘸番茄酱的。疫情太严重了，还是在家敲代码复习考研课吧。。。没事还能打一打无限火力，太快乐了），要求出两个起点到kfc最短的时间，移动到上下左右相邻结点要花的时间是11（为啥是11，是不是出题人单身太久了）。题目保证一定有解 题解又是bfs，bfs，bfs。。。从两个点分别做一次bfs，要注意两个人不是同时出发的，到达时间是两个人所花时间之和。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.util.*;class Point &#123; int x, y, step; public Point(int x, int y, int step) &#123; this.x = x; this.y = y; this.step = step; &#125; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public Point(Point point) &#123; this.x = point.x; this.y = point.y; this.step = point.step; &#125;&#125;public class Main &#123; static int[] dx = &#123;1, -1, 0, 0&#125;; static int[] dy = &#123;0, 0, 1, -1&#125;; static char[][] mp = new char[205][205]; static boolean[][] vis = new boolean[205][205]; static int[][] KFC = new int[205][205];//记录每个kfc的时间 public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); while (cin.hasNextInt()) &#123; int n = cin.nextInt(), m = cin.nextInt(); int ans = Integer.MAX_VALUE; int yx = 0, yy = 0, mx = 0, my = 0; String s = cin.nextLine(); Queue&lt;Point&gt; queue = new LinkedList&lt;Point&gt;(); for (int i = 0; i &lt; n; i++) &#123; s = cin.nextLine(); for (int j = 0; j &lt; s.length(); j++) &#123; mp[i][j] = s.charAt(j); vis[i][j] = false; KFC[i][j] = 0; if (mp[i][j] == 'Y') &#123; yx = i; yy = j; &#125; if (mp[i][j] == 'M') &#123; mx = i; my = j; &#125; &#125; &#125; Point now = new Point(yx, yy, 0); queue.offer(now); vis[yx][yy] = true; while (!queue.isEmpty()) &#123; now = queue.peek(); queue.poll(); if (mp[now.x][now.y] == '@') KFC[now.x][now.y] = now.step * 11; for (int k = 0; k &lt; 4; k++) &#123; Point next = new Point(now); next.step++; next.x += dx[k]; next.y += dy[k]; if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; mp[next.x][next.y] != '#' &amp;&amp; !vis[next.x][next.y]) &#123; vis[next.x][next.y] = true; queue.offer(next); &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; vis[i][j] = false; &#125; &#125; while (!queue.isEmpty()) queue.poll(); now = new Point(mx, my, 0); queue.offer(now); vis[yx][yy] = true; while (!queue.isEmpty()) &#123; now = queue.peek(); queue.poll(); if (mp[now.x][now.y] == '@')&#123; KFC[now.x][now.y] += now.step * 11; ans = Math.min(KFC[now.x][now.y], ans); &#125; for (int k = 0; k &lt; 4; k++) &#123; Point next = new Point(now); next.step++; next.x += dx[k]; next.y += dy[k]; if (next.x &gt;= 0 &amp;&amp; next.x &lt; n &amp;&amp; next.y &gt;= 0 &amp;&amp; next.y &lt; m &amp;&amp; mp[next.x][next.y] != '#' &amp;&amp; !vis[next.x][next.y]) &#123; vis[next.x][next.y] = true; queue.offer(next); &#125; &#125; &#125; System.out.println(ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>蓝桥杯</tag>
        <tag>搜索</tag>
        <tag>bfs记录最短路径</tag>
        <tag>bfs</tag>
        <tag>dfs</tag>
        <tag>双起点bfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tarjan求有向图的强连通分量]]></title>
    <url>%2F2019%2F09%2F02%2Ftarjan%E6%B1%82%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%2F</url>
    <content type="text"><![CDATA[tarjan到底是念“塔进”还是“塔扬”。好像大多数人都念“塔进”，但是英语好像是念“塔扬”。胡扯结束。。。 这个tarjan算法求的是有向图中的强连通分量，并将他们合并。 强连通分量（如果会可以直接看tarjan部分）那什么是强连通分量呢？强连通嘛，就是图中任意两点能相互到达。那强连通分量就是一个图中的强连通子图。 环是最简单的强连通分量： 那你如果从1出发，只要转一圈就能经过所有点。 强连通分量不等于环，还有一些复杂的强连通分量，例如完全图： 很明显能看出从图中一点出发，可到达其他任意一个点。 tarjan算法先上时间复杂度：O(N+M) （其中N和M分别为点数和边数） tarjan算法是通过对图的dfs来找出其中的强连通分量，并分类。（需掌握dfs的思想并且能熟练运用） dfn数组和low数组讲解这里给出tarjan算法中两个重要数组的定义： ​ dfn[u]：表示当前结点i在dfs算法中第几个被访问的的点。 ​ low[u]：表示当前结点i能回溯到的最小dfs序结点，dfs序即dfn[u]的值。 （6-&gt;1的箭头画反了，应该时1-&gt;6） 当从结点1开始dfs时，假设优先向下访问：dfn[1] = 1; dfn[6] = 2;因为第一个访问的时结点1，所以它的dfs序是1，第二个访问的是结点6，所以它的dfs序时2。访问完结点6发现没有路了，则开始访问结点1的下一条出边。 开始访问结点2，刚刚访问的结点6是第二个访问的结点，所以结点2是第三个访问的结点，即它的dfs序为3：dfn[2] = 3; dfn[5] = 4; dfn[4] = 5; dfn[3] = 6;我们顺着结点2依次访问下去，发现只有一条路，畅通无阻。 当访问到结点三的时候我们发现结点3有一条通向结点2的路，则此时我们称结点3回溯到结点2。我们还发现dfn[2]&lt;dfn[3]，即结点2在dfs中比结点3先被访问。此时我们在dfs回溯的过程中令：low[3] = dfn[2]; low[4] = dfn[2]; low[5] = dfn[2];即令回溯路上的所有点的low数组都赋值为结点2的dfs序。 由此我们经历了一遍tarjan的简化步骤，我们能发现low数组的取值为： 12345low[u] = min( dfn[u],//1. dfn[v],//2. low[v]//3.) low数组初始化时为当前结点的dfs序，即low[u] = dfn[u]; 这里的v是边（u, v）中的v，和上图中边（3, 2）类似。当发现能回溯到的结点dfs序小于自身dfs序时更新low的值 这里的（u, v）和上图中的（4, 3）类似。dfs回溯过程中时发现前面结点的low值小于自身的low值时，更新自身low值 从图中可看出2， 5， 4， 3四个结点为一个环，环是最简单的强连通分量，所以2， 5， 4， 3为一个强连通分量。而单独一个结点我们也将他看成一个强连通分量，因此图中有三个强连通分量：（1）（6）（2，4，5，3） 从中我们观察出1， 6， 2的dfn值和low值相同，所以当dfn[u]==low[u]时，它就是一个强连通分量在dfs树中的起始节点 tarjan算法伪代码讲解12345678910111213141516tarjan(u)&#123; DFN[u]=Low[u]=++Index//1. Stack.push(u)//2. for each (u, v) in E//3. if (v is not visted)//4. tarjan(v)//dfs Low[u] = min(Low[u], Low[v]) else if (v in S)//5. Low[u] = min(Low[u], DFN[v]) if (DFN[u] == Low[u])//6. repeat v = S.pop//7. print v until (u== v)&#125; 为结点u初始化dfn和low的值为dfs时的访问顺序，index为全局变量 将结点u压入栈中 遍历结点u的每一条边 如果没访问过 如果v在栈中 上面讲过，当dfn[u]==low[u]时，该节点为强连通分量根结点 将栈顶元素出栈，直到栈顶元素为u时，u出栈，则此次出栈的一系列元素为一个强连通分量 （6-&gt;1的箭头画反了，应该时1-&gt;6） 从结点1开始：dfn[1] = low[1] = 1; 结点1进栈 1-&gt;6：dfn[6] = low[6] = 2; 结点6进栈结点6没有出边，无法dfs，发现dfn[6]==low[6]，栈顶元素出栈，栈顶元素正好时结点6，无需继续出栈，则结点6自己为一个单独的强联通分量。 1-&gt;2：dfn[2] = low[2] = 3；结点2进栈结点2有出边且为访问，开始dfs。 2-&gt;5：dfn[5] = low[5] = 4；结点5进栈结点5有出边且未访问，继续dfs 5-&gt;4：dfn[4] = low[4] = 5；结点4进栈结点4有未访问的出边，继续dfs 4-&gt;3：dfn[3] = low[3] = 6；结点3进栈结点3有出边，但结点2已经访问过了，且结点2在栈里面，所以3可以回溯到结点2，可知dfn[2]=3, low[3]=6; 所以low[3] = dfn[2] = 3; 此时dfn[3]!=low[3]，所以不出栈。 当dfs回溯到5-&gt;4的时候，发现(low[4]=5) &gt; (low[3]=3)，所以low[4] = 3; 依此类推low[5]=3;且直到dfs回溯到结点2的时候才会进行出栈操作，因为2时强连通分量的根节点。 不难看出，依次出栈的时3、4、5、2，这四个结点为一个强连通分量 最后dfs回溯到最开始的入口，结点1出栈 由此的强连通分量有3个，分别是：（1）、（6）、（3，4，5，2） tarjan算法模板链式前向星模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859struct Edge&#123; int net; int to; int w;&#125;edge[maxn];int head[maxn], cnt=0;//1.void add_dege(int u, int v, int w)&#123; edge[cnt].to = v; edge[cnt].net = head[u]; edge[cnt].w = w; head[u] = cnt++;&#125;int dfn[maxn], low[maxn], belong[maxn];//2.int index=0, Bcnt;//3.bool instack[maxn];stack&lt;int&gt; s;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; s.push(u);instack[u] = true; for(int i=head[u]; i!=-1; i=edge[i].net) &#123; int v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[v], low[u]); &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++;int v; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(v!=u); &#125;&#125;void solve()&#123; Bcnt = index = 0; memset(dfn, 0, sizeof dfn); while(!s.empty())s.pop(); for(int i=0; i&lt;n; i++)//4. if(!dfn[i])//5. tarjan(i);&#125; head[u]记得初始化，初始化为-1。 belong数组值相同的结点属于同一个强连通分量。 Bcnt用于划分强连通分量 要从每个结点都进行一次tarjan，否则有些不可达结点就无法划分强联通分量，n为结点数 dfn数组初始化为0，当dfn[u]的值不为0的时候则说明被访问过了 邻接矩阵模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546int mp[maxn][maxn];//1.int dfn[maxn], low[maxn], belong[maxn];int index=0, Bcnt;bool instack[maxn];stack&lt;int&gt; s;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; s.push(u);instack[u] = true; for(int v=0; v&lt;n; v++)//2. &#123; if(mp[u][v]==-1) continue; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[v], low[u]); &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; int v; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(v!=u); &#125;&#125;void solve()&#123; Bcnt = index = 0; memset(dfn, 0, sizeof dfn); while(!s.empty())s.pop(); for(int i=0; i&lt;n; i++) if(!dfn[i]) tarjan(i);&#125; 邻接矩阵，当值为-1时表示不连通 n为结点数 邻接表模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253vector&lt;pair&lt;int, int&gt; &gt; G[maxn];//1.int dfn[maxn], low[maxn], belong[maxn];int index=0, Bcnt;bool instack[maxn];stack&lt;int&gt; s;void add_eage(int u, int v, int w)&#123; G[u].push_back(make_pair(w, v)); //G[v].push_back(make_pair(w, u));&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; s.push(u);instack[u] = true; for(int i=0; i&lt;G[u].size(); i++) &#123; int v = G[u][i].second; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[v], low[u]); &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; int v; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(v!=u); &#125;&#125;void solve()&#123; for(int i=0; i&lt;n; i++)//2. G[i].clear(); Bcnt = index = 0; memset(dfn, 0, sizeof dfn); while(!s.empty())s.pop(); for(int i=0; i&lt;n; i++) if(!dfn[i]) tarjan(i);&#125; 用vector和pair实现邻接表，pair的first为路径权重，pair的second为另一端结点 初始化邻接表 例题HDU1269题意：给你一个图，让你判断这个图是不是一整个强连通分量 题解：没什么可说的，tarjan模板题。需要注意的是有的能给的图只有点没有边，所以结束条件需要时m和n同时为0时才行。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;struct Edge&#123; int to, net;&#125;edge[maxn];int head[maxn], cnt=0;int dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn];bool instack[maxn];stack&lt;int&gt; s;void addedge(int u, int v)&#123; edge[cnt].to = v; edge[cnt].net = head[u]; head[u] = cnt++;&#125;void init()&#123; cnt = index = Bcnt = 0; memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(head, -1, sizeof head); memset(instack, 0, sizeof instack); memset(belong, 0, sizeof belong); while(!s.empty())s.pop();&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; instack[u] = true; s.push(u); int v; for(int i = head[u]; i!=-1; i=edge[i].net) &#123; v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); if(low[v]&lt;low[u]) low[u] = low[v]; &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125;while(u!=v); &#125;&#125;int main()&#123; while(cin &gt;&gt;n &gt;&gt;m &amp;&amp; n+m) &#123; init(); for(int i=0; i&lt;m; i++) &#123; int u, v; cin &gt;&gt;u &gt;&gt;v; addedge(u, v); &#125; for(int i=1; i&lt;=n; i++) if(!dfn[i]) tarjan(i); int flag = belong[1]; bool f = true; for(int i=1; i&lt;=n; i++) if(belong[i]!=flag) f = false; if(!f) cout &lt;&lt;"No" &lt;&lt;endl; else cout &lt;&lt;"Yes" &lt;&lt;endl; &#125; return 0;&#125; HDU1827题意：给你一些人的联系方式，但是这种联系方式时有向的，即x可以联系y不代表y可以联系到x，其实就是有向图。也给出你联系每个人的花费，如果可以让别人帮忙联系，就可以不需要花费话费。求最少需要联系多少人和花费多少话费。 题解：这道题没有那么直接，但是也能看出和强连通分量有关。这道题要求的是没有入边的强连通分量的个数，并且求出这些没有入边的强联通分量中花费最小的人。为什么是没有入边的强连通分量而不是强连通分量，因为有如入边的强联通分量可以被其他人通知到，就不需要你再亲自通知了。（一开始我理解成强连通分量的个数了(&gt;_&lt;) ）这题要用scnaf和printf，不能用cin和cout，数据量大，会超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4+10;const int INF = 1&lt;&lt;30;struct Edge&#123; int to, net;&#125; edge[maxn];int head[maxn], cnt=0;int dfn[maxn], low[maxn], index, Bcnt, n, m, belong[maxn], fee[maxn], cost[maxn], ans;bool instack[maxn], in[maxn];//1.stack&lt;int&gt; s;void addedge(int u, int v)&#123; edge[cnt].to = v; edge[cnt].net = head[u]; head[u] = cnt++;&#125;void init()&#123; cnt = index = ans = Bcnt = 0; memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(head, -1, sizeof head); memset(instack, 0, sizeof instack); memset(belong, 0, sizeof belong); memset(in, 0, sizeof in); for(int i=0; i&lt;maxn; i++) cost[i]=INF; memset(fee, 0, sizeof fee); while(!s.empty()) s.pop();&#125;void tarjan(int u)&#123; dfn[u] = low[u] = ++index; instack[u] = true; s.push(u); int v; for(int i = head[u]; i!=-1; i=edge[i].net) &#123; v = edge[i].to; if(!dfn[v]) &#123; tarjan(v); if(low[v]&lt;low[u]) low[u] = low[v]; &#125; else if(instack[v] &amp;&amp; dfn[v]&lt;low[u]) low[u] = dfn[v]; &#125; if(dfn[u]==low[u]) &#123; Bcnt++; do &#123; v = s.top(); s.pop(); belong[v] = Bcnt; instack[v] = false; &#125; while(u!=v); &#125;&#125;int main()&#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(); for(int i=1; i&lt;=n; i++) scanf("%d", &amp;fee[i]); for(int i=0; i&lt;m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; for(int i=1; i&lt;=n; i++) if(!dfn[i]) tarjan(i); int cnt=Bcnt; for(int i=1; i&lt;=n; i++)//2. for(int j=head[i]; j!=-1; j=edge[j].net) if(belong[i]!=belong[edge[j].to] &amp;&amp; !in[belong[edge[j].to]]) &#123; in[belong[edge[j].to]] = true; cnt--; &#125; for(int i=1; i&lt;=n; i++)//3. if(!in[belong[i]]) cost[belong[i]] = min(cost[belong[i]], fee[i]); for(int i=1; i&lt;=Bcnt; i++) if(!in[i]) ans+=cost[i]; printf("%d %d\n", cnt, ans); &#125; return 0;&#125; in数组表示该强连通分量是否有入边，为true则有，false则没有。 这个for循环求出有入边的强连通分量，即看看每个点的入边是否和自己在同一个强连通分量中即可。cnt为没有入边的个数。 求出没有入边的强连通分量中的最小花费，cost[i]代表第i个强连通分量的花费 参考： BYVoid有向图强连通分量的tarjan算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[差分约束系统是求解一组特殊的不等式组的方法。 差分约束举例差分约束是有n个变量和m个不等式组成的。其中每个不等式都是形如：$x_i-x_j \leq b_k(i,j\in[1,n], k\in[1,m])$ 或 $x_i-x_j \geq b_k(i,j\in[1,n], k\in[1,m])$ 。 其中x为n个变量，b为m个不等式右边的值，用b的值来约束x的差称为差分约束。求一组解：$x_1=a_1,\quad x_2=a_2,\cdots x_n=a_n$使得所有约束条件(即m个不等式)均成立，则称差分约束有解，否则无解。 例如：$$(1)x_1-x_3 \leq 5;\quad(2)x_3-x_5 \leq 4;\quad$$$$(3)x_3-x_2 \leq 1;\quad(4)x_1-x_5 \leq 10;\quad(5)x_2-x_5 \leq 2;\quad$$ 观察$ x_1-x_5 $的关系，有如下三种关系： (4) $x_1-x_5 \leq 10$ (1)+(2) $x_1-x_5 \leq 9$ (1)+(3)+(5) $x_1-x_5 \leq 8 $ 因为要满足所有等式的关系，所以取其中最大的3.$x_1-x_5 \leq 8$ 因为8一定小于9和10嘛，如果$x_1-x_5$小于等于8了，那他们一定小于等于9和10。 最短路问题观察可发现 $x_i-x_j \leq b_k$ 可转换为：$x_i \leq b_k+x_j$ 。与求最短路公式中的dis[j]&lt;dis[i]+w[i, j]非常相似，那差分约束问题是不是也可以转化成最短路问题来求解呢？肯定是可以的！先来看个例子： 仔细观察图中可发现总共有三条路径： 5 -&gt; 1 长度为10 5 -&gt; 3 -&gt; 1 长度为9 5 -&gt; 2 -&gt; 3 -&gt; 1 长度为8 很容易发现从5到1的最短路径是8。那为什么求差分约束问题能和最短路问题联系到一起呢？此处要先了解最短路知识，不懂的可以看一看我前面写的博客：1.dijkstra 2.SPFA 3.Floyd 差分约束和最短路问题对于每个不等式$x_i-x_j \leq b_k$，我们都从结点j向结点i连一条长度为$b_k$的有向边。此时再看上面给出的那些不等式所转化成的图，是否和给出的图一样呢，最后求解的答案也一样。那么我们将差分约束问题转化成最短路问题，由最短路知识可知，当图中存在可达到的负环时，最短路一定无解。所以可以用SPFA来判断该差分约束问题是否有解。 这时候就有一个问题了，在最短路中有些点是不可达的，当遇到不可达的负环用SPFA一定判断不出来，但此时差分约束却是无解的。怎么办呢？有两种方法，其实本质都是一样的： 我们新定义一个结点，可以是$x_0$，让它向所有其它结点连一条边，让这些边的权值为0。因为SPFA是一个bfs的过程(有些题目需要把spfa改成dfs的形式，但是并不影响它访问的结点个数，只是访问顺序不一样)，所以从这个结点出发一定能到达所有结点，而且不会影响结果的正确性。 第二种方法就比较暴力了，现在问题是有的结点访问不到怎么办，spfa又是求单源最短路，那我们直接一个for循环，每个结点都当一次源点，求n次单源最短路，这样就能访问到所有结点了。 两种方法的时间复杂度我不太会分析，但是感觉好像差不多一样的。 变化技巧不等式转化有时候题中会给出三种不等式，但是求最短路只能有一种不等式，这时候我们就可以把其他不等式变化成一样的不等式，进而转化成图。 题意 转化 连边 $x_i-x_j \leq b_k$ $x_i-x_j \leq b_k$ add(j, i, $b_k$) $x_i-x_j \geq b_k $ $x_j-x_i \leq -b_k$ add(i, j, -$b_k$) $x_i=x_j$ $x_i-x_j \leq 0$, $x_j-x_i \leq 0$ add(i, j, 0), add(j, i, 0) 最短路与最长路和差分约束的关系有最短路了一定也有最长路，那他们和差分约束有什么关系呢？ 当我们要求差分约束的最小值时，一定希望所有不等式都是大于等于号，这样求出来的一定是最小值。但是当我们有m个约束条件（即不等式），我们想要满足所有大于等于的不等式，我们一定得找到所有$ b_k $中最大的那一个，这样如果满足了最大的那个$ b_k $不等式，其他的大于等于不等式也一定都满足了。所以求$x_i-x_j$的最小值，就是求图中的最长路。所以，求最长路就是求差分约束中的最小值。求最长路的时候有正环则无解。 同理求最短路就是求差分约束的最大值。求最短路的时候有负环则无解。 什么？你问我最长路怎么求？把最短路算法中的小于号改成大于号不就行了。 例题洛谷P1993 参考 夜深人静写算法（四）- 最短路和差分约束 OI-WiKi（一个算法竞赛的百科） 维基百科：差分约束系统 P1993小K的农场 题解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的边存储--链式前向星]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%9B%BE%E7%9A%84%E8%BE%B9%E5%AD%98%E5%82%A8-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%2F</url>
    <content type="text"><![CDATA[链式前向星是在看差分约束的题的时候偶然间看到的，一开始没太重视它，感觉好像没怎么听说过。还要定义结构体，而且需要辅助数组，感觉挺麻烦的。还不如直接用STL的vector+pair定义的邻接表好用。但是后来发现大家写SPFA的时候都用的链式前向星，感觉还是写个博客学习一下吧，以前都没听说过，太菜了。。。 边存储结构存的都是有向边！！！ 优缺点优点 适用范围广，基本上所有图论的题都能用链式前向星来存储。 存储效率高，像邻接表一样不会存储不存在的边 可以用来替代邻接表，用vector实现邻接表好像容易爆内存(看别人说的)好像也确实，vector在容量不够时会重新开辟一个两倍于原来大小的数组。 缺点 邻接表的缺点它都有， 无法判断重边(必须遍历查找) 无法操作某个特定的边(必须遍历查找) 相对于邻接矩阵来说不容易实现和理解 代码实现1234567891011121314151617struct Edge&#123; int net;//1. int to; int w;&#125;edge[maxn];int head[maxn], cnt=0;//2.void add_dege(int u, int v, int w)&#123; edge[cnt].to = v; edge[cnt].net = head[u];//3. edge[cnt].w = w; head[u] = cnt++;&#125;for(int i=head[u]; i!=-1; i=edge[i].net)//4. 注释： net是next，有时候定义next可能会和系统关键字重复，所以定义为net。net指向当前边的出发结点的下一条边在edge数组中的下标。SPFA是一个bfs的过程，进行广搜时会先遍历某个顶点的所有出边，net即指向当前结点的下一条出边。to即当前边的尾结点。w即权重。 head[u]即存储u结点的第一个出边在edge数组中的下标。cnt即记录当前存储到edge数组的第几位了，用来设置数组下标。 链式前向星是反着存储的，即先输入的边存在后面，有些类似于栈，后进先出。当a的第一条出边存入edge数组中，net等于head[u]，即-1。(所有head初始化为-1，-1表示没有边存入)之后head[u]被赋值为cnt，即刚输入的那条边在edge数组中的下标。当a的第二条边存入edge数组时，net等于head[u]，此时head[u]存的是上一次存储以u为出边的边在edge数组中的下标。每次head[u]存储的都是上一个u的边，所以遍历的时候是先遍历最后输入u的边。 链式前向星遍历结点u所有出边的方法，当等于-1时表示没有下一条边了，遍历结束。 举例 输入顺序为： u = 0 v = 1 u = 1 v = 3 u = 0 v = 2 u = 2 v = 3 u = 1 v = 2 u = 3 v = 4 u = 4 v = 2 手动模拟一下 edge[0].to = 1 edge[0].net = -1 head[0] = 0 cnt = 0 edge[1].to = 3 edge[1].net = -1 head[1] = 0 cnt = 1 edge[2].to = 2 edge[2].net = 0 head[0] = 2 cnt = 2 edge[3].to = 3 edge[3].net = -1 head[2] = 0 cnt = 3 edge[4].to = 2 edge[4].net = 0 head[1] = 4 cnt = 4 edge[5].to = 4 edge[5].net = -1 head[3] = 5 cnt = 5 edge[6].to = 2 edge[6].net = -1 head[4] = 6 cnt = 6 上图中0的出边有两条，在edge数组中的存储位置分别为0、2，最后head[0] = 2；当遍历以0为起点的边时，先从edge[2]开始遍历，可发现edge[2].net = 0;即以0为起点的最后一条边。可看出，遍历和输入顺序是相反的，但是并不影响结果。 参考 不知道为什么404了 ACM图论之存图方式]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>图的存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路--Floyd]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-Floyd%2F</url>
    <content type="text"><![CDATA[Floyd是用来求全局任意两点之间的最短路的。 Floyd很好理解，依次用每个点去松弛其它所有边，感觉没什么好讲的。理解了dijkstra和SPFA之后，感觉Floyd就很简单易懂了，直接上代码吧。 时间复杂度：O(n^3) 空间复杂度：O(n^2) 算法实现1234for(int k=0; k&lt;n; k++)//1. for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); 注释： 其中n为图中顶点个数，k依次枚举所有顶点去松弛其它所有边。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>最短路</tag>
        <tag>图论</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路--SPFA]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA%2F</url>
    <content type="text"><![CDATA[SPFA是个很神奇的算法，他在一般情况下时间会跑的很快，肯定有人想用SPFA来代替dijkstra，但是有一种特殊的数据专门来卡SPFA，只能让dijkstra过，SPFA过不去，那就是网格图，我稍后会讲为什么网格图可以卡掉SPFA。 但是为什么SPFA跑不过dijkstra，大家还要用SPFA？因为dijkstra只能计算不带负环的图，当图中出现负环，dijkstra就会一直卡在负环里出不来了。如果不太懂可以看一看我的上一篇博客：Dijkstra 当图中存在可到达的负环，则该图一定不存在最短路，因为负环可以一直当做最短路来松弛其他边，那么最短路就能无限小，所以不存在最短路。 SPFA也是用来求单源最短路，它当然也不能在存在可达负环的时候计算最短路，但是他有一个神奇的功能：判断图中是否存在可达负环。 Bellman-FordSPFA是Bellman-Ford的队列优化，在一般情况下比Bellman-Ford快很多。这里介绍Bellman-Ford是希望可以更好地理解SPFA，因为两者本质区别不大。 算法步骤算法总共跑n-1轮就能确定所有点的最短路。总共有n个点，x1, x2, x3, x4…xn，其中x1为源点，第一轮一定可以确定离源点最近的点的最短路，即x2的最短路。依次类推，如果图中不存在负环，则一定能在n-1轮推出所有点的最短路。 算法实现下面把敦爷讲课的时候的代码放出来： 12345678for(int k=1; k&lt;=n-1; k++)&#123; for(int i=1; i&lt;m; i++) &#123; if(dis[v[i]] &gt; dis[u[i]]+w[i]) dis[v[i]] = dis[u[i]]+w[i] &#125;&#125; SPFA观察上面的Bellman-Ford可发现，当dis[u]没有被更新的时候，它依然会用dis[u]去松弛其它边，这样就做了很多冗余的操作，我们用一个队列来优化它，就是当有一个点被更新了，如果这个点没在队列里面，就把它放到队列里面去。这样一个点很久没有被更新过的话，就不会用它去更新其它边。 算法实现此处建议先看懂我的上一篇博客：Dijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int dis[maxn], viscnt[maxn];bool inq[maxn];vector&lt;pair&lt;int, int&gt; &gt; G[maxn];//1.void add_eage(int s, int t, int w)&#123; G[s].push_back(make_pair(w, t));//2. G[t].push_back(make_pair(w, s));//3.&#125;void init(int n)//4.&#123; for(int i=0; i&lt;n; i++) G[i].clear();&#125;bool SPFA(int n, int s)//5.&#123; for(int i=0; i&lt;n; i++)//6. &#123; dis[i] = (i==s)?0:INF; inq[i] = false; viscnt[i] = 0; &#125; queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(dis[s], s));//7. inq[s] = true; while(!q.empty()) &#123; pair&lt;int, int&gt; p = q.front(); int x = p.second;//8. q.pop(); inq[x] = false; if(viscnt[x]++&gt;n)//9. return true; for(int i=0; i&lt;G[x].size(); i++)//10. &#123; int y=G[x][i].second, w=G[x][i].first; if(dis[x]+w&lt;dis[y])//11. &#123; dis[y] = dis[x]+w; if(!inq[y]) &#123; q.push(make_pair(dis[y], y)); inq[y] = true; &#125; &#125; &#125; &#125; return false;&#125; 注释： viscnt[i]用来计数第i个点被更新了几次，如果更新次数超过n，则说明图中存在负环。inq[i]表示第i个点是否在队列里面。存放pair的vector用来存放边和边权，G[i] [j]存放的是和结点i相连的第j条边。G[i] [j].second存放的是和结点i相连的第j条边的另一个端点。G[i] [j].first存放的是和结点i相连的第j条边的权重。maxn为自己定义的常量。 将边添加至vector中，s、w、t 说明同上。 无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。 初始化vector，清空所有先前加入的边。 SPFA当图中存在负环时返回true，不存在时返回false。 初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。viscnt和inq设为0和false。 将源点压入队列。inq[s]设为true。 依次取队首元素。取出后inq[i]设为false。 每次访问一个点，令这个点的viscnt++，当这个点的访问次数超过n次，则说明图中存在负环。 依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重。 进行松弛操作，如果某个点松弛操作成功，则把它压入队列。 如何卡SPFA因为SPFA没回更新的时候用的是一条边去更新，被更新过的点入队。 比如说我们有一条链 当我们用边0-1去更新后面所有边之后，如果边0-1又被更新，则后面的所有边都要被依次再更新一遍。 这样SPFA的时间复杂度就会变得非常高 参考 夜深人静写算法（四）- 最短路和差分约束 2019ccpc夏令营敦爷讲的图论]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>最短路</tag>
        <tag>图论</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路--Dijkstra]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%9C%80%E7%9F%AD%E8%B7%AF--Dijkstra%2F</url>
    <content type="text"><![CDATA[Dijkstra是单源最短路算法，用于求正权图源点到每个顶点的最短路。Dijkstra用到了一些BFS的思想 算法步骤 初始化dis数组和vis数组。 dis[i]表示源点到第i个点的距离，初始化为INF，表示无穷大。（INF为自己定义） vis[i]数组表示第i个点的最短路是否用于处理过未求出最短路的点。（当用优先队列的时候则不用vis数组） 找出当前最短dis[i]，并且vis[i]为false的点。如果找不到，则最短路求解完成，算法结束。 令vis[i]为true，表示已经使用过该最短路处理其dis[i]，防止重复使用。依次遍历其余所有点，令dis[j] = min(dis[j], dis[i]+w[i] [j]) w[i] [j]表示点i到点j的距离。这一步表示源点到i加上i到j的距离和源点到j的距离哪个小。 算法实现邻接矩阵版时间复杂度为O(n*n) n为顶点数 123456789101112131415161718192021222324252627void dijkstra(int n, int s)//1.&#123; for(int i=0; i&lt;n; i++)//2. &#123; dis[i] = w[s][i]; vis[i] = false; &#125; dis[s] = 0; for(int i=0; i&lt;n; i++)//3. &#123; int mn = INF, x; for(int j=0; j&lt;n; j++)//4. if(!vis[j] &amp;&amp; dis[j]&lt;mn) &#123; mn = dis[j]; x=j; &#125; if(mn==INF)//5. return; vis[x] = true;//6. for(int j=0; j&lt;n; j++) dis[j] = min(dis[j], dis[x]+w[x][j]); &#125;&#125; 注释： n为结点个数，s为源点。 初始化dis数组和vis数组 依次遍历每个结点 找出当先未使用过的最短路，并把下标存入x 如果全部使用过则算法结束 vis[x]设为true，比较dis[j]和dis[x]+w[x] [j]的大小 优先队列版用优先队列优化dijkstra大部分时间优于普通版，但是在完全图时普通版更好。 时间复杂度：O((m+n)logm) 其中n为顶点数，m为边数。所以当完全图时普通版更好。 1234567891011121314151617181920212223242526272829303132333435363738394041int dis[maxn];vector&lt;pair&lt;int, int&gt; &gt; G[maxn];//1.void add_eage(int s, int t, int w)&#123; G[s].push_back(make_pair(w, t));//2. G[t].push_back(make_pair(w, s));//3.&#125;void init(int n)//4.&#123; for(int i=0; i&lt;n; i++) G[i].clear();&#125;void dijkstra(int n, int s)&#123; for(int i=0; i&lt;n; i++)//5. dis[i] = (i==s)?0:INF; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q;//6. q.push(make_pair(dis[s], s));//7. while(!q.empty()) &#123; pair&lt;int, int&gt; p = q.top(); int x = p.second;//8. q.pop(); for(int i=0; i&lt;G[x].size(); i++) &#123; int y=G[x][i].second, w=G[x][i].first;//9. if(dis[x]+w&lt;dis[y])//10. &#123; dis[y] = dis[x]+w; q.push(make_pair(dis[y], y)); &#125; &#125; &#125;&#125; 注释： 存放pair的vector用来存放边和边权，因为pair比较大小是first优先，所以pair的first放的是权重。G[i] [j]存放的是和结点i相连的第j条边。G[i] [j].second存放的是和结点i相连的第j条边的另一个端点。G[i] [j].first存放的是和结点i相连的第j条边的权重。maxn为自己定义的常量。 将边添加至vector中，s、w、t 说明同上。 无向图的边是无向的，所以需要在G[s]和G[w]中都加入一条边。有向图不需要这一步。 初始化vector，清空所有先前加入的边。 初始化dis数组，将源点到源点的距离设置为0，其他的设置为INF(自己定义)。 定义优先队列，第一个参数为数据类型，比较pair类型，pair的first优先。第二个参数为存储容器，和先前存边的vector定义相同。第三个参数表示小顶堆(greater为小顶堆，less为大顶堆)。 将源点压入队列。 x存放当前未访问过的权值最小边的一端结点编号。 依次遍历与x相连的边，y表示与x相连的边的另一端结点编号。w表示x到y路径权重 该步骤通邻接矩阵dijkstra相似 模板例题hdoj1874 参考 夜深人静写算法（四）- 最短路和差分约束 dijkstra几大模板（这里面的优先队列模板好像时错的，我只参考了他的stl用法） C++ pair的比较大小]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>最短路</tag>
        <tag>dijkstra</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集是一种树型数据结构，用于查找不相交的子集，并将他们合并在一起，简称并查集。并查集分为拆分、查找和合并三个操作。 并查集查找 pre数组记录所有结点的前驱结点，根节点的前驱结点是它自己 find函数先找到x的根节点 12345678int pre[1000];//1.int find(int x)//2.&#123; int r=x; while ( pre[r] != r )//3. r=pre[r]; return r ;&#125; 注释： 记录前驱结点 查找根节点 找到根节点 r 合并 join函数先找到两个变量的根节点 ​ 如果他们相同则说明两个变量在同一个集合中 ​ 如果不同则将其中一个根节点设置为另外一个根节点的前驱 123456void join(int x,int y)//1.&#123; int fx=find(x),fy=find(y); if(fx!=fy) pre[fx ]=fy;&#125; 注释： 判断x y是否连通，如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起。 并查集的优化路径压缩路径压缩是在寻找根结点的过程中，将子集中所有的点的前驱设置为根结点。 为什么要进行路径压缩呢？因为在并查集合并过程中，他有可能变成一个单链表，这样每次寻找根结点要遍历子集中所有的结点。进行路径压缩之后，每次寻找根结点只需访问他的父结点就可找到根结点。 优化后的find函数： 12345678910111213141516int pre[1000 ];int find(int x) &#123; int r=x; while ( pre[r] != r ) r=pre[r]; int i=x , j ; while( i != r )//1. &#123; j = pre[ i ];//2. pre[ i ]= r ;//3. i=j; &#125; return r ;&#125; 注释： 路径压缩 在改变上级之前用临时变量j记录下他的值 把上级改为根节点 按秩(Rank)合并按秩合并就是在合并过程中将元素所在深度小的集合合并到元素所在深度大的集合 为什么要按秩合并呢？因为如果将元素深度大的集合合并到小的集合，那么合并后的集合深度则等于较大的深度加一。如果将深度小的集合合并到深度大的集合，则合并后的集合深度不变。 优化后的join函数： 12345678910111213void join(int x, int y)&#123; int fx=find(x),fy=find(y); if(rank[fx]&gt;rank[fy])//1. pre[fy] = pre[fx];//2. else &#123; pre[fx] = fy; if(rank[fx]==rank[fy])//3. rank[fy]++; &#125;&#125; 注释： rank数组为当前结点秩的值 只需要比较根结点的rank值就够了 修改时也只用修改根结点的rank值 并查集的精简实现12345678910void init(int n) &#123; for(int i=1; i&lt;=n; i++) pre[i]=i; &#125;int find(int x) &#123; return pre[x]=x?x:pre[x]=get(pre[x]); &#125;//1.void join(int x, int y) &#123; pre[get(x)] = get[y]; &#125;void join(int x, int y)&#123;//2. pre[rank[find(x)&gt;rank[find(y)?find(y):find(x)] = pre[rank[find(x)&gt;rank[find(y)?find(x):find(y)]; if(rank[find(x)]==rank[find(y)]) rank[find(y)]++;&#125; 注释： 根结点的pre为0。 带秩合并，还没验证，不能确定对错。 参考： 维基百科：并查集 并查集详解——图文解说，简单易懂（转） 并查集笔记&amp;模板]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可以评论了！！！]]></title>
    <url>%2F2018%2F11%2F02%2F%E5%8F%AF%E4%BB%A5%E8%AF%84%E8%AE%BA%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[来吐槽吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello Word!]]></title>
    <url>%2F2018%2F11%2F01%2FHello-Word%2F</url>
    <content type="text"><![CDATA[HELLO WORD!!!]]></content>
  </entry>
</search>
